<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>算法 | Kerolt's Blog</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/categories/%E7%AE%97%E6%B3%95/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.e86fca84f55806041871ed7351917eaee2448b47fbc63452ca15c8e099639644.css integrity="sha256-6G/KhPVYBgQYce1zUZF+ruJEi0f7xjRSyhXI4JljlkQ=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/categories/%E7%AE%97%E6%B3%95/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/categories/%E7%AE%97%E6%B3%95/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/categories/%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="算法"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="算法"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/categories/>Categories</a></div><h1>算法
<a href=/categories/%E7%AE%97%E6%B3%95/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>84. 柱状图中最大的矩形</h2></header><div class=entry-content><p>单调栈中保存每个柱子在 heights 中的下标，从栈底到栈顶的元素对应的柱子的高度是单调递增的。
顺序遍历 heights，如果 heights[i] 比栈顶对应柱子高度更小（heights[i] &lt; heights[st.top()]），那么说明 heights[st.top()] 这个高度在当前柱子加入后已经没有了作用（现在最小的高度是当前柱子，那么要算矩形面积的时候也只会用 heights[i] 来作为矩形的高）。
我们每次计算的矩形为 [栈顶元素代表的矩形, i对应的矩形)：
在弹出栈顶元素==后==，矩形的宽（weight）应该为 i - st.top() - 1，如果栈为空了就为 i - (-1) - 1 -> i。
class Solution { public: int largestRectangleArea(vector&lt;int>& heights) { stack&lt;int> st; int res = 0; heights.push_back(-1); for (int i = 0; i &lt; heights.size(); ++i) { while (!st.empty() && heights[i] &lt; heights[st.top()]) { int h = heights[st.top()]; st.pop(); int w = i; // 即 w = i - (-1) - 1 if (!st.empty()) { w = i - st.top() - 1; } res = max(res, h * w); } st.push(i); } return res; } };</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;103 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 84. 柱状图中最大的矩形" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/84.-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>875. 爱吃香蕉的珂珂</h2></header><div class=entry-content><p>https://leetcode.cn/problems/koko-eating-bananas/
假设每小时吃 max(piles) 根香蕉，那么按照题意（向上取整）来说就只要 piles.length 个小时就可以吃完。而注意提示中的：piles.length &lt;= h &lt;= 10^9，这说明每小时吃 max(piles) 根香蕉已经是最大的速度了，再快也没用了。因此需要去找比 max(piles) 小的且满足题意的数。
那取 max(piles) 作为右边界，左边界取 1 （因为总不可能不吃吧~），然去通过二分去找最小的满足条件的速度。
class Solution { public: int minEatingSpeed(vector&lt;int>& piles, int h) { int left = 1, right = *ranges::max_element(piles); auto check = [&](int x) { long long sum{}; for (int p : piles) { sum += (p + x - 1) / x; } return sum &lt;= h; }; while (left &lt;= right) { int mid = (left + right) >> 1; if (check(mid)) { right = mid - 1; } else { left = mid + 1; } } return left; } }; 相似题目：
https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/</p></div><footer class=entry-footer><span title='2025-05-07 00:00:00 +0000 UTC'>2025-05-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;103 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 875. 爱吃香蕉的珂珂" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3488. 距离最小相等元素查询</h2></header><div class=entry-content><p>https://leetcode.cn/problems/closest-equal-element-queries/
通过示例1来分析：
输入： nums = [1,3,1,4,1,3,2], queries = [0,3,5] 输出： [2,-1,3] 对于queries[0] = 0, nums[queries[0]] = 1来说，其在nums中的下标集合为p = [0, 2, 4]，由于nums是一个循环数组，所以按理来说数组p的第一个元素往左需要能找到最后一个元素，最后一个元素往右能找到第一个元素。
n 为 nums 的长度， 在下标列表前面添加 4−n=−3，相当于认为在 −3 下标处也有一个 1。 在下标列表末尾添加 0+n=7，相当于认为在 7 下标处也有一个 1。
题意是需要我们查询一个 nums 中的下标 x，与 任意 其他下标 j（满足 nums[j] == nums[x]）之间的 最小 距离。我们用哈希表将每个相同值的元素的下标收集起来作为集合 p，然后在查询时使用二分查询 x 在其对应集合中的位置 i，则左边最近的元素下标为 p[i - 1]，右边最近元素下标为 p[i + 1]，那么最小距离就是 min(p[i + 1] - x, x - p[i - 1])。
class Solution { public: vector&lt;int> solveQueries(vector&lt;int>& nums, vector&lt;int>& queries) { unordered_map&lt;int, vector&lt;int>> m; int n = nums.size(); // 将每个相同值的元素的下标收集起来 for (int i = 0; i &lt; nums.size(); ++i) { m[nums[i]].push_back(i); } // 增加左右两个哨兵 for (auto& [_, p] : m) { int t = p[0]; p.insert(p.begin(), p.back() - n); p.push_back(n + t); } for (int& x : queries) { auto& p = m[nums[x]]; if (p.size() == 3) { // 由于添加了两个哨兵，所以当集合长度为 3 时说明集合中实际只有1个元素，即这个元素在 nums 中是唯一的 x = -1; } else { int i = ranges::lower_bound(p, x) - p.begin(); x = min(p[i + 1] - x, x - p[i - 1]); } } return queries; } };</p></div><footer class=entry-footer><span title='2025-04-16 00:00:00 +0000 UTC'>2025-04-16</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;171 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 3488. 距离最小相等元素查询" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/3488.-%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>259. 关闭分部的可行集合数目</h2></header><div class=entry-content><p>难度：Hard
标签：位运算；图论；Floyd算法
链接： https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/
...</p></div><footer class=entry-footer><span title='2024-07-17 00:00:00 +0000 UTC'>2024-07-17</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;251 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 259. 关闭分部的可行集合数目" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/259.-%E5%85%B3%E9%97%AD%E5%88%86%E9%83%A8%E7%9A%84%E5%8F%AF%E8%A1%8C%E9%9B%86%E5%90%88%E6%95%B0%E7%9B%AE/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>76. 最小覆盖子串</h2></header><div class=entry-content><p>难度：Hard
标签：哈希表；滑动窗口；字符串
链接： https://leetcode.cn/problems/minimum-window-substring/description/
...</p></div><footer class=entry-footer><span title='2024-06-15 00:00:00 +0000 UTC'>2024-06-15</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;131 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 76. 最小覆盖子串" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>30. 串联所有单词的子串</h2></header><div class=entry-content><p>难度：Hard
标签：哈希表、字符串、滑动窗口
链接：https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/
...</p></div><footer class=entry-footer><span title='2024-06-07 00:00:00 +0000 UTC'>2024-06-07</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;147 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 30. 串联所有单词的子串" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/30.-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>股票问题第二波</h2></header><div class=entry-content><p>上一篇文章：股票问题与状态机dp
本篇文章涉及题目如下：
123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 309. 买卖股票的最佳时机含冷冻期 ...</p></div><footer class=entry-footer><span title='2024-04-12 00:00:00 +0000 UTC'>2024-04-12</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 股票问题第二波" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%AC%AC%E4%BA%8C%E6%B3%A2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>股票问题与状态机dp</h2></header><div class=entry-content><p>本篇文章思路来源于 @bilibili/灵茶山艾府
题目描述：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii
相对于买卖股票的最佳时机I，该问题可以多次买入和卖出股票以获取最大利益
...</p></div><footer class=entry-footer><span title='2024-04-11 00:00:00 +0000 UTC'>2024-04-11</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;324 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 股票问题与状态机dp" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BAdp/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【链表】判断回文链表</h2></header><div class=entry-content><p>https://leetcode.cn/problems/palindrome-linked-list/
（1）将链表转化为数组进行比较 比较呆板的做法，空间复杂度为O(n)​。
class Solution { public: bool isPalindrome(ListNode* head) { vector&lt;int> arr; ListNode* p = head; while (p) { arr.push_back(p->val); p = p->next; } int n = arr.size(); for (int i = 0, j = n - 1; i &lt; j; i++, j--) { if (arr[i] != arr[j]) return false; } return true; } }; （2）递归 链表也具有递归性质，二叉树也不过是链表的衍生。
利用后序遍历的思想：
先保存头结点（left，全局变量），然后递归至最后（最深）的结点（right），然后比较left​和right​的值；如果相等，由递归栈返回上一层（也即right向左走），再操作left向右走，这样就实现了left和right的双向奔赴。
class Solution { private: ListNode* left_ = nullptr; bool Traverse(ListNode* right) { if (!right) return true; bool res = Traverse(right->next); res = res && (left_->val == right->val); left_ = left_->next; return res; } public: bool isPalindrome(ListNode* head) { left_ = head; return Traverse(head->next); } }; （3）优化递归 利用方法二，看似是没有使用到额外空间了，但实际上还有递归所带来的函数调用栈的开销，其空间复杂度也为O(n)​。
因此可以利用双指针的思想，找到链表的中间结点后，将其后面的结点反转。
using ListNodePtr = ListNode*; class Solution { private: ListNode* Reverse(ListNode* head) { ListNodePtr cur = head, pre = nullptr; while (cur) { ListNodePtr ne = cur->next; cur->next = pre; pre = cur; cur = ne; } return pre; } public: bool isPalindrome(ListNode* head) { ListNodePtr fast = head, slow = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } if (fast) slow = slow->next; ListNodePtr left = head; ListNodePtr right = Reverse(slow); while (right) { if (left->val != right->val) return false; left = left->next; right = right->next; } return true; } };</p></div><footer class=entry-footer><span title='2023-11-10 00:00:00 +0000 UTC'>2023-11-10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;204 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【链表】判断回文链表" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>