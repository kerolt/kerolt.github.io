<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>K8s on Kerolt&#39;s Blog</title>
    <link>https://kerolt.github.io/categories/k8s/</link>
    <description>Recent content in K8s on Kerolt&#39;s Blog</description>
    <image>
      <title>Kerolt&#39;s Blog</title>
      <url>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.151.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 17 Sep 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kerolt.github.io/categories/k8s/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>什么是云原生（自我解惑）</title>
      <link>https://kerolt.github.io/posts/k8s/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F%E8%87%AA%E6%88%91%E8%A7%A3%E6%83%91/</link>
      <pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/k8s/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F%E8%87%AA%E6%88%91%E8%A7%A3%E6%83%91/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;云原生​&lt;/strong&gt;​是一套以​&lt;strong&gt;​微服务、容器、动态编排（如 Kubernetes）、DevOps​&lt;/strong&gt;​为核心，旨在构建和运行​&lt;strong&gt;​弹性、可靠、敏捷​&lt;/strong&gt;​的云化应用的最佳实践集合。&lt;/p&gt;
&lt;p&gt;理解它的关键在于思维的转变：​&lt;strong&gt;​从把云当作一台更便宜的虚拟主机，转变为把云当作一个可无限扩展、按需取用的计算能力平台，并以此为前提来设计和构建应用。​&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;什么是云原生&#34;&gt;什么是云原生？&lt;/h2&gt;
&lt;p&gt;​&lt;strong&gt;​云原生​&lt;/strong&gt;​ 是一种构建和运行应用程序的全新方法论，它充分利用了云计算的优势。&lt;/p&gt;
&lt;p&gt;简单来说，​&lt;strong&gt;​云原生 = 云 + 原生​&lt;/strong&gt;​。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​云​&lt;/strong&gt;​：指的是应用程序运行在云环境中，而不仅仅是托管在云服务器上。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​原生​&lt;/strong&gt;​：意味着应用程序从设计、开发、部署到运维的整个生命周期，都是​&lt;strong&gt;​专门为云环境而设计和构建的​&lt;/strong&gt;​，是“云上的原住民”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它不是某一种具体的技术，而是一套​&lt;strong&gt;​技术体系、方法论和最佳实践的集合​&lt;/strong&gt;​，其核心目标是构建和运行​&lt;strong&gt;​弹性扩展、韧性可靠、易于管理、可观测、松耦合的现代化应用​&lt;/strong&gt;​。&lt;/p&gt;
&lt;h2 id=&#34;如何通俗地理解云原生&#34;&gt;如何通俗地理解云原生&lt;/h2&gt;
&lt;p&gt;我们可以用一个生动的比喻来理解：&lt;/p&gt;
&lt;p&gt;​&lt;strong&gt;​传统应用 vs. 云原生应用​&lt;/strong&gt;​&lt;/p&gt;
&lt;p&gt;想象一下，你要运送货物。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​传统应用（像“巨石应用”）​&lt;/strong&gt;​：就像把所有的货物都塞进一个巨大的、不可分割的木箱里。这个木箱非常沉重，需要一辆巨大的卡车（一台强大的服务器）来运输。如果想扩大运力，你必须换一辆更大的卡车（升级服务器，​&lt;strong&gt;​纵向扩展​&lt;/strong&gt;​），这个过程很慢，而且一旦卡车抛锚，所有货物都会受损。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​对应现实​&lt;/strong&gt;​：一个庞大的、所有功能都紧密耦合在一起的传统软件（如一个庞大的 ERP 系统），部署和维护都非常笨重。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​云原生应用（像“乐高应用”）​&lt;/strong&gt;​：就像把货物分装在许多标准化的小集装箱（​&lt;strong&gt;​微服务​&lt;/strong&gt;​）里。每个集装箱都可以被单独搬运、检查、替换。你可以根据需要轻松地增加或减少集装箱的数量（​&lt;strong&gt;​弹性伸缩​&lt;/strong&gt;​），并且用许多辆小卡车（廉价的普通服务器）组成车队来运输。即使有几辆小卡车坏掉，也只会影响部分货物，整个运输系统不会瘫痪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​对应现实​&lt;/strong&gt;​：一个应用被拆分成许多小的、独立的服务（如用户服务、订单服务、支付服务），它们可以独立开发、部署和扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生的四大核心要素&#34;&gt;云原生的四大核心要素&lt;/h2&gt;
&lt;p&gt;要支撑上述的“乐高式”应用，需要一套强大的技术框架。云原生主要由以下四大核心技术要素构成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​微服务​&lt;/strong&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​是什么​&lt;/strong&gt;​：将大型单体应用拆分为一组小的、松耦合的、可独立部署和升级的服务。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​好处​&lt;/strong&gt;​：每个服务可以由不同的团队用不同的技术栈开发，更新速度快，容错性高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​容器化​&lt;/strong&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​是什么​&lt;/strong&gt;​：最代表性的技术是 ​&lt;strong&gt;​Docker​&lt;/strong&gt;​。它将应用程序及其所有依赖项（库、环境配置等）打包成一个标准化的、轻量级的、可移植的“容器镜像”。这个容器在任何地方（开发、测试、生产环境）的运行效果都是一致的。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​好处​&lt;/strong&gt;​：解决了“在我这运行得好好的，到你那就出问题”的环境一致性问题，是应用的标准交付件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​动态编排​&lt;/strong&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​是什么​&lt;/strong&gt;​：最代表性的技术是 ​&lt;strong&gt;​Kubernetes​&lt;/strong&gt;​。当你有成千上万个容器需要管理时，Kubernetes 就像一位​&lt;strong&gt;​超级调度员和管家​&lt;/strong&gt;​。它负责自动部署容器、故障恢复（容器挂了自动重启）、弹性伸缩（流量大了自动增加容器数量）、负载均衡等。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​好处​&lt;/strong&gt;​：实现了应用的自动化和智能化运维，是云原生的操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​DevOps 和持续交付​&lt;/strong&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​是什么​&lt;/strong&gt;​：​&lt;strong&gt;​DevOps​&lt;/strong&gt;​ 是一种文化理念和实践，它打通了开发（Development）和运维（Operations）团队，通过高度自动化工具链（如 CI/CD），实现软件的频繁、可靠、快速的交付。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​好处​&lt;/strong&gt;​：使得从代码提交到应用上线的过程可以完全自动化，极大地加快了迭代速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;strong&gt;​简单总结一下四者的关系​&lt;/strong&gt;​：&lt;/p&gt;
&lt;p&gt;我们用 ​&lt;strong&gt;​DevOps​&lt;/strong&gt;​ 的文化和 ​&lt;strong&gt;​CI/CD​&lt;/strong&gt;​ 的工具，来自动化地开发、构建和测试​&lt;strong&gt;​微服务​&lt;/strong&gt;​，并将其打包成​&lt;strong&gt;​容器​&lt;/strong&gt;​，最后交给 ​&lt;strong&gt;​Kubernetes​&lt;/strong&gt;​ 这个编排系统去动态地管理和运行。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要云原生它的优势是什么&#34;&gt;为什么需要云原生？它的优势是什么？&lt;/h2&gt;
&lt;p&gt;采用云原生架构能带来巨大的商业和技术价值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​弹性与可扩展性​&lt;/strong&gt;​：应用可以根据流量压力自动缩扩容，轻松应对“双十一”等高峰场景，同时节省空闲时的资源成本。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​高韧性与故障隔离​&lt;/strong&gt;​：单个服务的故障不会导致整个系统崩溃，系统具备自愈能力。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​快速迭代与交付​&lt;/strong&gt;​：微服务和 DevOps 使得新功能可以独立、频繁、安全地发布，大大加快了市场响应速度。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​资源利用率高​&lt;/strong&gt;​：容器非常轻量，可以在同一台机器上密集部署，节省硬件成本。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​可移植性​&lt;/strong&gt;​：容器化的应用可以运行在任何云平台（公有云、私有云、混合云）上，避免被单一云厂商锁定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云环境和托管在云服务器上有什么区别&#34;&gt;云环境和托管在云服务器上有什么区别&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;托管在云服务器上（租用办公室）&lt;/th&gt;
          &lt;th&gt;构建在云环境上（打造智能企业）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;​​核心思想​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​“换地方”​&lt;/strong&gt;​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​“换活法”​&lt;/strong&gt;​&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​比喻​​&lt;/td&gt;
          &lt;td&gt;你租用了一间云厂商的​&lt;strong&gt;​办公室（云服务器）​&lt;/strong&gt;​，然后把自家机房里的​&lt;strong&gt;​旧家具、旧电脑（传统应用）​&lt;/strong&gt;​ 原封不动地搬了进去。运维方式完全没变。&lt;/td&gt;
          &lt;td&gt;你利用云厂商提供的​&lt;strong&gt;​全套智能办公解决方案（云服务）​&lt;/strong&gt;​：按需使用的会议室（计算资源）、自动化的物流系统（CI/CD）、可随意拼拆的工位（容器）、智能调度系统（Kubernetes）来​&lt;strong&gt;​重新组建一个高效、灵活的现代化公司（云原生应用）​&lt;/strong&gt;​。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​弹性伸缩​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​手动、缓慢​&lt;/strong&gt;​。需要更多资源时，需要人工干预去升级服务器配置（​&lt;strong&gt;​纵向扩展​&lt;/strong&gt;​），这通常需要停机。&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​自动、即时​&lt;/strong&gt;​。应用可根据流量压力，自动增加或减少计算资源（​&lt;strong&gt;​横向扩展​&lt;/strong&gt;​），过程无缝，按实际使用量计费。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​韧性/可靠性​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​依赖单机​&lt;/strong&gt;​。如果托管你应用的这台云服务器宕机，你的服务就中断了，直到你手动将其恢复或迁移到另一台服务器。&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​内置高可用​&lt;/strong&gt;​。应用被设计为分布式、多实例运行。即使底层一台或多台服务器宕机，编排系统会自动在健康的服务器上重启应用实例，用户无感知。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​资源管理​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​以服务器为中心​&lt;/strong&gt;​。你需要关心每台服务器的 CPU、内存、磁盘使用率，并进行运维。&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​以应用为中心​&lt;/strong&gt;​。你只需声明“我的应用需要 2 核 4G”，云平台会自动调度和分配资源，你不再需要关心应用具体跑在哪台物理机上。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​成本模式​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​为资源预留付费​&lt;/strong&gt;​。你租了一台云服务器，无论你是否满负荷使用它，你都需要为它整个月的配置付费。&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​为资源消耗付费​&lt;/strong&gt;​。你只为应用程序实际消耗的 CPU 秒、内存 MB、网络流量付费。利用率极高，成本显著优化。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​技术栈​​&lt;/td&gt;
          &lt;td&gt;传统架构，如：​&lt;strong&gt;​单体应用​&lt;/strong&gt;​ + ​&lt;strong&gt;​服务器​&lt;/strong&gt;​ + ​&lt;strong&gt;​SSH 运维​&lt;/strong&gt;​。&lt;/td&gt;
          &lt;td&gt;云原生架构，如：​&lt;strong&gt;​微服务​&lt;/strong&gt;​ + ​&lt;strong&gt;​容器​&lt;/strong&gt;​ + ​&lt;strong&gt;​Kubernetes​&lt;/strong&gt;​ + ​&lt;strong&gt;​DevOps​&lt;/strong&gt;​。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;​​与云的关系​​&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​租赁关系​&lt;/strong&gt;​。你只是租用它的基础空间和硬件。&lt;/td&gt;
          &lt;td&gt;​&lt;strong&gt;​共生关系​&lt;/strong&gt;​。你的应用深度使用了云提供的数据库、消息队列、AI、大数据等​&lt;strong&gt;​托管服务​&lt;/strong&gt;​，与应用紧密集成。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    <item>
      <title>【k8s】什么是Service</title>
      <link>https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/</link>
      <pubDate>Sun, 07 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/</guid>
      <description>&lt;p&gt;在 Kubernetes（K8s）中，&lt;strong&gt;Service（服务）&lt;/strong&gt; 是一个非常核心、关键的抽象概念。它的主要作用是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;✅ &lt;strong&gt;为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;为什么需要-service&#34;&gt;为什么需要 Service？&lt;/h2&gt;
&lt;p&gt;在 Kubernetes 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 是&lt;strong&gt;临时的、动态的&lt;/strong&gt; —— 它们随时可能被调度、重启、扩缩容，IP 会变&lt;/li&gt;
&lt;li&gt;如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败&lt;/li&gt;
&lt;li&gt;我们需要一个&lt;strong&gt;稳定的访问端点（Service）&lt;/strong&gt;，无论后端 Pod 如何变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service 的核心功能为：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;功能&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;服务发现&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;通过 Service 名称（在集群内 DNS 可解析）访问后端应用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;自动将请求分发到后端多个 Pod 实例&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;解耦访问与实现&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;用户访问 Service，无需关心后端是哪些 Pod、IP 是多少&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;支持多种暴露方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;可在集群内访问、节点上暴露、或对外暴露公网访问&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;service-如何工作&#34;&gt;Service 如何工作？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 &lt;code&gt;app: my-app&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Kubernetes 为 Service 分配一个&lt;strong&gt;集群内唯一的虚拟 IP（ClusterIP）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡&lt;/li&gt;
&lt;li&gt;当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;service-的-4-种类型&#34;&gt;Service 的 4 种类型&lt;/h2&gt;
&lt;h3 id=&#34;1-clusterip默认&#34;&gt;1️⃣ &lt;code&gt;ClusterIP&lt;/code&gt;（默认）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只在&lt;strong&gt;集群内部&lt;/strong&gt;可访问&lt;/li&gt;
&lt;li&gt;为 Service 分配一个集群内虚拟 IP&lt;/li&gt;
&lt;li&gt;适用于微服务之间互相调用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-nodeport&#34;&gt;2️⃣ &lt;code&gt;NodePort&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;每个节点&lt;/strong&gt;上开放一个端口（默认 30000-32767）&lt;/li&gt;
&lt;li&gt;外部用户可通过 &lt;code&gt;http://&amp;lt;NodeIP&amp;gt;:&amp;lt;NodePort&amp;gt;&lt;/code&gt; 访问服务&lt;/li&gt;
&lt;li&gt;适合开发、测试或没有 LoadBalancer 的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NodePort&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;nodePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;30007&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 可选，不填则自动分配&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-loadbalancer&#34;&gt;3️⃣ &lt;code&gt;LoadBalancer&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;适用于&lt;strong&gt;云平台&lt;/strong&gt;（AWS、GCP、Azure、阿里云等）&lt;/li&gt;
&lt;li&gt;云平台会自动创建一个&lt;strong&gt;外部负载均衡器&lt;/strong&gt;，并分配公网 IP&lt;/li&gt;
&lt;li&gt;用户通过公网 IP 访问服务&lt;/li&gt;
&lt;li&gt;最适合生产环境对外暴露服务&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在 Minikube 或本地环境，可以使用 &lt;code&gt;minikube service &amp;lt;service-name&amp;gt;&lt;/code&gt; 来模拟 LoadBalancer。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
