<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>项目 | Kerolt's Blog</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/categories/%E9%A1%B9%E7%9B%AE/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.606825f206d352379c6dde44af4261b470bb478e4cd3698f13051e7ae36000f2.css integrity="sha256-YGgl8gbTUjecbd5Er0JhtHC7R45M02mPEwUeeuNgAPI=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/categories/%E9%A1%B9%E7%9B%AE/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/categories/%E9%A1%B9%E7%9B%AE/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/categories/%E9%A1%B9%E7%9B%AE/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="项目"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="项目"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/categories/>Categories</a></div><h1>项目
<a href=/categories/%E9%A1%B9%E7%9B%AE/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式缓存</h2></header><div class=entry-content><p>原分布式缓存项目的问题 KamaCache-Go 是在 Groupcache 的基础上修改的，引入了 set、delete 操作和 etcd 服务发现，但是这样就改变了 groupcache 的架构和本意，并且带来了一些问题。
groupcache 的本意是一个在读多写少的环境下为了应用自身的服务设计的内嵌式缓存系统。节点既是 app 又是 cache，并且
项目地址：https://github.com/kerolt/kcache
KCache 是一个分布式缓存系统，支持一致性哈希和 LRU 缓存淘汰策略。该项目使用 conan 作为包管理工具，使用 CMake 作为项目的构建工具。
数据流程 当有客户端请求 kcache node 中的数据时：
kcache node 首先检查本地缓存 如果本地缓存未命中，使用 PeerPicker 选择负责该键的节点 如果键属于远程节点，通过 gRPC 向远程节点请求数据 如果远程节点也没有数据，回退到原始数据源加载（例如数据源是 MySQL、SQLite 等数据库） 将加载的数据添加到本地缓存 示意架构图如下：
致谢 本项目参考了 geektutu/7days-golang 项目，感谢其作者提供的 教程 和代码示例。 项目第二版参考了 【代码随想录知识星球】项目分享-缓存系统（Go） 项目结构 . |-- .vscode | `-- launch.json |-- example | |-- CMakeLists.txt | `-- example.cpp |-- src | |-- cache | | `-- lru.cpp | |-- consistent_hash | | `-- consistent_hash.cpp | |-- group | | `-- group.cpp | |-- include | | `-- kcache | | |-- cache.h | | |-- consistent_hash.h | | |-- group.h | | |-- grpc_server.h | | |-- peer.h | | |-- registry.h | | `-- singleflight.h | |-- peer | | |-- peer.cpp | | `-- peer_picker.cpp | |-- proto | | |-- kcache.grpc.pb.cc | | |-- kcache.grpc.pb.h | | |-- kcache.pb.cc | | |-- kcache.pb.h | | `-- kcache.proto | |-- registry | | `-- registry.cpp | |-- server | | `-- grpc_server.cpp | `-- CMakeLists.txt |-- test | |-- CMakeLists.txt | |-- test_consistent_hash.cpp | |-- test_group.cpp | `-- test_lru.cpp |-- .clang-format |-- .gitignore |-- CMakeLists.txt |-- CMakePresets.json |-- conanfile.txt |-- LICENSE `-- README.md 依赖 项目依赖如下：
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0000 UTC'>发布于2025-05-25</span>&nbsp;&nbsp;·&nbsp;&nbsp;<span title='2025-12-08 00:00:00 +0000 UTC'>最后更新于2025-12-08</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 分布式缓存" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 5】常用IO函数的HOOK功能</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
hook函数的具体定义实现可以在这里查看：Github: src/hook.cpp
该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。
hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。
...</p></div><footer class=entry-footer><span title='2024-09-30 00:00:00 +0000 UTC'>发布于2024-09-30</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 5】常用IO函数的HOOK功能" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 4】IO协程调度器</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
IOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp
之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。
sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
...</p></div><footer class=entry-footer><span title='2024-09-29 00:00:00 +0000 UTC'>发布于2024-09-29</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 4】IO协程调度器" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 3】定时器</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
TimerManager类中具体定义实现可以在这里查看：Github: src/timer.cpp
通过定时器，我们可以实现给服务器注册定时事件。sylar的定时器采用最小堆设计，所有定时器根据绝对的超时时间点（也就是超时到期的具体时间戳）进行排序，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。
...</p></div><footer class=entry-footer><span title='2024-09-28 00:00:00 +0000 UTC'>发布于2024-09-28</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 3】定时器" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-3%E5%AE%9A%E6%97%B6%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 2】协程调度器</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
Scheduler类中其他函数的定义可以在这里查看：Github: src/scheduler.cpp
Sylar的协程调度器是一个N-M模型，意味着N个线程可以运行M个协程，协程能够在线程之间进行切换，也可以被绑定到特定的线程上执行。
调度器可以由应用程序中的任何线程创建，但创建它的线程（称为caller线程）可以选择是否参与协程的调度。如果caller线程参与调度，那么调度器的线程数会相应减少一个，因为caller线程本身也会作为一个调度线程。
...</p></div><footer class=entry-footer><span title='2024-09-11 00:00:00 +0000 UTC'>发布于2024-09-11</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 2】协程调度器" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-2%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 1】协程定义</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
Coroutine类中其他函数的定义可以在这里查看：Github: src/coroutine.cpp
对于什么是协程，为什么要使用协程，可以看看之前的笔记：【协程】C++20协程初体验。
对于我们自己来实现协程，其实在之前Xv6的Lab中就有做过：【MIT6.S081】Lab6 multithreading，当初做这个lab的时候没有意识到这就是协程。协程的切换最重要的就是要保存和恢复上下文，在这个lab中，我们通过保存每个协程在切换之前的寄存器的值，以此可用来恢复原来的执行流。
...</p></div><footer class=entry-footer><span title='2024-09-10 00:00:00 +0000 UTC'>发布于2024-09-10</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 1】协程定义" href=https://kerolt.github.io/posts/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0x/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-1%E5%8D%8F%E7%A8%8B%E5%AE%9A%E4%B9%89/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>