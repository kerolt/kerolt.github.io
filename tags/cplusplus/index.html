<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CPlusPlus | Kerolt's Blog</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/tags/cplusplus/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.e86fca84f55806041871ed7351917eaee2448b47fbc63452ca15c8e099639644.css integrity="sha256-6G/KhPVYBgQYce1zUZF+ruJEi0f7xjRSyhXI4JljlkQ=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/tags/cplusplus/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/tags/cplusplus/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/tags/cplusplus/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="CPlusPlus"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CPlusPlus"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/tags/>Tags</a></div><h1>CPlusPlus
<a href=/tags/cplusplus/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C&amp;C++类型双关转换</h2></header><div class=entry-content><p>#include &lt;iostream> auto ASSERT(bool flag, const char* msg) { if (!flag) { std::cerr &lt;&lt; msg &lt;&lt; std::endl; } } // READ: 枚举类型 &lt;https://zh.cppreference.com/w/cpp/language/enum> // `enum` 是 C 的兼容类型，本质上其对应类型的常量。 // 在 `enum` 中定义标识符等价于定义 constexpr 常量， // 这些标识符不需要前缀，可以直接引用。 // 因此 `enum` 定义会污染命名空间。 enum ColorEnum : unsigned char { COLOR_RED = 31, COLOR_GREEN, COLOR_YELLOW, COLOR_BLUE, }; // 有作用域枚举型是 C++ 引入的类型安全枚举。 // 其内部标识符需要带前缀引用，如 `Color::Red`。 // 作用域枚举型可以避免命名空间污染，并提供类型安全保证。 enum class Color : int { Red = COLOR_RED, Green, Yellow, Blue, }; ColorEnum convert_by_pun(Color c) { // READ: &lt;https://zh.cppreference.com/w/cpp/language/union> // `union` 表示在同一内存位置存储的不同类型的值。 // 其常见用法是实现类型双关转换，即将一种类型的值转换为另一种无关类型的值。 // 但这种写法实际上仅在 C 语言良定义，在 C++ 中是未定义行为。 // 这是比较少见的 C++ 不与 C 保持兼容的特性。 // READ: 类型双关 &lt;https://tttapa.github.io/Pages/Programming/Cpp/Practices/type-punning.html> union TypePun { ColorEnum e; Color c; }; TypePun pun; pun.c = c; return pun.e; } int main(int argc, char **argv) { ASSERT(convert_by_pun(Color::Red) == COLOR_RED, "Type punning conversion"); ASSERT(convert_by_pun(Color::Green) == COLOR_GREEN, "Type punning conversion"); ASSERT(convert_by_pun(Color::Yellow) == COLOR_YELLOW, "Type punning conversion"); ASSERT(convert_by_pun(Color::Blue) == COLOR_BLUE, "Type punning conversion"); return 0; }</p></div><footer class=entry-footer><span title='2025-08-21 00:00:00 +0000 UTC'>2025-08-21</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;152 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C&C++类型双关转换" href=https://kerolt.github.io/posts/c++/cc++%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%E8%BD%AC%E6%8D%A2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>关于内存对齐、位域的思考</h2></header><div class=entry-content><p>什么是内存对齐？为什么需要它？ 内存对齐（Memory Alignment）是计算机系统中数据在内存中存储的一种规则：​​数据在内存中的起始地址必须是其自身大小的整数倍​​。例如，一个 4 字节的整型变量（int），其起始地址必须是 4 的倍数（如地址 0x0000、0x0004、0x0008 等）。
而需要内存对齐主要基于以下三个原因：
​​硬件访问效率​​： CPU 通过内存总线从内存读取数据时，通常以固定大小的“块”为单位（例如 4 字节或 8 字节）。如果数据对齐，CPU 一次读取操作即可获取完整数据。 ​​非对齐示例​​：假设一个 int 变量（4 字节）存储在地址 0x0001（非 4 的倍数），CPU 需要分两次读取：先读取 0x0000-0x0003（包含前 3 字节），再读取 0x0004-0x0007（包含最后 1 字节），最后拼接数据。这会显著降低性能。 ​​硬件兼容性​​： 部分架构（如 ARM、MIPS）的 CPU 无法直接访问非对齐内存。尝试访问时会导致硬件异常（如“总线错误”）。对齐保证了代码的跨平台兼容性。 ​​缓存效率优化​​： 现代 CPU 使用缓存行（Cache Line，通常 64 字节）预加载数据。对齐的数据更可能完整地位于单个缓存行中。若数据跨缓存行存储，会引发两次缓存访问，降低效率。 alignas 和 alignof c++11 以后引入两个关键字 alignas 与 alignof。
alignas 用于显式设置变量、类成员或类型的内存对齐要求；而 alignof 用于获取类型或变量的内存对齐要求。例如：
struct Test1 {}; struct alignas(4) Test2 {}; static_assert(sizeof(Test1) == 1); static_assert(sizeof(Test2) == 4); static_assert(alignof(Test1) == 1); static_assert(alignof(Test2) == 4); alignas 支持三种语法形式：
alignas(expression)：expression 必须是计算结果为零的整数常量表达式，或者是对齐或扩展对齐的有效值（2 的倍数）。 alignas(type-id)：等效于 alignas(alignof(type-id)) alignas(pack...)：等效于应用于同一声明的多个 alignas 说明符，参数包的每个成员对应一个说明符，可以是类型参数包或常量参数包 Note 注意：若指定的对齐值小于编译器默认对齐要求，部分编译器可能忽略该设置。
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0000 UTC'>2025-07-22</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 关于内存对齐、位域的思考" href=https://kerolt.github.io/posts/c++/%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BD%8D%E5%9F%9F%E7%9A%84%E6%80%9D%E8%80%83/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++透明运算符</h2></header><div class=entry-content><p>透明运算符的概念与价值 在 C++ 编程中，当编写泛型代码时，不同类型的比较或操作可能导致意外的类型转换或精度损失。假设有一个 std::vector&lt;uint32_t>，使用自定义仿函数进行排序，一切运行正常。但当你将容器改为 std::vector&lt;uint64_t> 却忘记修改仿函数的实现时，编译器不会报错，但数据可能在比较前被静默截断，导致排序结果完全错误。而 C++14 引入透明运算符可以帮助我们避免这种 bug。
透明运算符（Transparent Operator）是 C++14 引入的一项强大特性，它通过 std::less&lt;>、std::greater&lt;> 等空模板参数的运算符函子实现，允许编译器在模板实例化时自动推导操作数的实际类型，从而避免不必要的类型转换和潜在错误。与传统的重载运算符不同，透明运算符的核心优势在于其类型透明性——它们不会强迫操作数转换为特定类型，而是根据操作数的实际类型进行推导，保留完整的类型信息。
传统 C++ 运算符重载需要严格定义操作数类型，这使得编写真正通用的泛型代码变得困难。例如，当我们使用 std::less&lt;int> 进行比较时，它会强制将两个操作数都视为 int 类型，如果操作数实际是 long 或 double，就可能发生精度损失或意外的类型转换。而透明运算符如 std::less&lt;> 则解决了这一问题，它本质上是一个模板化的函子，能够自动适应操作数的类型，保持代码的通用性和安全性。
实现原理 透明运算符的神奇之处在于其简洁而精妙的实现机制。让我们深入探究其工作原理，揭开这层看似简单的语法糖衣下蕴含的强大能力。
模板元编程技巧 透明运算符的核心实现依赖于空模板参数列表（operator&lt;>）这一巧妙设计。观察 std::less 的标准库实现，我们会发现它提供了两种形式：
// 传统形式：指定比较类型 template &lt;class T> struct less { bool operator()(const T& lhs, const T& rhs) const; }; // 透明形式：自动类型推导 template &lt;> struct less&lt;void> { template &lt;class T, class U> auto operator()(T&& t, U&& u) const -> decltype(std::forward&lt;T>(t) &lt; std::forward&lt;U>(u)); }; 当使用 std::less&lt;> 时，我们特化到了 less&lt;void>，它包含一个泛化的函数调用运算符。这个运算符是模板成员函数，接受任意类型的两个参数 T 和 U，并返回它们比较的结果。
类型推导与完美转发 透明运算符的实现依赖于两个现代 C++ 核心特性：自动类型推导和完美转发。当编译器遇到 std::less&lt;>{}(a, b) 这样的表达式时：
模板参数推导：编译器根据参数 a 和 b 的实际类型推导出模板参数 T 和 U 完美转发：通过 std::forward 保持参数的值类别（左值/右值），避免不必要的拷贝 返回类型推导：使用 decltype 自动推导比较结果的准确类型，保留常量性、引用性等类型信息 这种机制确保了比较操作以最直接的方式进行，不引入任何中间转换。例如，比较 int 和 double 时，编译器会直接生成 int 与 double 比较的代码，遵循标准的算术类型转换规则，而不是先将两者转换为同一类型。
...</p></div><footer class=entry-footer><span title='2025-06-20 00:00:00 +0000 UTC'>2025-06-20</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;376 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++透明运算符" href=https://kerolt.github.io/posts/c++/c++%E9%80%8F%E6%98%8E%E8%BF%90%E7%AE%97%E7%AC%A6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式缓存</h2></header><div class=entry-content><p>项目地址：https://github.com/kerolt/kcache
KCache 是一个分布式缓存系统，支持一致性哈希和 LRU 缓存淘汰策略。该项目使用 conan 作为包管理工具，使用 CMake 作为项目的构建工具。
数据流程 当有客户端请求 kcache node 中的数据时：
kcache node 首先检查本地缓存 如果本地缓存未命中，使用 PeerPicker 选择负责该键的节点 如果键属于远程节点，通过 gRPC 向远程节点请求数据 如果远程节点也没有数据，回退到原始数据源加载（例如数据源是 MySQL、SQLite 等数据库） 将加载的数据添加到本地缓存 示意架构图如下：
致谢 本项目参考了 geektutu/7days-golang 项目，感谢其作者提供的 教程 和代码示例。 项目第二版参考了 【代码随想录知识星球】项目分享-缓存系统（Go） 项目结构 . |-- .vscode | `-- launch.json |-- example | |-- CMakeLists.txt | `-- example.cpp |-- src | |-- cache | | `-- lru.cpp | |-- consistent_hash | | `-- consistent_hash.cpp | |-- group | | `-- group.cpp | |-- include | | `-- kcache | | |-- cache.h | | |-- consistent_hash.h | | |-- group.h | | |-- grpc_server.h | | |-- peer.h | | |-- registry.h | | `-- singleflight.h | |-- peer | | |-- peer.cpp | | `-- peer_picker.cpp | |-- proto | | |-- kcache.grpc.pb.cc | | |-- kcache.grpc.pb.h | | |-- kcache.pb.cc | | |-- kcache.pb.h | | `-- kcache.proto | |-- registry | | `-- registry.cpp | |-- server | | `-- grpc_server.cpp | `-- CMakeLists.txt |-- test | |-- CMakeLists.txt | |-- test_consistent_hash.cpp | |-- test_group.cpp | `-- test_lru.cpp |-- .clang-format |-- .gitignore |-- CMakeLists.txt |-- CMakePresets.json |-- conanfile.txt |-- LICENSE `-- README.md 依赖 项目依赖如下：
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0000 UTC'>2025-05-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;369 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 分布式缓存" href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project4 Concurrency Control 小结</h2></header><div class=entry-content><p>这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：
每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~
0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：
class TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist. Use `find` instead. */ std::unordered_map&lt;slot_offset_t, VersionUndoLink> prev_version_; }; /** protects version info */ std::shared_mutex version_info_mutex_; /** Stores the previous version of each tuple in the table heap. Do not directly access this field. Use the helper * functions in `transaction_manager_impl.cpp`. */ std::unordered_map&lt;page_id_t, std::shared_ptr&lt;PageVersionInfo>> version_info_; ... } 其中的 VersionUndoLink 也只是对 UndoLink 的一个包装：
...</p></div><footer class=entry-footer><span title='2025-05-06 00:00:00 +0000 UTC'>2025-05-06</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;735 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project4 Concurrency Control 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++折叠表达式</h2></header><div class=entry-content><p>C++17 为模板元编程带来了一个非常有用的特性：折叠表达式（fold expressions）。它的出现让变参模板函数的编写变得更加简洁、清晰和直观。
1. 如何处理变长参数包 在 C++11/14 中，如果我们要处理变长参数包（parameter pack），通常需要递归展开，例如：
template&lt;typename T> void print(const T& t) { std::cout &lt;&lt; t &lt;&lt; '\n'; } template&lt;typename T, typename... Args> void print(const T& t, const Args&... args) { std::cout &lt;&lt; t &lt;&lt; ", "; print(args...); } 虽然这段代码能完成任务，但却略显冗长，并且生成的汇编代码也会很多。C++17 中引入的折叠表达式，就是为了解决这个问题。
可以在 godbolt 上看看两种方法生成的汇编代码：https://godbolt.org/z/55a7q85oE
2. 什么是折叠表达式 折叠表达式是一种用运算符对参数包进行折叠的方式。折叠表达式的实例化按以下方式展开成表达式 e：
（图片来源：https://zh.cppreference.com/w/cpp/language/fold）
基本语法形式：
类型 语法形式 示例 一元左折叠 (... op pack) (... + args) 一元右折叠 (pack op ...) (args + ...) 二元左折叠 (init op ... op pack) (0 + ... + args) 二元右折叠 (pack op ... op init) (args + ... + 0) 折叠表达式支持多种运算符，包括但不限于：
...</p></div><footer class=entry-footer><span title='2025-05-06 00:00:00 +0000 UTC'>2025-05-06</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;343 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++折叠表达式" href=https://kerolt.github.io/posts/c++/c++%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>使用 Concept 替代基于虚函数的接口</h2></header><div class=entry-content><p>在 C++20 及更高版本中，可以使用 Concepts 来替代传统的基于虚函数的接口设计，这种方式提供了更好的编译时检查、更高效的代码生成和更灵活的接口约束。
在之前，可能是这样的：
class IDrawable { public: virtual ~IDrawable() = default; virtual void draw() const = 0; }; class Circle : public IDrawable { public: void draw() override { puts("Circle::draw()"); } }; class Squre : public IDrawable { public: void draw() override { puts("Squre::draw()"); } }; void render(IDrawable& drawable) { drawable.draw(); } 但是有了 Concept 后：
template &lt;typename T> concept Drawable = requires(T t) { { t.draw() } -> std::same_as&lt;void>; }; class Circle { public: void draw() const { puts("Circle::draw()"); } }; class Squre { public: void draw() { puts("Squre::draw()"); } }; template &lt;Drawable T> void render(T& drawable) { drawable.draw(); } 优势：
​​编译时多态​​：不需要运行时虚表查找，性能更高 ​​值语义​​：可以直接传递对象而不需要指针或引用 ​​更灵活的约束​​：可以约束多个不相关的类型 ​​更好的错误信息​​：编译错误更清晰明确 ​​无对象切片问题​​：因为不使用继承</p></div><footer class=entry-footer><span title='2025-04-28 00:00:00 +0000 UTC'>2025-04-28</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;109 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 使用 Concept 替代基于虚函数的接口" href=https://kerolt.github.io/posts/c++/%E4%BD%BF%E7%94%A8-concept-%E6%9B%BF%E4%BB%A3%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++何时会阻止默认的特殊成员函数的生成</h2></header><div class=entry-content><p>在C++中，编译器会根据类的定义情况自动决定是否生成默认的特殊成员函数（如构造函数、拷贝/移动操作、析构函数）。
1. 用户显式声明相关成员函数 显式声明或删除某个函数：
如果用户显式声明（即使使用 =default 或 =delete）某个特殊成员函数，编译器将不再生成默认版本。例如：
class Example { public: Example() = default; // 允许生成默认构造函数 Example(const Example&) {} // 用户定义的拷贝构造函数 // 编译器不再生成默认的移动构造函数和移动赋值运算符 }; 2. 用户定义析构函数、拷贝/移动操作的影响 定义析构函数：
如果用户定义了析构函数（即使为空），编译器会删除默认的移动操作（移动构造函数和移动赋值运算符），但拷贝操作仍可能生成（除非其他条件阻止）。
class Example { public: ~Example() {} // 用户定义的析构函数 // 移动操作被隐式删除，拷贝操作可能生成（若无其他限制） }; 定义拷贝操作：
如果用户定义了拷贝构造函数或拷贝赋值运算符，编译器会删除默认的移动操作。
class Example { public: Example(const Example&) {} // 用户定义的拷贝构造函数 // 移动操作被隐式删除 }; 定义移动操作：
如果用户定义了移动构造函数或移动赋值运算符，编译器会删除默认的拷贝操作。
#include &lt;utility> #include &lt;string> #include &lt;iostream> struct Example { std::string str; Example() = default; Example(const std::string& s): str(s) { std::cout &lt;&lt; "Example()\n"; } Example(Example&& other) { str = std::move(other.str); std::cout &lt;&lt; "Example(Example&&)\n"; } Example& operator=(Example&& other) { str = std::move(other.str); std::cout &lt;&lt; "operator=(Example&&)\n"; return *this; } }; int main() { Example x1("Hello"); Example x2 = std::move(x1); Example x3; x3 = std::move(x2); } 执行结果为：
...</p></div><footer class=entry-footer><span title='2025-03-13 00:00:00 +0000 UTC'>2025-03-13</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++何时会阻止默认的特殊成员函数的生成" href=https://kerolt.github.io/posts/c++/c++%E4%BD%95%E6%97%B6%E4%BC%9A%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project3 Query Execution 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！
这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。
前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：
auto BustubInstance::ExecuteSqlTxn(const std::string &amp;sql, ResultWriter &amp;writer, Transaction *txn, std::shared_ptr&lt;CheckOptions> check_options) -> bool { if (!sql.empty() && sql[0] == '\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement->type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner.PlanQuery(*statement); // 优化刚刚的执行计划 bustub::Optimizer optimizer(*catalog_, IsForceStarterRule()); auto optimized_plan = optimizer.Optimize(planner.plan_); ... // 执行优化后的plan，这里会使用火山模型去根据下面节点的Next函数来执行相应的算子 execution_engine_->Execute(optimized_plan, &amp;result_set, txn, exec_ctx.get()); // 将执行结果输出至指定位置 ... } return 是否执行成功; } 在 binder 之后，我们就有了一条 sql 的语句解析节点，例如执行 select * from (select * from test_2 where colA > 10) where colB > 2;，其 statement node 如下：
...</p></div><footer class=entry-footer><span title='2025-03-11 00:00:00 +0000 UTC'>2025-03-11</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2423 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project3 Query Execution 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project2 Extendible Hash Index 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写Lab时的思路，按照课程要求不会在Github和博客中公开源代码。欢迎与我一起讨论交流！
太菜了，从没打过这么艰难的仗QAQ。由于课程的要求不能公开源代码，所以网上的资源会少很多，平台上的测试案例比较全面，有的还比较刁钻，需要考虑到可拓展哈希的实现细节。在自认为写完了后，提交了近40来次总有几个测试集过不了，还好没有崩溃，在看了几篇博客的方法后，加上自己画图理解，最后终于过了😭。不过回头写博客的时候再去看代码，也没有特别的复杂，还是得明白其中的算法逻辑是如何实现的。
Task1 - Read/Write Page Guards 简单来说，就是为Page实现一个RAII来自动管理资源。因为在BufferPoolManager::Unpin中，每次调用这个函数，都会让对应的page的pin_count_ - 1，当这个值为0时，这个page就可以被回收，或者说被替换了。但如果我们忘记去手动调用，该页面将永远不会被逐出缓冲池。由于缓冲池以更少的帧数运行，磁盘内外的页面交换将更多。不仅性能受到影响，而且很难检测到错误。
主要需要考虑如何编写移动构造、移动赋值的逻辑。移动了一个对象后，原来的对象的资源应该转移到了新对象上，那么原来的对象无法再访问资源（将原来对象的资源重置nullptr或清空）。
还有一个Drop()的接口，这是提供给使用者的释放资源的api，在实现虚构函数时可以直接调用它。Drop的实现就是调用Unpin，然后置空资源。需要注意的是，在进行移动赋值时，一开始也要Drop一下，考虑这样一种情况：
auto p = std::move(basic_page_guard); p = std::move(basic_page_guard2); 这个时候同一个变量p接管了两个page，那么应该在第二个移动赋值时先drop掉第一个，因为第一个page不再使用了，自然要Unpin。
还有就是在三个page guard类重载移动赋值时，如果需要移动的对象和自身是同一个，那么直接返回自己就好：
auto BasicPageGuard::operator=(BasicPageGuard &&amp;that) noexcept -> BasicPageGuard & { if (&amp;that == this) { return *this; } // ... 其他操作 } 在ReadPageGuard和WritePageGuard的Drop()中，还需要考虑释放管理的page的锁。对应的，锁的获取发生在FetchPageWrite()和FetchPageWrite()中。
Task2 - Extendible Hash Table Pages 为什么我们需要可扩展哈希？
下图来源：https://www.bilibili.com/video/BV1Qt421w7JT
在bustub的设计中，Header Page，Directory Page和Bucket Page都是无法直接构造出来的，即不能通过构造函数创建，只能通过各自的PageGuard中的As()或者AsMut()函数来转换。
Header header page中有一个max_depth_的成员变量，1 &lt;&lt; max_depth_即为header page中能存放的目录的索引的数量。当我们有值需要放入哈希表时，获取hash(key)的二进制最高max_depth_位作为索引，再从header中对应位置去找到directory。对应的ExtendibleHTableHeaderPage中的功能实现并不难。
Directory directory中有两个depth：
Global Depth：若global depth为n，那么这个Directory就有2^n个entry（相当于指向2^n个bucket） Local Depth：若local depth为n，则在这个对应的bucket下，每个元素的key的最后n位都相同 类似header中获取下一级页的索引，directory获取hash(key)的二进制最低global_depth_位作为索引。那local depth的作用是什么呢？
这就要说到可拓展哈希中的插入和删除操作了。简单来说，在可拓展哈希表中，目录directory的大小是可以变化的（只要不超过最大容量限制）。目录中可能有多个entry映射到同一个bucket。当需要插入时，如果这个bucket还没有满时，可以直接插入；否则，需要将这个bucket分裂成两个bucket（或者说，将这个bucket中的一部分移动到另一个bucket中），并且这个bucket对应的local depth + 1，这样相比之前就多了一位二进制位去识别bucket。具体的用法可以看后面的Task3部分的笔记。
下面讲几个稍微难懂的函数：
GetGlobalDepthMask 这个函数的作用是获取global_depth_个二进制1，举个例子，如果global depth是2，那么说明这个目录当前的容量为2^2=4，索引为0~3，用两位二进制就能表示。
...</p></div><footer class=entry-footer><span title='2024-11-12 00:00:00 +0000 UTC'>2024-11-12</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;282 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project2 Extendible Hash Index 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project2-extendible-hash-index-%E5%B0%8F%E7%BB%93/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://kerolt.github.io/tags/cplusplus/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>