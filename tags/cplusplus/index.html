<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CPlusPlus | Kerolt's Blog</title>
<meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/tags/cplusplus/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.035011695ba11fe36df35b8148f02b5baa41b9707b8d79a5a7d00fb4e65cc340.css integrity="sha256-A1ARaVuhH+Nt81uBSPArW6pBuXB7jXmlp9APtOZcw0A=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/tags/cplusplus/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/tags/cplusplus/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/tags/cplusplus/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="CPlusPlus"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CPlusPlus"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/tags/>Tags</a></div><h1>CPlusPlus
<a href=/tags/cplusplus/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式缓存</h2></header><div class=entry-content><p>项目地址：https://github.com/kerolt/kcache
KCache 是一个分布式缓存系统，支持一致性哈希和 LRU 缓存淘汰策略。该项目使用 conan 作为包管理工具，使用 CMake 作为项目的构建工具。
数据流程 当有客户端请求 kcache node 中的数据时：
kcache node 首先检查本地缓存 如果本地缓存未命中，使用 PeerPicker 选择负责该键的节点 如果键属于远程节点，通过 gRPC 向远程节点请求数据 如果远程节点也没有数据，回退到原始数据源加载（例如数据源是 MySQL、SQLite 等数据库） 将加载的数据添加到本地缓存 示意架构图如下：
致谢 本项目参考了 geektutu/7days-golang 项目，感谢其作者提供的 教程 和代码示例。 项目第二版参考了 【代码随想录知识星球】项目分享-缓存系统（Go） 项目结构 . |-- .vscode | `-- launch.json |-- example | |-- CMakeLists.txt | `-- example.cpp |-- src | |-- cache | | `-- lru.cpp | |-- consistent_hash | | `-- consistent_hash.cpp | |-- group | | `-- group....</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0000 UTC'>2025-05-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;369 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 分布式缓存" href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++折叠表达式</h2></header><div class=entry-content><p>C++17 为模板元编程带来了一个非常有用的特性：折叠表达式（fold expressions）。它的出现让变参模板函数的编写变得更加简洁、清晰和直观。
1. 如何处理变长参数包 在 C++11/14 中，如果我们要处理变长参数包（parameter pack），通常需要递归展开，例如：
template&lt;typename T> void print(const T& t) { std::cout &lt;&lt; t &lt;&lt; '\n'; } template&lt;typename T, typename... Args> void print(const T& t, const Args&... args) { std::cout &lt;&lt; t &lt;&lt; ", "; print(args...); } 虽然这段代码能完成任务，但却略显冗长，并且生成的汇编代码也会很多。C++17 中引入的折叠表达式，就是为了解决这个问题。
可以在 godbolt 上看看两种方法生成的汇编代码：https://godbolt.org/z/55a7q85oE
2. 什么是折叠表达式 折叠表达式是一种用运算符对参数包进行折叠的方式。折叠表达式的实例化按以下方式展开成表达式 e：
（图片来源：https://zh.cppreference.com/w/cpp/language/fold）
基本语法形式：
类型 语法形式 示例 一元左折叠 (... op pack) (... + args) 一元右折叠 (pack op ...) (args + ...) 二元左折叠 (init op ....</p></div><footer class=entry-footer><span title='2025-05-06 00:00:00 +0000 UTC'>2025-05-06</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;343 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++折叠表达式" href=https://kerolt.github.io/posts/c++/c++%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>使用 Concept 替代基于虚函数的接口</h2></header><div class=entry-content><p>在 C++20 及更高版本中，可以使用 Concepts 来替代传统的基于虚函数的接口设计，这种方式提供了更好的编译时检查、更高效的代码生成和更灵活的接口约束。
在之前，可能是这样的：
class IDrawable { public: virtual ~IDrawable() = default; virtual void draw() const = 0; }; class Circle : public IDrawable { public: void draw() override { puts("Circle::draw()"); } }; class Squre : public IDrawable { public: void draw() override { puts("Squre::draw()"); } }; void render(IDrawable& drawable) { drawable.draw(); } 但是有了 Concept 后：
template &lt;typename T> concept Drawable = requires(T t) { { t.draw() } -> std::same_as&lt;void>; }; class Circle { public: void draw() const { puts("Circle::draw()"); } }; class Squre { public: void draw() { puts("Squre::draw()"); } }; template &lt;Drawable T> void render(T& drawable) { drawable....</p></div><footer class=entry-footer><span title='2025-04-28 00:00:00 +0000 UTC'>2025-04-28</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;109 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 使用 Concept 替代基于虚函数的接口" href=https://kerolt.github.io/posts/c++/%E4%BD%BF%E7%94%A8-concept-%E6%9B%BF%E4%BB%A3%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++何时会阻止默认的特殊成员函数的生成</h2></header><div class=entry-content><p>在C++中，编译器会根据类的定义情况自动决定是否生成默认的特殊成员函数（如构造函数、拷贝/移动操作、析构函数）。
1. 用户显式声明相关成员函数 显式声明或删除某个函数：
如果用户显式声明（即使使用 =default 或 =delete）某个特殊成员函数，编译器将不再生成默认版本。例如：
class Example { public: Example() = default; // 允许生成默认构造函数 Example(const Example&) {} // 用户定义的拷贝构造函数 // 编译器不再生成默认的移动构造函数和移动赋值运算符 }; 2. 用户定义析构函数、拷贝/移动操作的影响 定义析构函数：
如果用户定义了析构函数（即使为空），编译器会删除默认的移动操作（移动构造函数和移动赋值运算符），但拷贝操作仍可能生成（除非其他条件阻止）。
class Example { public: ~Example() {} // 用户定义的析构函数 // 移动操作被隐式删除，拷贝操作可能生成（若无其他限制） }; 定义拷贝操作：
如果用户定义了拷贝构造函数或拷贝赋值运算符，编译器会删除默认的移动操作。
class Example { public: Example(const Example&) {} // 用户定义的拷贝构造函数 // 移动操作被隐式删除 }; 定义移动操作：
如果用户定义了移动构造函数或移动赋值运算符，编译器会删除默认的拷贝操作。
#include &lt;utility> #include &lt;string> #include &lt;iostream> struct Example { std::string str; Example() = default; Example(const std::string& s): str(s) { std::cout &lt;&lt; "Example()\n"; } Example(Example&& other) { str = std::move(other....</p></div><footer class=entry-footer><span title='2025-03-13 00:00:00 +0000 UTC'>2025-03-13</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++何时会阻止默认的特殊成员函数的生成" href=https://kerolt.github.io/posts/c++/c++%E4%BD%95%E6%97%B6%E4%BC%9A%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project3 Query Execution 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！
这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。
前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：
auto BustubInstance::ExecuteSqlTxn(const std::string &amp;sql, ResultWriter &amp;writer, Transaction *txn, std::shared_ptr&lt;CheckOptions> check_options) -> bool { if (!sql.empty() && sql[0] == '\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement->type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner....</p></div><footer class=entry-footer><span title='2025-03-11 00:00:00 +0000 UTC'>2025-03-11</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2423 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project3 Query Execution 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project2 Extendible Hash Index 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写Lab时的思路，按照课程要求不会在Github和博客中公开源代码。欢迎与我一起讨论交流！
太菜了，从没打过这么艰难的仗QAQ。由于课程的要求不能公开源代码，所以网上的资源会少很多，平台上的测试案例比较全面，有的还比较刁钻，需要考虑到可拓展哈希的实现细节。在自认为写完了后，提交了近40来次总有几个测试集过不了，还好没有崩溃，在看了几篇博客的方法后，加上自己画图理解，最后终于过了😭。不过回头写博客的时候再去看代码，也没有特别的复杂，还是得明白其中的算法逻辑是如何实现的。
Task1 - Read/Write Page Guards 简单来说，就是为Page实现一个RAII来自动管理资源。因为在BufferPoolManager::Unpin中，每次调用这个函数，都会让对应的page的pin_count_ - 1，当这个值为0时，这个page就可以被回收，或者说被替换了。但如果我们忘记去手动调用，该页面将永远不会被逐出缓冲池。由于缓冲池以更少的帧数运行，磁盘内外的页面交换将更多。不仅性能受到影响，而且很难检测到错误。
主要需要考虑如何编写移动构造、移动赋值的逻辑。移动了一个对象后，原来的对象的资源应该转移到了新对象上，那么原来的对象无法再访问资源（将原来对象的资源重置nullptr或清空）。
还有一个Drop()的接口，这是提供给使用者的释放资源的api，在实现虚构函数时可以直接调用它。Drop的实现就是调用Unpin，然后置空资源。需要注意的是，在进行移动赋值时，一开始也要Drop一下，考虑这样一种情况：
auto p = std::move(basic_page_guard); p = std::move(basic_page_guard2); 这个时候同一个变量p接管了两个page，那么应该在第二个移动赋值时先drop掉第一个，因为第一个page不再使用了，自然要Unpin。
还有就是在三个page guard类重载移动赋值时，如果需要移动的对象和自身是同一个，那么直接返回自己就好：
auto BasicPageGuard::operator=(BasicPageGuard &&amp;that) noexcept -> BasicPageGuard & { if (&amp;that == this) { return *this; } // ... 其他操作 } 在ReadPageGuard和WritePageGuard的Drop()中，还需要考虑释放管理的page的锁。对应的，锁的获取发生在FetchPageWrite()和FetchPageWrite()中。
Task2 - Extendible Hash Table Pages 为什么我们需要可扩展哈希？
下图来源：https://www.bilibili.com/video/BV1Qt421w7JT
在bustub的设计中，Header Page，Directory Page和Bucket Page都是无法直接构造出来的，即不能通过构造函数创建，只能通过各自的PageGuard中的As()或者AsMut()函数来转换。
Header header page中有一个max_depth_的成员变量，1 &lt;&lt; max_depth_即为header page中能存放的目录的索引的数量。当我们有值需要放入哈希表时，获取hash(key)的二进制最高max_depth_位作为索引，再从header中对应位置去找到directory。对应的ExtendibleHTableHeaderPage中的功能实现并不难。
Directory directory中有两个depth：
Global Depth：若global depth为n，那么这个Directory就有2^n个entry（相当于指向2^n个bucket） Local Depth：若local depth为n，则在这个对应的bucket下，每个元素的key的最后n位都相同 类似header中获取下一级页的索引，directory获取hash(key)的二进制最低global_depth_位作为索引。那local depth的作用是什么呢？...</p></div><footer class=entry-footer><span title='2024-11-12 00:00:00 +0000 UTC'>2024-11-12</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;282 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project2 Extendible Hash Index 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project2-extendible-hash-index-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project1 Buffer Pool 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写Lab时的思路，按照课程要求不会在Github和博客中公开源代码。欢迎与我一起讨论交流！
这个Project需要我们实现一个缓存池，减少对于磁盘的频繁IO。开始慢慢上强度了，细节拉满！
...</p></div><footer class=entry-footer><span title='2024-10-12 00:00:00 +0000 UTC'>2024-10-12</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;295 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project1 Buffer Pool 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project1-buffer-pool-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【CMU15-445 Fall2023】Project0 C++ Primer 小结</h2></header><div class=entry-content><p>该系列博客只是为了记录自己在写Lab时的思路，按照课程要求不会在Github和博客中公开源代码。欢迎与我一起讨论交流！
project0只在task4中浅浅涉及了一点BusTub的内容，其他都是检测我们对于C++的一个掌握，主要涉及智能指针和C++的常用特性（dynamic_cast、std::move、并发与锁等）。
...</p></div><footer class=entry-footer><span title='2024-10-06 00:00:00 +0000 UTC'>2024-10-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;65 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【CMU15-445 Fall2023】Project0 C++ Primer 小结" href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project0-c++-primer-%E5%B0%8F%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 5】常用IO函数的HOOK功能</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
hook函数的具体定义实现可以在这里查看：Github: src/hook.cpp
该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。
hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。
...</p></div><footer class=entry-footer><span title='2024-09-30 00:00:00 +0000 UTC'>2024-09-30</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;108 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 5】常用IO函数的HOOK功能" href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>【动手写协程库 4】IO协程调度器</h2></header><div class=entry-content><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
IOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp
之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。
sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。
...</p></div><footer class=entry-footer><span title='2024-09-29 00:00:00 +0000 UTC'>2024-09-29</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;782 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【动手写协程库 4】IO协程调度器" href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://kerolt.github.io/tags/cplusplus/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>