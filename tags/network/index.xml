<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Network on Kerolt&#39;s Blog</title>
    <link>https://kerolt.github.io/tags/network/</link>
    <description>Recent content in Network on Kerolt&#39;s Blog</description>
    <image>
      <title>Kerolt&#39;s Blog</title>
      <url>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.152.2</generator>
    <language>en</language>
    <lastBuildDate>Wed, 17 Sep 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kerolt.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux NAPI机制知识点总结</title>
      <link>https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-napi%E6%9C%BA%E5%88%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux-napi%E6%9C%BA%E5%88%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;对 &lt;a href=&#34;https://docs.kernel.org/networking/napi.html&#34;&gt;https://docs.kernel.org/networking/napi.html&lt;/a&gt; 的总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NAPI (New API，但现已无特定含义) 是 Linux 内核中用于高效处理网络数据包的一种机制，旨在减少高负载下的中断开销。&lt;/p&gt;
&lt;p&gt;其​目的​​是为了解决传统基于中断的包处理在高流量下的性能问题（“中断活锁”）。通过混合​&lt;strong&gt;​中断​&lt;/strong&gt;​和​&lt;strong&gt;​轮询​&lt;/strong&gt;​模式，在低负载时使用中断保证低延迟，在高负载时切换到轮询保证高吞吐量。&lt;/p&gt;
&lt;p&gt;设备通过中断通知有新数据包 -&amp;gt; 内核调度对应的 NAPI 实例 -&amp;gt; 在软中断上下文（或内核线程）中轮询处理多个数据包 -&amp;gt; 处理完毕后再打开中断。&lt;/p&gt;
&lt;h2 id=&#34;核心数据结构与-api&#34;&gt;核心数据结构与 API&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​&lt;code&gt;struct napi_struct&lt;/code&gt;​&lt;/strong&gt;​：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心数据结构，代表一个 NAPI 实例，保存其状态信息。&lt;/li&gt;
&lt;li&gt;通常与一个中断或一个队列（RX/TX）相关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​控制 API (初始化和状态管理)​&lt;/strong&gt;​：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;netif_napi_add()&lt;/code&gt; / &lt;code&gt;netif_napi_del()&lt;/code&gt;: 向系统添加/删除一个 NAPI 实例（通常附加到网络设备上）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;napi_enable()&lt;/code&gt; / &lt;code&gt;napi_disable()&lt;/code&gt;: 启用/禁用 NAPI 实例。禁用状态下实例不会被调度，&lt;code&gt;poll&lt;/code&gt; 方法不会被调用。​&lt;strong&gt;​注意​&lt;/strong&gt;​：API 非幂等，错误调用顺序可能导致死锁或竞态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​数据路径 API (调度与处理)​&lt;/strong&gt;​：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;napi_schedule()&lt;/code&gt;: ​&lt;strong&gt;​核心调度函数​&lt;/strong&gt;​。通常在设备的中断处理程序中调用，通知内核有数据需要处理，并获取 NAPI 实例的所有权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;napi_schedule_irqoff()&lt;/code&gt;: &lt;code&gt;napi_schedule()&lt;/code&gt; 的变体，用于已知在中断上下文中调用的情况，可优化中断屏蔽操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;napi_complete_done()&lt;/code&gt;: ​&lt;strong&gt;​完成处理函数​&lt;/strong&gt;​。当驱动程序的 &lt;code&gt;poll&lt;/code&gt; 方法处理完所有事件后调用此函数，释放实例的所有权。​&lt;strong&gt;​警告​&lt;/strong&gt;​：&lt;code&gt;budget&lt;/code&gt; 为 0 时绝不能调用；若处理恰好用完 &lt;code&gt;budget&lt;/code&gt; 且工作已完成，需谨慎返回 &lt;code&gt;budget - 1&lt;/code&gt; 或等待下次调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;驱动程序实现要点&#34;&gt;驱动程序实现要点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​&lt;code&gt;poll&lt;/code&gt; 方法​&lt;/strong&gt;​：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驱动必须实现的回调函数，由内核调度执行实际的数据包处理工作。&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​参数 &lt;code&gt;budget&lt;/code&gt;​&lt;/strong&gt;​：限制一次 &lt;code&gt;poll&lt;/code&gt; 调用最多可处理的​&lt;strong&gt;​接收​&lt;/strong&gt;​（RX）数据包数量（发送 TX 处理无此限制）。若返回值为 &lt;code&gt;budget&lt;/code&gt;，表示还有工作未完成，内核会再次调度；若小于 &lt;code&gt;budget&lt;/code&gt;，表示本轮处理已完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;strong&gt;​中断屏蔽策略​&lt;/strong&gt;​：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【问题记录】ddns-go与IPv6网络配置</title>
      <link>https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95ddns-go%E4%B8%8Eipv6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 29 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95ddns-go%E4%B8%8Eipv6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;p&gt;在完成 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/1943305270387275457&#34;&gt;Rustdesk 自建服务器&lt;/a&gt; 的搭建后，我又想到：由于实验室服务器的公网 &lt;strong&gt;IPv6 地址&lt;/strong&gt; 并非永久不变，直接使用 IP 进行远程连接（如 SSH 或 Rustdesk）并不现实，如何确保远程访问的稳定性和便利性呢。为了解决这一痛点，我决定利用 &lt;strong&gt;动态域名解析（DDNS）&lt;/strong&gt; 技术，配合 &lt;strong&gt;ddns-go&lt;/strong&gt; 和 &lt;strong&gt;阿里云 DNS&lt;/strong&gt; 服务，将服务器的动态 IP 地址实时绑定到一个易于记忆的域名上。&lt;/p&gt;
&lt;p&gt;本文将记录我在配置过程中遇到的四个主要问题及其解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;问题-1ipv6-临时地址导致域名解析不稳定&#34;&gt;问题 1：IPv6 临时地址导致域名解析不稳定&lt;/h2&gt;
&lt;p&gt;在启用 &lt;strong&gt;ddns-go&lt;/strong&gt; 服务后，我发现尽管程序运行正常，但我的域名解析记录却频繁失效。经过排查，我意识到罪魁祸首是 &lt;strong&gt;IPv6 临时地址（Temporary Address）&lt;/strong&gt;。这是一种为了增强用户隐私而设计的特性，系统会定期生成新的、临时的 IPv6 地址用于出站连接。当服务器的地址发生变化时，DDNS 服务来不及同步更新，就会导致域名无法解析到正确的 IP 地址。&lt;/p&gt;
&lt;h3 id=&#34;解决方案禁用-ipv6-临时地址&#34;&gt;解决方案：禁用 IPv6 临时地址&lt;/h3&gt;
&lt;p&gt;要解决这个问题，最直接的方法就是从系统层面禁用 IPv6 临时地址功能，强制使用稳定的、非临时的地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编辑 sysctl 配置文件&lt;/strong&gt;：
使用 &lt;code&gt;vim&lt;/code&gt; 或其他编辑器打开 &lt;code&gt;sysctl.conf&lt;/code&gt; 文件，该文件用于在系统启动时配置内核参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo vim /etc/sysctl.conf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;添加配置项&lt;/strong&gt;：
在文件末尾添加以下两行，分别用于&lt;strong&gt;全局禁用&lt;/strong&gt;和&lt;strong&gt;默认禁用&lt;/strong&gt;所有网络接口的 IPv6 临时地址功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# 禁用 IPv6 临时地址&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv6.conf.all.use_tempaddr &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv6.conf.enp4s0.use_tempaddr &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果只想针对特定网卡（例如 &lt;code&gt;enp4s0&lt;/code&gt;）进行配置，可以添加 &lt;code&gt;net.ipv6.conf.enp4s0.use_tempaddr = 0&lt;/code&gt;。你可以通过 &lt;code&gt;ip a&lt;/code&gt; 命令查看你机器的网卡名称。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
