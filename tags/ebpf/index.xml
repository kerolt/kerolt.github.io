<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>EBPF on Kerolt&#39;s Blog</title>
    <link>https://kerolt.github.io/tags/ebpf/</link>
    <description>Recent content in EBPF on Kerolt&#39;s Blog</description>
    <image>
      <title>Kerolt&#39;s Blog</title>
      <url>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.152.2</generator>
    <language>en</language>
    <lastBuildDate>Wed, 29 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kerolt.github.io/tags/ebpf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TC和XDP</title>
      <link>https://kerolt.github.io/posts/ebpf/tc%E5%92%8Cxdp/</link>
      <pubDate>Wed, 29 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/tc%E5%92%8Cxdp/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;code&gt;tc&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;XDP&lt;/code&gt;&lt;/strong&gt; 都能对网络数据包进行处理，但它们位于 &lt;strong&gt;不同的网络协议栈层次&lt;/strong&gt;，因此性能、能力和适用场景差别都很大：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;项目&lt;/th&gt;
          &lt;th&gt;作用层级&lt;/th&gt;
          &lt;th&gt;处理方向&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;XDP (eXpress Data Path)&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;驱动层（最早）&lt;/strong&gt;：网络设备驱动入口处（L2 之前）&lt;/td&gt;
          &lt;td&gt;入站（Ingress）&lt;/td&gt;
          &lt;td&gt;极快，绕过内核协议栈，可直接丢包/转发&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;tc (Traffic Control)&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;内核网络栈层（L3/L4 之后）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;入站 + 出站&lt;/td&gt;
          &lt;td&gt;通常用于带宽控制、QoS、流量整形等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;linux-网络包处理路径&#34;&gt;Linux 网络包处理路径&lt;/h2&gt;
&lt;p&gt;下面这张图能清晰地看到 &lt;code&gt;XDP&lt;/code&gt; 和 &lt;code&gt;tc&lt;/code&gt; 各自处在什么位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |              用户空间                  |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |  (应用层: Nginx, curl, ping, etc.)     |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                ▲
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                │ send()/recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |            内核网络协议栈               |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |----------------------------------------|
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |   L4 (TCP/UDP)                         |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |   L3 (IP 路由转发)                     |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                |   L2 (Ethernet frame 处理)             |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     ▲                     ▲
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     │                     │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tc ingress/qdisc           tc egress/qdisc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             │                           │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             │                           ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        |        XDP (eXpress Data Path)         |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        | (位于网卡驱动中，最靠近硬件的钩子点)     |
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     ▲
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              NIC 驱动 / DMA 收包
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;处理路径细节对比&#34;&gt;处理路径细节对比&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;对比项&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;XDP&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;tc (ingress/egress)&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;所在层级&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;NIC 驱动层（比内核协议栈还早）&lt;/td&gt;
          &lt;td&gt;内核网络栈（L3/L4 层之间）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;钩子位置&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;驱动接收包 → DMA → XDP&lt;/td&gt;
          &lt;td&gt;skb（socket buffer）进入或离开协议栈时&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;作用方向&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;仅支持 ingress（入站）&lt;/td&gt;
          &lt;td&gt;支持 ingress + egress&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;处理对象&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;原始数据包（frame）&lt;/td&gt;
          &lt;td&gt;封装后的 skb&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;极高（可在百万 pps 级别）&lt;/td&gt;
          &lt;td&gt;中等（受内核调度和 qdisc 影响）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;典型用途&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;DDoS 防护、早期丢包、快速转发、内核旁路&lt;/td&gt;
          &lt;td&gt;QoS、流量整形、限速、包分类&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;可编程性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;eBPF 程序（xdp 程序）&lt;/td&gt;
          &lt;td&gt;eBPF 程序（cls_bpf）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;返回动作&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;XDP_PASS、XDP_DROP、XDP_TX、XDP_REDIRECT&lt;/td&gt;
          &lt;td&gt;TC_ACT_OK、TC_ACT_SHOT、TC_ACT_REDIRECT&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;使用接口&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;ip link set dev eth0 xdp obj prog.o&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;tc filter add dev eth0 ... bpf obj prog.o&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;数据处理流程举例&#34;&gt;数据处理流程举例&lt;/h2&gt;
&lt;h3 id=&#34;xdp-流程最早阶段&#34;&gt;XDP 流程（最早阶段）&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[网卡接收包]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[XDP 程序执行]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ├── XDP_DROP：直接丢包（不进入内核）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ├── XDP_PASS：让包进入内核协议栈
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ├── XDP_TX：直接从驱动回发
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   └── XDP_REDIRECT：转发到其他网卡或 AF_XDP socket
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;典型用途：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>eBPF中何时使用字节序转换函数</title>
      <link>https://kerolt.github.io/posts/ebpf/ebpf%E4%B8%AD%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 23 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/ebpf%E4%B8%AD%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在 eBPF 中，什么时候应该用 bpf_htons、bpf_htonl、bpf_ntohs、bpf_ntohl？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些 &lt;code&gt;bpf_*&lt;/code&gt; 函数是 eBPF 程序中用于&lt;strong&gt;字节序转换&lt;/strong&gt;的辅助函数。它们的作用与标准的 C 库中的 &lt;code&gt;htons&lt;/code&gt;、&lt;code&gt;htonl&lt;/code&gt;、&lt;code&gt;ntohs&lt;/code&gt;、&lt;code&gt;ntohl&lt;/code&gt; 类似，但针对 BPF 环境进行了优化或封装。它们用于在&lt;strong&gt;主机字节序&lt;/strong&gt;（Host Byte Order）和&lt;strong&gt;网络字节序&lt;/strong&gt;（Network Byte Order）之间进行转换。&lt;/p&gt;
&lt;p&gt;简而言之，当在 BPF 程序中处理&lt;strong&gt;网络协议头部&lt;/strong&gt;（如 IP、TCP、UDP）中的&lt;strong&gt;多字节字段&lt;/strong&gt;时，就需要使用这些函数。&lt;/p&gt;
&lt;p&gt;网络协议标准（例如，IPv4、TCP、UDP）规定所有多字节数值（如端口号、IP 地址、校验和等）都必须以&lt;strong&gt;网络字节序&lt;/strong&gt;（大端序，Big-Endian）传输。&lt;/p&gt;
&lt;hr&gt;

    &lt;div class=&#34;admonition note&#34;&gt;
      &lt;div class=&#34;admonition-header&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 576 512&#34;&gt;&lt;path d=&#34;M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z&#34;/&gt;&lt;/svg&gt;
        &lt;span&gt;Note&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;admonition-content&#34;&gt;
        &lt;p&gt;&lt;code&gt;bpf_ntohs&lt;/code&gt; (Network To Host Short) &amp;amp; &lt;code&gt;bpf_ntohl&lt;/code&gt; (Network To Host Long)&lt;/p&gt;</description>
    </item>
    <item>
      <title>eBPF Map中的数据成员类型的宏定义</title>
      <link>https://kerolt.github.io/posts/ebpf/ebpf-map%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 07 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/ebpf-map%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>&lt;p&gt;&lt;code&gt;__uint&lt;/code&gt;, &lt;code&gt;__type&lt;/code&gt;, &lt;code&gt;__array&lt;/code&gt;, &lt;code&gt;__ulong&lt;/code&gt; 这些宏主要用于 &lt;strong&gt;eBPF Map 的定义&lt;/strong&gt; 中，帮助 LLVM 编译器和 BPF CO-RE (Compile Once – Run Everywhere) 理解和提取 eBPF Map 的元数据信息。它们通常与 &lt;code&gt;BPF_MAP_DEF&lt;/code&gt; 或 &lt;code&gt;struct&lt;/code&gt; 配合使用，在 eBPF 程序中用于告诉内核如何创建 BPF map。&lt;/p&gt;
&lt;h2 id=&#34;常用的几个宏&#34;&gt;常用的几个宏&lt;/h2&gt;
&lt;h3 id=&#34;1-__uintname-val&#34;&gt;1. &lt;code&gt;__uint(name, val)&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#099&#34;&gt;#define __uint(name, val) int (*name)[val]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;用途：定义一个名为 &lt;code&gt;name&lt;/code&gt; 的字段，其值是一个大小为 &lt;code&gt;val&lt;/code&gt; 的整数数组指针。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#c0f&#34;&gt;__uint&lt;/span&gt;(max_entries, &lt;span style=&#34;color:#f60&#34;&gt;1024&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等价于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;max_entries)[&lt;span style=&#34;color:#f60&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;br&gt;
用于在 eBPF Map 的定义中指定 &lt;code&gt;max_entries&lt;/code&gt; 这一属性（即 map 的最大容量）。这种“类型欺骗”的方式让 clang 编译器能保留这些信息在 ELF 文件的 BTF（BPF Type Format）部分里，从而被 bpftool、libbpf 提取并传给内核。&lt;/p&gt;
&lt;h3 id=&#34;2-__typename-val&#34;&gt;2. &lt;code&gt;__type(name, val)&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#099&#34;&gt;#define __type(name, val) typeof(val) *name
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;用途：定义一个名为 &lt;code&gt;name&lt;/code&gt; 的字段，其类型是 &lt;code&gt;val&lt;/code&gt; 的指针。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CO-RE机制与vmlinux.h</title>
      <link>https://kerolt.github.io/posts/ebpf/co-re%E6%9C%BA%E5%88%B6%E4%B8%8Evmlinux.h/</link>
      <pubDate>Tue, 01 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/co-re%E6%9C%BA%E5%88%B6%E4%B8%8Evmlinux.h/</guid>
      <description>&lt;p&gt;通过解耦编译时依赖和运行时重定位，实现 BPF 程序对内核版本与配置差异的自动适配。vmlinux.h 之所以无需严格匹配你的内核配置或版本，关键在于以下机制：&lt;/p&gt;
&lt;h2 id=&#34;btfbpf-type-format提供统一类型描述&#34;&gt;BTF（BPF Type Format）提供统一类型描述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vmlinux.h 本质是内核 BTF 的 C 语言翻译&lt;/strong&gt;：它由 &lt;code&gt;bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; vmlinux.h&lt;/code&gt; 命令生成，完整包含内核所有数据结构的类型定义（如结构体、枚举）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立于具体配置&lt;/strong&gt;：BTF 记录了内核的&lt;strong&gt;最终内存布局&lt;/strong&gt;（包括因配置选项如 &lt;code&gt;CONFIG_COMPAT&lt;/code&gt; 导致的字段偏移变化）。因此，编译时使用的 &lt;code&gt;vmlinux.h&lt;/code&gt; 只需是&lt;strong&gt;某一有效内核的 BTF 快照&lt;/strong&gt;，无需与目标内核完全一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生成-vmlinuxh&#34;&gt;生成 vmlinux.h&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; vmlinux.h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;clang-编译时记录重定位元信息&#34;&gt;Clang 编译时记录“重定位元信息”&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当使用 Clang（≥10）编译 BPF 程序时，对内核结构的访问（如 &lt;code&gt;task_struct-&amp;gt;pid&lt;/code&gt;）会被转换为 &lt;strong&gt;CO-RE 重定位项&lt;/strong&gt;。这些项记录：
&lt;ul&gt;
&lt;li&gt;访问的&lt;strong&gt;字段名&lt;/strong&gt;（如 &lt;code&gt;pid&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型路径&lt;/strong&gt;（如 &lt;code&gt;struct task_struct&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;预期偏移/大小等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此过程依赖 &lt;code&gt;vmlinux.h&lt;/code&gt; 提供类型合法性检查，但&lt;strong&gt;不绑定具体偏移&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;libbpf-运行时动态重定位&#34;&gt;libbpf 运行时动态重定位&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加载 BPF 程序时，libbpf 执行关键两步：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;查询目标内核的 BTF&lt;/strong&gt;（&lt;code&gt;/sys/kernel/btf/vmlinux&lt;/code&gt;），获取实际结构布局；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比对编译时的重定位项&lt;/strong&gt;，修正字段偏移、处理字段增减（如通过 &lt;code&gt;bpf_core_field_exists()&lt;/code&gt; 判断成员是否存在）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例如：若目标内核的 &lt;code&gt;struct user_arg_ptr&lt;/code&gt; 因 &lt;code&gt;CONFIG_COMPAT=y&lt;/code&gt; 新增 &lt;code&gt;is_compat&lt;/code&gt; 字段，libbpf 会自动调整 &lt;code&gt;native&lt;/code&gt; 字段的访问偏移。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;co-re-辅助函数实现条件兼容&#34;&gt;CO-RE 辅助函数实现条件兼容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BPF 代码可通过以下函数动态适应内核差异：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bpf_core_read(dst, src)&lt;/code&gt;&lt;/strong&gt;：替代直接指针访问，按运行时偏移安全读取字段；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BPF_CORE_READ(src, field)&lt;/code&gt;&lt;/strong&gt;：处理嵌套结构；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bpf_core_field_exists(field)&lt;/code&gt;&lt;/strong&gt;：条件执行兼容逻辑（如选择参数索引）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这些函数在编译时生成重定位项，在运行时由 libbpf 解析为正确操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实际限制与注意事项&#34;&gt;实际限制与注意事项&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;限制&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;目标内核需开启 BTF&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;必须配置 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt;（多数发行版已默认开启）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;旧内核无 BTF 支持&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;若无 BTF，需手动提供等效的 BTF 文件（如通过 &lt;a href=&#34;https://github.com/aquasecurity/btfhub&#34;&gt;BTFHub&lt;/a&gt;）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;宏与函数签名变化&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;BTF 不记录宏或函数参数列表变化，需通过 &lt;code&gt;#ifdef&lt;/code&gt; 或运行时检测处理。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;BPF CO-RE 将&lt;strong&gt;类型描述&lt;/strong&gt;（&lt;code&gt;vmlinux.h&lt;/code&gt;）、&lt;strong&gt;编译时元信息&lt;/strong&gt;（Clang 重定位项）、&lt;strong&gt;运行时适配器&lt;/strong&gt;（libbpf）三者分离，使 &lt;code&gt;vmlinux.h&lt;/code&gt; 仅需作为“合法类型模板”，而&lt;strong&gt;非精确内存布局参考&lt;/strong&gt;。最终由 libbpf 借助目标内核的 BTF 完成字段偏移、存在性的动态修正，实现跨版本/配置的运行兼容。这一机制大幅降低了 eBPF 程序的移植成本，使其真正成为“一次编译，到处运行”的内核可编程工具。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【eBPF学习】使用fentry跟踪tcp连接</title>
      <link>https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8fentry%E8%B7%9F%E8%B8%AAtcp%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sun, 22 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8fentry%E8%B7%9F%E8%B8%AAtcp%E8%BF%9E%E6%8E%A5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a href=&#34;https://github.com/cilium/ebpf/tree/main/examples/fentry&#34;&gt;cilium/ebpf examples: fentry &lt;/a&gt;的一个学习记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，我们将会利用 ebpf 监控并记录系统上所有新发起的 IPv4 TCP 连接，其工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;挂载点&lt;/strong&gt;：程序使用 &lt;code&gt;fentry&lt;/code&gt; 机制把自己附加到内核函数 &lt;code&gt;tcp_connect&lt;/code&gt; 的入口。每当系统中有任何一个进程尝试发起一个 TCP 连接时，这个内核函数就会被调用，从而触发我们的 eBPF 程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤&lt;/strong&gt;：程序首先检查连接的地址族是否为 &lt;code&gt;AF_INET&lt;/code&gt;，即 IPv4。如果不是（例如是 IPv6），程序会直接退出，不做任何处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据提取&lt;/strong&gt;：对于 IPv4 连接，程序会从传递给 &lt;code&gt;tcp_connect&lt;/code&gt; 函数的 &lt;code&gt;struct sock&lt;/code&gt; 参数中提取以下关键信息：
&lt;ul&gt;
&lt;li&gt;源 IP 地址 (&lt;code&gt;saddr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;目标 IP 地址 (&lt;code&gt;daddr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;目标端口 (&lt;code&gt;dport&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;源端口 (&lt;code&gt;sport&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取进程信息&lt;/strong&gt;：使用 &lt;code&gt;bpf_get_current_comm()&lt;/code&gt; 辅助函数获取当前发起连接的进程名（例如 &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;ssh&lt;/code&gt; 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据发送&lt;/strong&gt;：程序将收集到的所有信息（IP 地址、端口、进程名）打包成一个 &lt;code&gt;struct event&lt;/code&gt; 结构体，并通过一个高效的 &lt;code&gt;ringbuf&lt;/code&gt; 映射发送到用户空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是-fentry&#34;&gt;什么是 fentry&lt;/h2&gt;
&lt;p&gt;fentry 是 eBPF 中的一种程序附加类型，全称为 &amp;ldquo;function entry&amp;rdquo;（函数入口）。它是现代 Linux 内核中用于跟踪和性能分析的高效机制。&lt;/p&gt;
&lt;p&gt;fentry 允许将 eBPF 程序附加到内核函数的入口点，当该函数被调用时，eBPF 程序会在函数的主体执行前运行。这种机制让我们可以：&lt;/p&gt;</description>
    </item>
    <item>
      <title>【eBPF学习】使用kprobe监测捕获unlink系统调用</title>
      <link>https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8kprobe%E7%9B%91%E6%B5%8B%E6%8D%95%E8%8E%B7unlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Tue, 10 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8kprobe%E7%9B%91%E6%B5%8B%E6%8D%95%E8%8E%B7unlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是对于 &lt;a href=&#34;https://eunomia.dev/zh/tutorials/2-kprobe-unlink/&#34;&gt;Eunomia Tutorials 2&lt;/a&gt; 的一个学习记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;什么是-kprobe&#34;&gt;什么是 kprobe&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Kprobe​&lt;/strong&gt;​（Kernel Probe）是 Linux 内核提供的一项强大功能，它允许开发者和系统管理员在不​&lt;strong&gt;​修改内核源代码​&lt;/strong&gt;​或重启系统的前提下，在任意内核函数处动态插入“探针”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​工作原理​&lt;/strong&gt;​：通过​&lt;strong&gt;​临时替换​&lt;/strong&gt;​目标函数的前几条指令为一个断点指令（如 int3）&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​执行流程​&lt;/strong&gt;​：当程序执行到断点时，CPU 控制权会交给 kprobe 系统&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​事件回调​&lt;/strong&gt;​：系统执行注册的回调函数，完成数据采集后恢复原函数执行&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​两种类型​&lt;/strong&gt;​：
&lt;ul&gt;
&lt;li&gt;​&lt;strong&gt;​Kprobe​&lt;/strong&gt;​：在函数入口处执行&lt;/li&gt;
&lt;li&gt;​&lt;strong&gt;​Kretprobe​&lt;/strong&gt;​：在函数返回时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种机制为我们提供了​&lt;strong&gt;​零侵入式​&lt;/strong&gt;​的内核行为洞察能力，特别适用于​&lt;strong&gt;​实时监控​&lt;/strong&gt;​、​&lt;strong&gt;​性能分析​&lt;/strong&gt;​和​&lt;strong&gt;​故障排查​&lt;/strong&gt;​等场景。&lt;/p&gt;
&lt;h2 id=&#34;do_unlinkat-的作用&#34;&gt;do_unlinkat 的作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;do_unlinkat&lt;/code&gt; 是 Linux 内核中的一个内部函数，它的作用是&lt;strong&gt;执行文件或目录的删除操作&lt;/strong&gt;。其在内核源码中的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;do_unlinkat&lt;/span&gt;(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; dfd, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;struct&lt;/span&gt; filename &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;name) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_unlinkat&lt;/code&gt; 是内核中实际执行文件删除逻辑的最终汇聚点&lt;/li&gt;
&lt;li&gt;用户空间调用 &lt;code&gt;unlink()&lt;/code&gt;、&lt;code&gt;unlinkat()&lt;/code&gt; 或 &lt;code&gt;rmdir()&lt;/code&gt; 等系统调用时，最终都会通过系统调用表路由到这个函数&lt;/li&gt;
&lt;li&gt;采用文件描述符 (AT_FDCWD) 和路径名的组合方式，提供了灵活的路径解析能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vmlinuxh&#34;&gt;vmlinux.h&lt;/h2&gt;
&lt;p&gt;不同内核版本之间，内核数据结构如结构体字段位置、字段名称等都可能发生变化。传统的 eBPF 程序直接使用内核头文件会导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兼容性问题：程序在​&lt;strong&gt;​不同内核版本​&lt;/strong&gt;​中崩溃&lt;/li&gt;
&lt;li&gt;字段偏移错误：读取到​&lt;strong&gt;​无效内存数据​&lt;/strong&gt;​&lt;/li&gt;
&lt;li&gt;维护困难：需要针对​&lt;strong&gt;​每个内核版本​&lt;/strong&gt;​进行适配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;vmlinux.h&lt;/code&gt; 利用内核的​&lt;strong&gt;​BTF（BPF Type Format）​&lt;/strong&gt;​ 信息生成与当前运行内核完全匹配的类型定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; vmlinux.h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;内核态程序-kprobe_unlinkbpfc&#34;&gt;内核态程序 kprobe_unlink.bpf.c&lt;/h2&gt;
&lt;p&gt;为 &lt;code&gt;do_unlinkat&lt;/code&gt; 函数同时设置入口探针和返回探针：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
