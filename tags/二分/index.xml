<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>二分 on Kerolt&#39;s Blog</title>
    <link>https://kerolt.github.io/tags/%E4%BA%8C%E5%88%86/</link>
    <description>Recent content in 二分 on Kerolt&#39;s Blog</description>
    <image>
      <title>Kerolt&#39;s Blog</title>
      <url>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.126.2</generator>
    <language>en</language>
    <lastBuildDate>Wed, 07 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kerolt.github.io/tags/%E4%BA%8C%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>875. 爱吃香蕉的珂珂</title>
      <link>https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</link>
      <pubDate>Wed, 07 May 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</guid>
      <description>https://leetcode.cn/problems/koko-eating-bananas/
假设每小时吃 max(piles) 根香蕉，那么按照题意（向上取整）来说就只要 piles.length 个小时就可以吃完。而注意提示中的：piles.length &amp;lt;= h &amp;lt;= 10^9，这说明每小时吃 max(piles) 根香蕉已经是最大的速度了，再快也没用了。因此需要去找比 max(piles) 小的且满足题意的数。
那取 max(piles) 作为右边界，左边界取 1 （因为总不可能不吃吧~），然去通过二分去找最小的满足条件的速度。
class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int left = 1, right = *ranges::max_element(piles); auto check = [&amp;amp;](int x) { long long sum{}; for (int p : piles) { sum += (p + x - 1) / x; } return sum &amp;lt;= h; }; while (left &amp;lt;= right) { int mid = (left + right) &amp;gt;&amp;gt; 1; if (check(mid)) { right = mid - 1; } else { left = mid + 1; } } return left; } }; 相似题目：</description>
    </item>
    <item>
      <title>3488. 距离最小相等元素查询</title>
      <link>https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/3488.-%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/3488.-%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2/</guid>
      <description>https://leetcode.cn/problems/closest-equal-element-queries/
通过示例1来分析：
输入： nums = [1,3,1,4,1,3,2], queries = [0,3,5] 输出： [2,-1,3] 对于queries[0] = 0, nums[queries[0]] = 1来说，其在nums中的下标集合为p = [0, 2, 4]，由于nums是一个循环数组，所以按理来说数组p的第一个元素往左需要能找到最后一个元素，最后一个元素往右能找到第一个元素。
n 为 nums 的长度， 在下标列表前面添加 4−n=−3，相当于认为在 −3 下标处也有一个 1。 在下标列表末尾添加 0+n=7，相当于认为在 7 下标处也有一个 1。
题意是需要我们查询一个 nums 中的下标 x，与 任意 其他下标 j（满足 nums[j] == nums[x]）之间的 最小 距离。我们用哈希表将每个相同值的元素的下标收集起来作为集合 p，然后在查询时使用二分查询 x 在其对应集合中的位置 i，则左边最近的元素下标为 p[i - 1]，右边最近元素下标为 p[i + 1]，那么最小距离就是 min(p[i + 1] - x, x - p[i - 1])。
class Solution { public: vector&amp;lt;int&amp;gt; solveQueries(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; queries) { unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; m; int n = nums.</description>
    </item>
  </channel>
</rss>
