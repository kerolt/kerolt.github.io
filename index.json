[{"content":" https://leetcode.cn/problems/koko-eating-bananas/\nå‡è®¾æ¯å°æ—¶åƒ max(piles) æ ¹é¦™è•‰ï¼Œé‚£ä¹ˆæŒ‰ç…§é¢˜æ„ï¼ˆå‘ä¸Šå–æ•´ï¼‰æ¥è¯´å°±åªè¦ piles.length ä¸ªå°æ—¶å°±å¯ä»¥åƒå®Œã€‚è€Œæ³¨æ„æç¤ºä¸­çš„ï¼špiles.length \u0026lt;= h \u0026lt;= 10^9ï¼Œè¿™è¯´æ˜æ¯å°æ—¶åƒ max(piles) æ ¹é¦™è•‰å·²ç»æ˜¯æœ€å¤§çš„é€Ÿåº¦äº†ï¼Œå†å¿«ä¹Ÿæ²¡ç”¨äº†ã€‚å› æ­¤éœ€è¦å»æ‰¾æ¯” max(piles) å°çš„ä¸”æ»¡è¶³é¢˜æ„çš„æ•°ã€‚\né‚£å– max(piles) ä½œä¸ºå³è¾¹ç•Œï¼Œå·¦è¾¹ç•Œå– 1 ï¼ˆå› ä¸ºæ€»ä¸å¯èƒ½ä¸åƒå§~ï¼‰ï¼Œç„¶å»é€šè¿‡äºŒåˆ†å»æ‰¾æœ€å°çš„æ»¡è¶³æ¡ä»¶çš„é€Ÿåº¦ã€‚\nclass Solution { public: int minEatingSpeed(vector\u0026lt;int\u0026gt;\u0026amp; piles, int h) { int left = 1, right = *ranges::max_element(piles); auto check = [\u0026amp;](int x) { long long sum{}; for (int p : piles) { sum += (p + x - 1) / x; } return sum \u0026lt;= h; }; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (check(mid)) { right = mid - 1; } else { left = mid + 1; } } return left; } }; ç›¸ä¼¼é¢˜ç›®ï¼š\nhttps://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/ ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/","summary":"https://leetcode.cn/problems/koko-eating-bananas/\nå‡è®¾æ¯å°æ—¶åƒ max(piles) æ ¹é¦™è•‰ï¼Œé‚£ä¹ˆæŒ‰ç…§é¢˜æ„ï¼ˆå‘ä¸Šå–æ•´ï¼‰æ¥è¯´å°±åªè¦ piles.length ä¸ªå°æ—¶å°±å¯ä»¥åƒå®Œã€‚è€Œæ³¨æ„æç¤ºä¸­çš„ï¼špiles.length \u0026lt;= h \u0026lt;= 10^9ï¼Œè¿™è¯´æ˜æ¯å°æ—¶åƒ max(piles) æ ¹é¦™è•‰å·²ç»æ˜¯æœ€å¤§çš„é€Ÿåº¦äº†ï¼Œå†å¿«ä¹Ÿæ²¡ç”¨äº†ã€‚å› æ­¤éœ€è¦å»æ‰¾æ¯” max(piles) å°çš„ä¸”æ»¡è¶³é¢˜æ„çš„æ•°ã€‚\né‚£å– max(piles) ä½œä¸ºå³è¾¹ç•Œï¼Œå·¦è¾¹ç•Œå– 1 ï¼ˆå› ä¸ºæ€»ä¸å¯èƒ½ä¸åƒå§~ï¼‰ï¼Œç„¶å»é€šè¿‡äºŒåˆ†å»æ‰¾æœ€å°çš„æ»¡è¶³æ¡ä»¶çš„é€Ÿåº¦ã€‚\nclass Solution { public: int minEatingSpeed(vector\u0026lt;int\u0026gt;\u0026amp; piles, int h) { int left = 1, right = *ranges::max_element(piles); auto check = [\u0026amp;](int x) { long long sum{}; for (int p : piles) { sum += (p + x - 1) / x; } return sum \u0026lt;= h; }; while (left \u0026lt;= right) { int mid = (left + right) \u0026gt;\u0026gt; 1; if (check(mid)) { right = mid - 1; } else { left = mid + 1; } } return left; } }; ç›¸ä¼¼é¢˜ç›®ï¼š","title":"875. çˆ±åƒé¦™è•‰çš„ç‚ç‚"},{"content":"C++17 ä¸ºæ¨¡æ¿å…ƒç¼–ç¨‹å¸¦æ¥äº†ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç‰¹æ€§ï¼šæŠ˜å è¡¨è¾¾å¼ï¼ˆfold expressionsï¼‰ã€‚å®ƒçš„å‡ºç°è®©å˜å‚æ¨¡æ¿å‡½æ•°çš„ç¼–å†™å˜å¾—æ›´åŠ ç®€æ´ã€æ¸…æ™°å’Œç›´è§‚ã€‚\n1. å¦‚ä½•å¤„ç†å˜é•¿å‚æ•°åŒ… åœ¨ C++11/14 ä¸­ï¼Œå¦‚æœæˆ‘ä»¬è¦å¤„ç†å˜é•¿å‚æ•°åŒ…ï¼ˆparameter packï¼‰ï¼Œé€šå¸¸éœ€è¦é€’å½’å±•å¼€ï¼Œä¾‹å¦‚ï¼š\ntemplate\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T, typename... Args\u0026gt; void print(const T\u0026amp; t, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; print(args...); } è™½ç„¶è¿™æ®µä»£ç èƒ½å®Œæˆä»»åŠ¡ï¼Œä½†å´ç•¥æ˜¾å†—é•¿ï¼Œå¹¶ä¸”ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ä¹Ÿä¼šå¾ˆå¤šã€‚C++17 ä¸­å¼•å…¥çš„æŠ˜å è¡¨è¾¾å¼ï¼Œå°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nå¯ä»¥åœ¨ godbolt ä¸Šçœ‹çœ‹ä¸¤ç§æ–¹æ³•ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ï¼šhttps://godbolt.org/z/55a7q85oE\n2. ä»€ä¹ˆæ˜¯æŠ˜å è¡¨è¾¾å¼ æŠ˜å è¡¨è¾¾å¼æ˜¯ä¸€ç§ç”¨è¿ç®—ç¬¦å¯¹å‚æ•°åŒ…è¿›è¡ŒæŠ˜å çš„æ–¹å¼ã€‚æŠ˜å è¡¨è¾¾å¼çš„å®ä¾‹åŒ–æŒ‰ä»¥ä¸‹æ–¹å¼å±•å¼€æˆè¡¨è¾¾å¼Â eï¼š\nï¼ˆå›¾ç‰‡æ¥æºï¼šhttps://zh.cppreference.com/w/cpp/language/foldï¼‰\nåŸºæœ¬è¯­æ³•å½¢å¼ï¼š\nç±»å‹ è¯­æ³•å½¢å¼ ç¤ºä¾‹ ä¸€å…ƒå·¦æŠ˜å  (... op pack) (... + args) ä¸€å…ƒå³æŠ˜å  (pack op ...) (args + ...) äºŒå…ƒå·¦æŠ˜å  (init op ... op pack) (0 + ... + args) äºŒå…ƒå³æŠ˜å  (pack op ... op init) (args + ... + 0) æŠ˜å è¡¨è¾¾å¼æ”¯æŒå¤šç§è¿ç®—ç¬¦ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼š\nç®—æœ¯è¿ç®—ç¬¦ï¼š+, -, *, / é€»è¾‘è¿ç®—ç¬¦ï¼š\u0026amp;\u0026amp;, || æ¯”è¾ƒè¿ç®—ç¬¦ï¼š==, !=, \u0026lt;, \u0026gt; ä½è¿ç®—ç¬¦ï¼š\u0026amp;, |, ^ é€—å·è¿ç®—ç¬¦ï¼š, éœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nè‹¥å‚æ•°åŒ…ä¸ºç©ºï¼Œä½¿ç”¨äºŒå…ƒæŠ˜å å¯è®¾ç½®åˆå§‹å€¼é˜²æ­¢ç¼–è¯‘é”™è¯¯ã€‚ åˆå§‹å€¼æ”¾åœ¨å“ªè¾¹ï¼Œå°±ç”±å“ªä¸€è¾¹â€œå¼€å§‹ç»“åˆâ€ 3. æŠ˜å è¡¨è¾¾å¼ç¤ºä¾‹ 3.1 æ±‚å’Œå‡½æ•° template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (... + args); // å·¦æŠ˜å  } ä½¿ç”¨ï¼š\nstd::cout \u0026lt;\u0026lt; sum(1, 2, 3, 4); // è¾“å‡º 10 3.2 æ‰“å°å˜å‚ template\u0026lt;typename... Args\u0026gt; void print(Args\u0026amp;\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // å·¦æŠ˜å ç»“åˆæµè¾“å‡º } ä½¿ç”¨ï¼š\nprint(\u0026#34;Hello, \u0026#34;, \u0026#34;fold \u0026#34;, \u0026#34;expression!\u0026#34;); // è¾“å‡º Hello, fold expression! 3.3 æ‰€æœ‰å‚æ•°æ˜¯å¦éƒ½æ»¡è¶³æŸæ¡ä»¶ template\u0026lt;typename... Args\u0026gt; bool all_true(Args... args) { return (... \u0026amp;\u0026amp; args); } ä½¿ç”¨ï¼š\nbool result = all_true(true, true, false); // false 4. ä¸ std::cout ç»“åˆ std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; b \u0026lt;\u0026lt; c æ˜¯ä¸€ä¸ªå·¦ç»“åˆçš„è¡¨è¾¾å¼ï¼Œå…¶ç­‰ä»·äºï¼š\n((std::cout \u0026lt;\u0026lt; a) \u0026lt;\u0026lt; b) \u0026lt;\u0026lt; c å› æ­¤ï¼Œåœ¨ä½¿ç”¨æŠ˜å è¡¨è¾¾å¼æ¥æ‰“å°å‚æ•°æ—¶ï¼Œå¿…é¡»ä½¿ç”¨å·¦æŠ˜å ï¼ï¼ï¼ã€‚\næ­£ç¡®ç¤ºä¾‹ä¸ºï¼š\ntemplate\u0026lt;typename... Args\u0026gt; void print(Args\u0026amp;\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args); // å·¦æŠ˜å  } è¿™ä¸ªå±•å¼€æ–¹å¼ç­‰ä»·äºï¼š\n(((std::cout \u0026lt;\u0026lt; arg1) \u0026lt;\u0026lt; arg2) \u0026lt;\u0026lt; arg3) ... è¿™æ ·æ¯æ¬¡éƒ½æŠŠè¾“å‡ºç»“æœâ€œç»§ç»­â€ä¼ ç»™ std::cout \u0026lt;\u0026lt; ...ï¼Œä¿æŒæµæ“ä½œé“¾çš„æœ‰æ•ˆæ€§ã€‚\nä½†å¦‚æœæŒ‰ä¸‹é¢çš„å†™æ³•æ¥ï¼š\n(std::cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; ...); ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯æˆ–è€…è¯­ä¹‰é”™è¯¯ï¼Œå› ä¸º std::cout å¿…é¡»æ”¾åœ¨æœ€å·¦è¾¹ï¼Œæ‰èƒ½æ­£ç¡®å¯åŠ¨æµæ“ä½œé“¾ã€‚\n5. ä¸ std::cout å’Œé€—å·è¿ç®—ç¬¦ç»“åˆ å¯¹äºé€—å·è¿ç®—ç¬¦ï¼šåœ¨ (a, b) ä¸­ï¼Œé€—å·è¿ç®—ç¬¦ä¼šå…ˆæ‰§è¡Œ aï¼Œå†æ‰§è¡Œ bï¼Œè¿”å› b çš„å€¼ã€‚è¿™å…è®¸æˆ‘ä»¬ï¼š\nåœ¨ä¸€æ¬¡æŠ˜å ä¸­ æ‰§è¡Œå¤šæ¡è¯­å¥ ä¸”ç¡®ä¿é¡ºåºæ‰§è¡Œã€æ— ä¸­é—´å˜é‡å±•å¼€ ä¾‹å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š\n#include \u0026lt;iostream\u0026gt; template\u0026lt;typename... Args\u0026gt; void print(Args... args) { ((std::cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34;, \u0026#34;), ...); } int main() { print(1, 3.0, \u0026#39;*\u0026#39;); } å…¶åœ¨ç¼–è¯‘å™¨å¤„ç†ä¹‹åä¼šæ˜¯è¿™ä¸ªæ ·å­ï¼ˆä½¿ç”¨è¿™ä¸ªå·¥å…· https://cppinsights.io/ï¼‰ï¼š\n#include \u0026lt;iostream\u0026gt; template\u0026lt;typename ... Args\u0026gt; void print(Args... args) { (((std::cout \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#34;, \u0026#34;), ...); } template\u0026lt;\u0026gt; void print\u0026lt;int, double, char\u0026gt;(int __args0, double __args1, char __args2) { (std::operator\u0026lt;\u0026lt;(std::cout.operator\u0026lt;\u0026lt;(__args0), \u0026#34;, \u0026#34;)) , ( (std::operator\u0026lt;\u0026lt;(std::cout.operator\u0026lt;\u0026lt;(__args1), \u0026#34;, \u0026#34;)) , (std::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::cout, __args2), \u0026#34;, \u0026#34;)) ); } int main() { print(1, 3.0, \u0026#39;*\u0026#39;); return 0; } å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šçœ‹èµ·æ¥ ... åœ¨ args çš„å³è¾¹ï¼Œä½†è¿™ä¾ç„¶æ˜¯å·¦æŠ˜å ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/c++%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"C++17 ä¸ºæ¨¡æ¿å…ƒç¼–ç¨‹å¸¦æ¥äº†ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç‰¹æ€§ï¼šæŠ˜å è¡¨è¾¾å¼ï¼ˆfold expressionsï¼‰ã€‚å®ƒçš„å‡ºç°è®©å˜å‚æ¨¡æ¿å‡½æ•°çš„ç¼–å†™å˜å¾—æ›´åŠ ç®€æ´ã€æ¸…æ™°å’Œç›´è§‚ã€‚\n1. å¦‚ä½•å¤„ç†å˜é•¿å‚æ•°åŒ… åœ¨ C++11/14 ä¸­ï¼Œå¦‚æœæˆ‘ä»¬è¦å¤„ç†å˜é•¿å‚æ•°åŒ…ï¼ˆparameter packï¼‰ï¼Œé€šå¸¸éœ€è¦é€’å½’å±•å¼€ï¼Œä¾‹å¦‚ï¼š\ntemplate\u0026lt;typename T\u0026gt; void print(const T\u0026amp; t) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T, typename... Args\u0026gt; void print(const T\u0026amp; t, const Args\u0026amp;... args) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; print(args...); } è™½ç„¶è¿™æ®µä»£ç èƒ½å®Œæˆä»»åŠ¡ï¼Œä½†å´ç•¥æ˜¾å†—é•¿ï¼Œå¹¶ä¸”ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ä¹Ÿä¼šå¾ˆå¤šã€‚C++17 ä¸­å¼•å…¥çš„æŠ˜å è¡¨è¾¾å¼ï¼Œå°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nå¯ä»¥åœ¨ godbolt ä¸Šçœ‹çœ‹ä¸¤ç§æ–¹æ³•ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ï¼šhttps://godbolt.org/z/55a7q85oE\n2. ä»€ä¹ˆæ˜¯æŠ˜å è¡¨è¾¾å¼ æŠ˜å è¡¨è¾¾å¼æ˜¯ä¸€ç§ç”¨è¿ç®—ç¬¦å¯¹å‚æ•°åŒ…è¿›è¡ŒæŠ˜å çš„æ–¹å¼ã€‚æŠ˜å è¡¨è¾¾å¼çš„å®ä¾‹åŒ–æŒ‰ä»¥ä¸‹æ–¹å¼å±•å¼€æˆè¡¨è¾¾å¼Â eï¼š\nï¼ˆå›¾ç‰‡æ¥æºï¼šhttps://zh.cppreference.com/w/cpp/language/foldï¼‰\nåŸºæœ¬è¯­æ³•å½¢å¼ï¼š\nç±»å‹ è¯­æ³•å½¢å¼ ç¤ºä¾‹ ä¸€å…ƒå·¦æŠ˜å  (... op pack) (... + args) ä¸€å…ƒå³æŠ˜å  (pack op ...) (args + ...) äºŒå…ƒå·¦æŠ˜å  (init op .","title":"C++æŠ˜å è¡¨è¾¾å¼"},{"content":"åœ¨ C++20 åŠæ›´é«˜ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ Concepts æ¥æ›¿ä»£ä¼ ç»Ÿçš„åŸºäºè™šå‡½æ•°çš„æ¥å£è®¾è®¡ï¼Œè¿™ç§æ–¹å¼æä¾›äº†æ›´å¥½çš„ç¼–è¯‘æ—¶æ£€æŸ¥ã€æ›´é«˜æ•ˆçš„ä»£ç ç”Ÿæˆå’Œæ›´çµæ´»çš„æ¥å£çº¦æŸã€‚\nåœ¨ä¹‹å‰ï¼Œå¯èƒ½æ˜¯è¿™æ ·çš„ï¼š\nclass IDrawable { public: virtual ~IDrawable() = default; virtual void draw() const = 0; }; class Circle : public IDrawable { public: void draw() override { puts(\u0026#34;Circle::draw()\u0026#34;); } }; class Squre : public IDrawable { public: void draw() override { puts(\u0026#34;Squre::draw()\u0026#34;); } }; void render(IDrawable\u0026amp; drawable) { drawable.draw(); } ä½†æ˜¯æœ‰äº† Concept åï¼š\ntemplate \u0026lt;typename T\u0026gt; concept Drawable = requires(T t) { { t.draw() } -\u0026gt; std::same_as\u0026lt;void\u0026gt;; }; class Circle { public: void draw() const { puts(\u0026#34;Circle::draw()\u0026#34;); } }; class Squre { public: void draw() { puts(\u0026#34;Squre::draw()\u0026#34;); } }; template \u0026lt;Drawable T\u0026gt; void render(T\u0026amp; drawable) { drawable.draw(); } ä¼˜åŠ¿ï¼š\nâ€‹â€‹ç¼–è¯‘æ—¶å¤šæ€â€‹â€‹ï¼šä¸éœ€è¦è¿è¡Œæ—¶è™šè¡¨æŸ¥æ‰¾ï¼Œæ€§èƒ½æ›´é«˜ â€‹â€‹å€¼è¯­ä¹‰â€‹â€‹ï¼šå¯ä»¥ç›´æ¥ä¼ é€’å¯¹è±¡è€Œä¸éœ€è¦æŒ‡é’ˆæˆ–å¼•ç”¨ â€‹â€‹æ›´çµæ´»çš„çº¦æŸâ€‹â€‹ï¼šå¯ä»¥çº¦æŸå¤šä¸ªä¸ç›¸å…³çš„ç±»å‹ â€‹â€‹æ›´å¥½çš„é”™è¯¯ä¿¡æ¯â€‹â€‹ï¼šç¼–è¯‘é”™è¯¯æ›´æ¸…æ™°æ˜ç¡® â€‹â€‹æ— å¯¹è±¡åˆ‡ç‰‡é—®é¢˜â€‹â€‹ï¼šå› ä¸ºä¸ä½¿ç”¨ç»§æ‰¿ ","permalink":"https://kerolt.github.io/posts/c++/%E4%BD%BF%E7%94%A8-concept-%E6%9B%BF%E4%BB%A3%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/","summary":"åœ¨ C++20 åŠæ›´é«˜ç‰ˆæœ¬ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ Concepts æ¥æ›¿ä»£ä¼ ç»Ÿçš„åŸºäºè™šå‡½æ•°çš„æ¥å£è®¾è®¡ï¼Œè¿™ç§æ–¹å¼æä¾›äº†æ›´å¥½çš„ç¼–è¯‘æ—¶æ£€æŸ¥ã€æ›´é«˜æ•ˆçš„ä»£ç ç”Ÿæˆå’Œæ›´çµæ´»çš„æ¥å£çº¦æŸã€‚\nåœ¨ä¹‹å‰ï¼Œå¯èƒ½æ˜¯è¿™æ ·çš„ï¼š\nclass IDrawable { public: virtual ~IDrawable() = default; virtual void draw() const = 0; }; class Circle : public IDrawable { public: void draw() override { puts(\u0026#34;Circle::draw()\u0026#34;); } }; class Squre : public IDrawable { public: void draw() override { puts(\u0026#34;Squre::draw()\u0026#34;); } }; void render(IDrawable\u0026amp; drawable) { drawable.draw(); } ä½†æ˜¯æœ‰äº† Concept åï¼š\ntemplate \u0026lt;typename T\u0026gt; concept Drawable = requires(T t) { { t.draw() } -\u0026gt; std::same_as\u0026lt;void\u0026gt;; }; class Circle { public: void draw() const { puts(\u0026#34;Circle::draw()\u0026#34;); } }; class Squre { public: void draw() { puts(\u0026#34;Squre::draw()\u0026#34;); } }; template \u0026lt;Drawable T\u0026gt; void render(T\u0026amp; drawable) { drawable.","title":"ä½¿ç”¨ Concept æ›¿ä»£åŸºäºè™šå‡½æ•°çš„æ¥å£"},{"content":"æœ€è¿‘ Fedora42 æ›´æ–°äº†ï¼Œå› æ­¤æˆ‘æ‰“ç®—å‡çº§ä¸€ä¸‹ç©ç©ã€‚åœ¨æ‰§è¡Œå®Œä¸‹é¢çš„å‘½ä»¤åï¼š\nsudo dnf upgrade --refresh sudo dnf system-upgrade download --releasever=42 sudo dnf system-upgrade reboot é‡å¯å¼€æœºæˆäº†è¿™æ ·:(\nåœ¨ç½‘ä¸Šæœç´¢ä¸€åœˆåï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ç³»ç»Ÿå°± ok äº†ï¼š\nsudo dracut --regenerate-all --force é”™è¯¯çš„åŸå› å¯èƒ½æ˜¯æ›´æ–°å†…æ ¸åæ²¡æœ‰æ­£ç¡®ç”Ÿæˆæ–°çš„ initramfs æ–‡ä»¶ï¼Œç³»ç»Ÿå¯èƒ½ä¼šä½¿ç”¨æ—§çš„ã€ä¸å…¼å®¹çš„ initramfs æ–‡ä»¶ï¼Œä»è€Œå¯¼è‡´å¯åŠ¨å¤±è´¥ã€‚\nè€Œ dracut æ˜¯ä¸€ä¸ªç”¨äºç”Ÿæˆ Linux ç³»ç»Ÿ initramfsï¼ˆåˆå§‹å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼‰çš„å·¥å…·ã€‚è¿è¡Œ è¿™æ¡å‘½ä»¤åï¼Œdracut ä¼šé‡æ–°ç”Ÿæˆä¸å½“å‰ç³»ç»Ÿä¸­æ‰€æœ‰å·²å®‰è£…å†…æ ¸å¯¹åº”çš„ initramfs æ–‡ä»¶ã€‚\nå‚è€ƒï¼šhttps://www.reddit.com/r/Fedora/comments/1hfkqnq/boot_error_after_updating_to_6124200\n","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%A7%A3%E5%86%B3fedora42%E5%8D%87%E7%BA%A7%E5%90%AF%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BAkernel-panic/","summary":"æœ€è¿‘ Fedora42 æ›´æ–°äº†ï¼Œå› æ­¤æˆ‘æ‰“ç®—å‡çº§ä¸€ä¸‹ç©ç©ã€‚åœ¨æ‰§è¡Œå®Œä¸‹é¢çš„å‘½ä»¤åï¼š\nsudo dnf upgrade --refresh sudo dnf system-upgrade download --releasever=42 sudo dnf system-upgrade reboot é‡å¯å¼€æœºæˆäº†è¿™æ ·:(\nåœ¨ç½‘ä¸Šæœç´¢ä¸€åœˆåï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ç³»ç»Ÿå°± ok äº†ï¼š\nsudo dracut --regenerate-all --force é”™è¯¯çš„åŸå› å¯èƒ½æ˜¯æ›´æ–°å†…æ ¸åæ²¡æœ‰æ­£ç¡®ç”Ÿæˆæ–°çš„ initramfs æ–‡ä»¶ï¼Œç³»ç»Ÿå¯èƒ½ä¼šä½¿ç”¨æ—§çš„ã€ä¸å…¼å®¹çš„ initramfs æ–‡ä»¶ï¼Œä»è€Œå¯¼è‡´å¯åŠ¨å¤±è´¥ã€‚\nè€Œ dracut æ˜¯ä¸€ä¸ªç”¨äºç”Ÿæˆ Linux ç³»ç»Ÿ initramfsï¼ˆåˆå§‹å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼‰çš„å·¥å…·ã€‚è¿è¡Œ è¿™æ¡å‘½ä»¤åï¼Œdracut ä¼šé‡æ–°ç”Ÿæˆä¸å½“å‰ç³»ç»Ÿä¸­æ‰€æœ‰å·²å®‰è£…å†…æ ¸å¯¹åº”çš„ initramfs æ–‡ä»¶ã€‚\nå‚è€ƒï¼šhttps://www.reddit.com/r/Fedora/comments/1hfkqnq/boot_error_after_updating_to_6124200","title":"ã€è§£å†³ã€‘Fedora42å‡çº§å¯åŠ¨æ—¶æ˜¾ç¤ºkernel panic"},{"content":" https://leetcode.cn/problems/closest-equal-element-queries/\né€šè¿‡ç¤ºä¾‹1æ¥åˆ†æï¼š\nè¾“å…¥ï¼š nums = [1,3,1,4,1,3,2], queries = [0,3,5] è¾“å‡ºï¼š [2,-1,3] å¯¹äºqueries[0] = 0, nums[queries[0]] = 1æ¥è¯´ï¼Œå…¶åœ¨numsä¸­çš„ä¸‹æ ‡é›†åˆä¸ºp = [0, 2, 4]ï¼Œç”±äºnumsæ˜¯ä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼Œæ‰€ä»¥æŒ‰ç†æ¥è¯´æ•°ç»„pçš„ç¬¬ä¸€ä¸ªå…ƒç´ å¾€å·¦éœ€è¦èƒ½æ‰¾åˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ€åä¸€ä¸ªå…ƒç´ å¾€å³èƒ½æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚\nn ä¸º nums çš„é•¿åº¦ï¼Œ åœ¨ä¸‹æ ‡åˆ—è¡¨å‰é¢æ·»åŠ Â 4âˆ’n=âˆ’3ï¼Œç›¸å½“äºè®¤ä¸ºåœ¨Â âˆ’3Â ä¸‹æ ‡å¤„ä¹Ÿæœ‰ä¸€ä¸ªÂ 1ã€‚ åœ¨ä¸‹æ ‡åˆ—è¡¨æœ«å°¾æ·»åŠ Â 0+n=7ï¼Œç›¸å½“äºè®¤ä¸ºåœ¨Â 7Â ä¸‹æ ‡å¤„ä¹Ÿæœ‰ä¸€ä¸ªÂ 1ã€‚\né¢˜æ„æ˜¯éœ€è¦æˆ‘ä»¬æŸ¥è¯¢ä¸€ä¸ª nums ä¸­çš„ä¸‹æ ‡ xï¼Œä¸Â ä»»æ„Â å…¶ä»–ä¸‹æ ‡Â jï¼ˆæ»¡è¶³Â nums[j] == nums[x]ï¼‰ä¹‹é—´çš„Â æœ€å°Â è·ç¦»ã€‚æˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨å°†æ¯ä¸ªç›¸åŒå€¼çš„å…ƒç´ çš„ä¸‹æ ‡æ”¶é›†èµ·æ¥ä½œä¸ºé›†åˆ pï¼Œç„¶ååœ¨æŸ¥è¯¢æ—¶ä½¿ç”¨äºŒåˆ†æŸ¥è¯¢ x åœ¨å…¶å¯¹åº”é›†åˆä¸­çš„ä½ç½® iï¼Œåˆ™å·¦è¾¹æœ€è¿‘çš„å…ƒç´ ä¸‹æ ‡ä¸º p[i - 1]ï¼Œå³è¾¹æœ€è¿‘å…ƒç´ ä¸‹æ ‡ä¸º p[i + 1]ï¼Œé‚£ä¹ˆæœ€å°è·ç¦»å°±æ˜¯ min(p[i + 1] - x, x - p[i - 1])ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; solveQueries(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; queries) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; m; int n = nums.size(); // å°†æ¯ä¸ªç›¸åŒå€¼çš„å…ƒç´ çš„ä¸‹æ ‡æ”¶é›†èµ·æ¥ for (int i = 0; i \u0026lt; nums.size(); ++i) { m[nums[i]].push_back(i); } // å¢åŠ å·¦å³ä¸¤ä¸ªå“¨å…µ for (auto\u0026amp; [_, p] : m) { int t = p[0]; p.insert(p.begin(), p.back() - n); p.push_back(n + t); } for (int\u0026amp; x : queries) { auto\u0026amp; p = m[nums[x]]; if (p.size() == 3) { // ç”±äºæ·»åŠ äº†ä¸¤ä¸ªå“¨å…µï¼Œæ‰€ä»¥å½“é›†åˆé•¿åº¦ä¸º 3 æ—¶è¯´æ˜é›†åˆä¸­å®é™…åªæœ‰1ä¸ªå…ƒç´ ï¼Œå³è¿™ä¸ªå…ƒç´ åœ¨ nums ä¸­æ˜¯å”¯ä¸€çš„ x = -1; } else { int i = ranges::lower_bound(p, x) - p.begin(); x = min(p[i + 1] - x, x - p[i - 1]); } } return queries; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/3488.-%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2/","summary":"https://leetcode.cn/problems/closest-equal-element-queries/\né€šè¿‡ç¤ºä¾‹1æ¥åˆ†æï¼š\nè¾“å…¥ï¼š nums = [1,3,1,4,1,3,2], queries = [0,3,5] è¾“å‡ºï¼š [2,-1,3] å¯¹äºqueries[0] = 0, nums[queries[0]] = 1æ¥è¯´ï¼Œå…¶åœ¨numsä¸­çš„ä¸‹æ ‡é›†åˆä¸ºp = [0, 2, 4]ï¼Œç”±äºnumsæ˜¯ä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼Œæ‰€ä»¥æŒ‰ç†æ¥è¯´æ•°ç»„pçš„ç¬¬ä¸€ä¸ªå…ƒç´ å¾€å·¦éœ€è¦èƒ½æ‰¾åˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ€åä¸€ä¸ªå…ƒç´ å¾€å³èƒ½æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚\nn ä¸º nums çš„é•¿åº¦ï¼Œ åœ¨ä¸‹æ ‡åˆ—è¡¨å‰é¢æ·»åŠ Â 4âˆ’n=âˆ’3ï¼Œç›¸å½“äºè®¤ä¸ºåœ¨Â âˆ’3Â ä¸‹æ ‡å¤„ä¹Ÿæœ‰ä¸€ä¸ªÂ 1ã€‚ åœ¨ä¸‹æ ‡åˆ—è¡¨æœ«å°¾æ·»åŠ Â 0+n=7ï¼Œç›¸å½“äºè®¤ä¸ºåœ¨Â 7Â ä¸‹æ ‡å¤„ä¹Ÿæœ‰ä¸€ä¸ªÂ 1ã€‚\né¢˜æ„æ˜¯éœ€è¦æˆ‘ä»¬æŸ¥è¯¢ä¸€ä¸ª nums ä¸­çš„ä¸‹æ ‡ xï¼Œä¸Â ä»»æ„Â å…¶ä»–ä¸‹æ ‡Â jï¼ˆæ»¡è¶³Â nums[j] == nums[x]ï¼‰ä¹‹é—´çš„Â æœ€å°Â è·ç¦»ã€‚æˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨å°†æ¯ä¸ªç›¸åŒå€¼çš„å…ƒç´ çš„ä¸‹æ ‡æ”¶é›†èµ·æ¥ä½œä¸ºé›†åˆ pï¼Œç„¶ååœ¨æŸ¥è¯¢æ—¶ä½¿ç”¨äºŒåˆ†æŸ¥è¯¢ x åœ¨å…¶å¯¹åº”é›†åˆä¸­çš„ä½ç½® iï¼Œåˆ™å·¦è¾¹æœ€è¿‘çš„å…ƒç´ ä¸‹æ ‡ä¸º p[i - 1]ï¼Œå³è¾¹æœ€è¿‘å…ƒç´ ä¸‹æ ‡ä¸º p[i + 1]ï¼Œé‚£ä¹ˆæœ€å°è·ç¦»å°±æ˜¯ min(p[i + 1] - x, x - p[i - 1])ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; solveQueries(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; queries) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; m; int n = nums.","title":"3488. è·ç¦»æœ€å°ç›¸ç­‰å…ƒç´ æŸ¥è¯¢"},{"content":"åœ¨C++ä¸­ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®ç±»çš„å®šä¹‰æƒ…å†µè‡ªåŠ¨å†³å®šæ˜¯å¦ç”Ÿæˆé»˜è®¤çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼ˆå¦‚æ„é€ å‡½æ•°ã€æ‹·è´/ç§»åŠ¨æ“ä½œã€ææ„å‡½æ•°ï¼‰ã€‚\n1. ç”¨æˆ·æ˜¾å¼å£°æ˜ç›¸å…³æˆå‘˜å‡½æ•° æ˜¾å¼å£°æ˜æˆ–åˆ é™¤æŸä¸ªå‡½æ•°ï¼š\nå¦‚æœç”¨æˆ·æ˜¾å¼å£°æ˜ï¼ˆå³ä½¿ä½¿ç”¨ =default æˆ– =deleteï¼‰æŸä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œç¼–è¯‘å™¨å°†ä¸å†ç”Ÿæˆé»˜è®¤ç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼š\nclass Example { public: Example() = default; // å…è®¸ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•° Example(const Example\u0026amp;) {} // ç”¨æˆ·å®šä¹‰çš„æ‹·è´æ„é€ å‡½æ•° // ç¼–è¯‘å™¨ä¸å†ç”Ÿæˆé»˜è®¤çš„ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ }; 2. ç”¨æˆ·å®šä¹‰ææ„å‡½æ•°ã€æ‹·è´/ç§»åŠ¨æ“ä½œçš„å½±å“ å®šä¹‰ææ„å‡½æ•°ï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†ææ„å‡½æ•°ï¼ˆå³ä½¿ä¸ºç©ºï¼‰ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„ç§»åŠ¨æ“ä½œï¼ˆç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ï¼‰ï¼Œä½†æ‹·è´æ“ä½œä»å¯èƒ½ç”Ÿæˆï¼ˆé™¤éå…¶ä»–æ¡ä»¶é˜»æ­¢ï¼‰ã€‚\nclass Example { public: ~Example() {} // ç”¨æˆ·å®šä¹‰çš„ææ„å‡½æ•° // ç§»åŠ¨æ“ä½œè¢«éšå¼åˆ é™¤ï¼Œæ‹·è´æ“ä½œå¯èƒ½ç”Ÿæˆï¼ˆè‹¥æ— å…¶ä»–é™åˆ¶ï¼‰ }; å®šä¹‰æ‹·è´æ“ä½œï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†æ‹·è´æ„é€ å‡½æ•°æˆ–æ‹·è´èµ‹å€¼è¿ç®—ç¬¦ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„ç§»åŠ¨æ“ä½œã€‚\nclass Example { public: Example(const Example\u0026amp;) {} // ç”¨æˆ·å®šä¹‰çš„æ‹·è´æ„é€ å‡½æ•° // ç§»åŠ¨æ“ä½œè¢«éšå¼åˆ é™¤ }; å®šä¹‰ç§»åŠ¨æ“ä½œï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†ç§»åŠ¨æ„é€ å‡½æ•°æˆ–ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„æ‹·è´æ“ä½œã€‚\n#include \u0026lt;utility\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; struct Example { std::string str; Example() = default; Example(const std::string\u0026amp; s): str(s) { std::cout \u0026lt;\u0026lt; \u0026#34;Example()\\n\u0026#34;; } Example(Example\u0026amp;\u0026amp; other) { str = std::move(other.str); std::cout \u0026lt;\u0026lt; \u0026#34;Example(Example\u0026amp;\u0026amp;)\\n\u0026#34;; } Example\u0026amp; operator=(Example\u0026amp;\u0026amp; other) { str = std::move(other.str); std::cout \u0026lt;\u0026lt; \u0026#34;operator=(Example\u0026amp;\u0026amp;)\\n\u0026#34;; return *this; } }; int main() { Example x1(\u0026#34;Hello\u0026#34;); Example x2 = std::move(x1); Example x3; x3 = std::move(x2); } æ‰§è¡Œç»“æœä¸ºï¼š\nExample() Example(Example\u0026amp;\u0026amp;) operator=(Example\u0026amp;\u0026amp;) 3. ç±»æˆå‘˜æˆ–åŸºç±»çš„é™åˆ¶ ä¸å¯é»˜è®¤æ„é€ /æ‹·è´/ç§»åŠ¨çš„æˆå‘˜ï¼š\nå¦‚æœç±»ä¸­åŒ…å«æ— æ³•é»˜è®¤æ„é€ ã€æ‹·è´æˆ–ç§»åŠ¨çš„æˆå‘˜ï¼ˆå¦‚ std::unique_ptrã€å¸¦æœ‰åˆ é™¤æ‹·è´æ“ä½œçš„ç±»ï¼‰ï¼Œåˆ™å¯¹åº”çš„é»˜è®¤ç‰¹æ®Šæˆå‘˜å‡½æ•°ä¼šè¢«éšå¼åˆ é™¤ã€‚\nclass Example { std::unique_ptr\u0026lt;int\u0026gt; ptr; // ä¸å¯æ‹·è´ }; // é»˜è®¤çš„æ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦è¢«åˆ é™¤ åŸºç±»æˆ–æˆå‘˜çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°è¢«åˆ é™¤ï¼š\nå¦‚æœåŸºç±»æˆ–æˆå‘˜çš„æŸä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°è¢«åˆ é™¤æˆ–ä¸å¯è®¿é—®ï¼Œæ´¾ç”Ÿç±»å¯¹åº”çš„å‡½æ•°ä¹Ÿä¼šè¢«éšå¼åˆ é™¤ã€‚\nclass NonCopyable { public: NonCopyable(const NonCopyable\u0026amp;) = delete; }; class Derived : public NonCopyable { // æ‹·è´æ„é€ å‡½æ•°è¢«éšå¼åˆ é™¤ï¼Œå› ä¸ºåŸºç±»çš„æ‹·è´æ„é€ å‡½æ•°è¢«åˆ é™¤ }; ","permalink":"https://kerolt.github.io/posts/c++/c++%E4%BD%95%E6%97%B6%E4%BC%9A%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/","summary":"åœ¨C++ä¸­ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®ç±»çš„å®šä¹‰æƒ…å†µè‡ªåŠ¨å†³å®šæ˜¯å¦ç”Ÿæˆé»˜è®¤çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼ˆå¦‚æ„é€ å‡½æ•°ã€æ‹·è´/ç§»åŠ¨æ“ä½œã€ææ„å‡½æ•°ï¼‰ã€‚\n1. ç”¨æˆ·æ˜¾å¼å£°æ˜ç›¸å…³æˆå‘˜å‡½æ•° æ˜¾å¼å£°æ˜æˆ–åˆ é™¤æŸä¸ªå‡½æ•°ï¼š\nå¦‚æœç”¨æˆ·æ˜¾å¼å£°æ˜ï¼ˆå³ä½¿ä½¿ç”¨ =default æˆ– =deleteï¼‰æŸä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œç¼–è¯‘å™¨å°†ä¸å†ç”Ÿæˆé»˜è®¤ç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼š\nclass Example { public: Example() = default; // å…è®¸ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•° Example(const Example\u0026amp;) {} // ç”¨æˆ·å®šä¹‰çš„æ‹·è´æ„é€ å‡½æ•° // ç¼–è¯‘å™¨ä¸å†ç”Ÿæˆé»˜è®¤çš„ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ }; 2. ç”¨æˆ·å®šä¹‰ææ„å‡½æ•°ã€æ‹·è´/ç§»åŠ¨æ“ä½œçš„å½±å“ å®šä¹‰ææ„å‡½æ•°ï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†ææ„å‡½æ•°ï¼ˆå³ä½¿ä¸ºç©ºï¼‰ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„ç§»åŠ¨æ“ä½œï¼ˆç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ï¼‰ï¼Œä½†æ‹·è´æ“ä½œä»å¯èƒ½ç”Ÿæˆï¼ˆé™¤éå…¶ä»–æ¡ä»¶é˜»æ­¢ï¼‰ã€‚\nclass Example { public: ~Example() {} // ç”¨æˆ·å®šä¹‰çš„ææ„å‡½æ•° // ç§»åŠ¨æ“ä½œè¢«éšå¼åˆ é™¤ï¼Œæ‹·è´æ“ä½œå¯èƒ½ç”Ÿæˆï¼ˆè‹¥æ— å…¶ä»–é™åˆ¶ï¼‰ }; å®šä¹‰æ‹·è´æ“ä½œï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†æ‹·è´æ„é€ å‡½æ•°æˆ–æ‹·è´èµ‹å€¼è¿ç®—ç¬¦ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„ç§»åŠ¨æ“ä½œã€‚\nclass Example { public: Example(const Example\u0026amp;) {} // ç”¨æˆ·å®šä¹‰çš„æ‹·è´æ„é€ å‡½æ•° // ç§»åŠ¨æ“ä½œè¢«éšå¼åˆ é™¤ }; å®šä¹‰ç§»åŠ¨æ“ä½œï¼š\nå¦‚æœç”¨æˆ·å®šä¹‰äº†ç§»åŠ¨æ„é€ å‡½æ•°æˆ–ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ï¼Œç¼–è¯‘å™¨ä¼šåˆ é™¤é»˜è®¤çš„æ‹·è´æ“ä½œã€‚\n#include \u0026lt;utility\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; struct Example { std::string str; Example() = default; Example(const std::string\u0026amp; s): str(s) { std::cout \u0026lt;\u0026lt; \u0026#34;Example()\\n\u0026#34;; } Example(Example\u0026amp;\u0026amp; other) { str = std::move(other.","title":"C++ä½•æ—¶ä¼šé˜»æ­¢é»˜è®¤çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°çš„ç”Ÿæˆ"},{"content":" è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™ Lab æ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨ Github å’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nè¿™ä¸ª project å’Œä¹‹å‰å°±ä¸ä¸€æ ·äº†ï¼Œå¼€å§‹æ·±å…¥æ•°æ®åº“å†…æ ¸çš„å®ç°äº†ã€‚éœ€è¦ç†æ¸…æ¥šä¸€æ¡ sql è¯­å¥æ˜¯å¦‚ä½•è¢«æ‰§è¡Œçš„ï¼Œæ–¹æ‰èƒ½å†™å‡ºä»£ç ã€‚\nå‰ç½®å¥¶é…ª ä¸€æ¡ SQL è¯­å¥çš„æ‰§è¡Œ è¿™é‡Œéœ€è¦å»çœ‹çœ‹ä¸€æ¡ sql è¯­å¥ä¼ å…¥ bustub å†…éƒ¨ä¹‹åçš„ä»£ç ï¼šsrc/common/bustub_instance.cpp:ExecuteSqlTxnï¼š\nauto BustubInstance::ExecuteSqlTxn(const std::string \u0026amp;sql, ResultWriter \u0026amp;writer, Transaction *txn, std::shared_ptr\u0026lt;CheckOptions\u0026gt; check_options) -\u0026gt; bool { if (!sql.empty() \u0026amp;\u0026amp; sql[0] == \u0026#39;\\\\\u0026#39;) { // å¤„ç†å…ƒå‘½ä»¤ ... } // binderï¼Œä½†æ˜¯åœ¨å…¶ä¸­ä¼šä½¿ç”¨libpg_queryæ¥è§£æsqlè¯­å¥ bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // ç»è¿‡ä¸Šä¸€æ­¥åï¼Œbinderä¸­çš„statement_nodes_å­˜å‚¨ç€æ‰€æœ‰çš„è¯­å¥è§£æèŠ‚ç‚¹ for (auto *stmt : binder.statement_nodes_) { // å°†stmtè½¬æ¢æˆBoundStatementå¯¹è±¡ï¼Œæ–¹ä¾¿åé¢å¤„ç†æ•°æ® auto statement = binder.BindStatement(stmt); // åªæœ‰ä¸éœ€è¦æ„å»ºplanæ ‘ã€ä¸éœ€è¦è¿›è¡Œä¼˜åŒ–çš„sqlè¯­å¥æ‰ä¼šåœ¨switchä¹‹åç»§ç»­æ‰§è¡Œ switch (statement-\u0026gt;type_) { ... } // ç”Ÿæˆåˆæ­¥çš„æ‰§è¡Œè®¡åˆ’ bustub::Planner planner(*catalog_); planner.PlanQuery(*statement); // ä¼˜åŒ–åˆšåˆšçš„æ‰§è¡Œè®¡åˆ’ bustub::Optimizer optimizer(*catalog_, IsForceStarterRule()); auto optimized_plan = optimizer.Optimize(planner.plan_); ... // æ‰§è¡Œä¼˜åŒ–åçš„planï¼Œè¿™é‡Œä¼šä½¿ç”¨ç«å±±æ¨¡å‹å»æ ¹æ®ä¸‹é¢èŠ‚ç‚¹çš„Nextå‡½æ•°æ¥æ‰§è¡Œç›¸åº”çš„ç®—å­ execution_engine_-\u0026gt;Execute(optimized_plan, \u0026amp;result_set, txn, exec_ctx.get()); // å°†æ‰§è¡Œç»“æœè¾“å‡ºè‡³æŒ‡å®šä½ç½® ... } return æ˜¯å¦æ‰§è¡ŒæˆåŠŸ;\t} åœ¨ binder ä¹‹åï¼Œæˆ‘ä»¬å°±æœ‰äº†ä¸€æ¡ sql çš„è¯­å¥è§£æèŠ‚ç‚¹ï¼Œä¾‹å¦‚æ‰§è¡Œ select * from (select * from test_2 where colA \u0026gt; 10) where colB \u0026gt; 2;ï¼Œå…¶ statement node å¦‚ä¸‹ï¼š\nBoundSelect { table=BoundSubqueryRef { alias=__subquery#0, subquery=BoundSelect { table=BoundBaseTableRef { table=test_2, oid=23 }, columns=[\u0026#34;test_2.colA\u0026#34;, \u0026#34;test_2.colB\u0026#34;, \u0026#34;test_2.colC\u0026#34;], groupBy=[], having=, where=(test_2.colA\u0026gt;10), limit=, offset=, order_by=[], is_distinct=false, ctes=, }, columns=[\u0026#34;test_2.colA\u0026#34;, \u0026#34;test_2.colB\u0026#34;, \u0026#34;test_2.colC\u0026#34;], }, columns=[\u0026#34;__subquery#0.test_2.colA\u0026#34;, \u0026#34;__subquery#0.test_2.colB\u0026#34;, \u0026#34;__subquery#0.test_2.colC\u0026#34;], groupBy=[], having=, where=(__subquery#0.test_2.colB\u0026gt;2), limit=, offset=, order_by=[], is_distinct=false, ctes=, } å…¶ä¸­çš„å­æŸ¥è¯¢å’Œ where çš„æ¡ä»¶è¿˜æœ‰éœ€è¦å“ªäº›åˆ—éƒ½èƒ½éå¸¸æ¸…æ¥šçš„çœ‹åˆ°ã€‚\nIterator Model é€šå¸¸ä¸€ä¸ª SQL ä¼šè¢«ç»„ç»‡æˆæ ‘çŠ¶çš„æŸ¥è¯¢è®¡åˆ’ï¼Œæ•°æ®ä»å¶å­èŠ‚ç‚¹æµåˆ°æ ¹èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢ç»“æœåœ¨æ ¹èŠ‚ç‚¹ä¸­å¾—å‡ºã€‚\nbustub ä¸­é‡‡ç”¨çš„æ•°æ®åº“æŸ¥è¯¢æ‰§è¡Œæ¨¡å‹å«åšè¿­ä»£å™¨æ¨¡å‹ï¼Œä¹Ÿå«ç«å±±æ¨¡å‹ã€‚\næŸ¥è¯¢è®¡åˆ’ï¼ˆquery planï¼‰ä¸­çš„æ¯æ­¥ operator å¯¹åº”çš„ executor éƒ½å®ç°ä¸€ä¸ª next å‡½æ•°ï¼Œæ¯æ¬¡è°ƒç”¨æ—¶ï¼Œoperator è¿”å›ä¸€ä¸ª tuple æˆ–è€… nullï¼Œåè€…è¡¨ç¤ºæ•°æ®å·²ç»éå†å®Œæ¯•ã€‚operator æœ¬èº«å®ç°ä¸€ä¸ªå¾ªç¯ï¼Œæ¯æ¬¡è°ƒç”¨å…¶ child operators çš„ next å‡½æ•°ï¼Œä»å®ƒä»¬é‚£è¾¹è·å–ä¸‹ä¸€æ¡æ•°æ®ä¾›è‡ªå·±æ“ä½œï¼Œè¿™æ ·æ•´ä¸ª query plan å°±è¢«ä»ä¸Šè‡³ä¸‹åœ°ä¸²è”èµ·æ¥ã€‚\nä½†æ˜¯åƒ Joins, Aggregates, Subqueries, Order By è¿™æ ·çš„æ“ä½œéœ€è¦ç­‰æ‰€æœ‰ children è¿”å›å®ƒä»¬çš„ tupleã€‚è™½ç„¶ä¸€æ¬¡è°ƒç”¨è¯·æ±‚ä¸€æ¡æ•°æ®ï¼Œå ç”¨å†…å­˜è¾ƒå°ï¼Œä½†å‡½æ•°è°ƒç”¨å¼€é”€å¤§ã€‚\nCatalog, Table and Index ä¸‹å›¾å‡ºå¤„ï¼šhttps://www.cnblogs.com/joey-wang/p/17351258.html\nç´¢å¼• index åœ¨ Bustub ä¸­ï¼Œç´¢å¼•ç”¨äºåŠ é€Ÿæ•°æ®è®¿é—®ã€‚ç´¢å¼•é€šè¿‡ç»´æŠ¤è¡¨ä¸­æ•°æ®çš„æœ‰åºç»“æ„ï¼Œä½¿å¾—æŸ¥è¯¢å¯ä»¥æ›´å¿«åœ°å®šä½åˆ°æ‰€éœ€çš„è®°å½•ã€‚\nç»“æ„ ç´¢å¼•çš„ç»“æ„å›¾å’Œä¸Šé¢è¡¨çš„ç»“æ„å›¾ç±»ä¼¼ã€‚åœ¨ catalog ä¸­ï¼Œå¯ä»¥è·å–åˆ°ä¸€ä¸ªè¡¨å¯¹åº”çš„æ‰€æœ‰IndexInfoï¼Œæ¯ä¸ª IndexInfo ä¸­åŒ…å«ç€è¿™ä¸ªç´¢å¼•çš„ä¿¡æ¯ï¼Œè¿™é‡Œè®²ä¸¤ä¸ªä¸ªæˆ‘è®¤ä¸ºæ¯”è¾ƒé‡è¦çš„æˆå‘˜å˜é‡ï¼š\nkey_schema_ï¼šç´¢å¼•å¯¹åº”çš„åˆ—çš„ç»“æ„ï¼Œä¾‹å¦‚ä½¿ç”¨å…¶ ToString() å‡½æ•°æ—¶ï¼Œå…¶ä¼šè¿”å› (æ·»åŠ äº†ç´¢å¼•çš„åˆ—çš„åç§°:è¯¥åˆ—çš„æ•°æ®ç±»å‹) index_ï¼šè¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ª Index ç±»çš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯çœŸæ­£çš„ç´¢å¼• // catalog.h class Catalog { public: template \u0026lt;class KeyType, class ValueType, class KeyComparator\u0026gt; auto CreateIndex(Transaction *txn, const std::string \u0026amp;index_name, const std::string \u0026amp;table_name, const Schema \u0026amp;schema, const Schema \u0026amp;key_schema, const std::vector\u0026lt;uint32_t\u0026gt; \u0026amp;key_attrs, std::size_t keysize, HashFunction\u0026lt;KeyType\u0026gt; hash_function, bool is_primary_key = false, IndexType index_type = IndexType::HashTableIndex) -\u0026gt; IndexInfo *; auto GetIndex(const std::string \u0026amp;index_name, const std::string \u0026amp;table_name) -\u0026gt; IndexInfo *; auto GetIndex(const std::string \u0026amp;index_name, const table_oid_t table_oid) -\u0026gt; IndexInfo *; auto GetIndex(index_oid_t index_oid) -\u0026gt; IndexInfo *; auto GetTableIndexes(const std::string \u0026amp;table_name) const -\u0026gt; std::vector\u0026lt;IndexInfo *\u0026gt;; ... private: ... /** * Map index identifier -\u0026gt; index metadata. * * NOTE: that `indexes_` owns all index metadata. */ std::unordered_map\u0026lt;index_oid_t, std::unique_ptr\u0026lt;IndexInfo\u0026gt;\u0026gt; indexes_; /** Map table name -\u0026gt; index names -\u0026gt; index identifiers. */ std::unordered_map\u0026lt;std::string, std::unordered_map\u0026lt;std::string, index_oid_t\u0026gt;\u0026gt; index_names_; /** The next index identifier to be used. */ std::atomic\u0026lt;index_oid_t\u0026gt; next_index_oid_{0}; }; struct IndexInfo { ... /** The schema for the index key */ Schema key_schema_; /** The name of the index */ std::string name_; /** An owning pointer to the index */ std::unique_ptr\u0026lt;Index\u0026gt; index_; /** The unique OID for the index */ index_oid_t index_oid_; /** The name of the table on which the index is created */ std::string table_name_; /** The size of the index key, in bytes */ const size_t key_size_; /** Is primary key index? */ bool is_primary_key_; /** The index type */ [[maybe_unused]] IndexType index_type_{IndexType::BPlusTreeIndex}; }; Index ä¸­æœ‰ç€ä¸‰ä¸ªè™šå‡½æ•°ä¾›å…¶æ´¾ç”Ÿç±»å»å®ç°ï¼Œå…¶å”¯ä¸€çš„æˆå‘˜å˜é‡çš„ç±»å‹ä¸º IndexMetaï¼Œç”¨æ¥å­˜å‚¨ä¸€äº›å…ƒä¿¡æ¯ï¼Œä¾‹å¦‚è¿™ä¸ªç´¢å¼•çš„åç§°ï¼Œå®ƒæ‰€å±çš„è¡¨çš„åç§°ï¼Œæœ€é‡è¦çš„è¿˜æœ‰ä¸€ä¸ª key_attrs_ï¼Œç¨åå°±è¯´è°ˆè®ºå®ƒã€‚\n// index.h class IndexMeta { ... private: /** The name of the index */ std::string name_; /** The name of the table on which the index is created */ std::string table_name_; /** The mapping relation between key schema and tuple schema */ const std::vector\u0026lt;uint32_t\u0026gt; key_attrs_; /** The schema of the indexed key */ std::shared_ptr\u0026lt;Schema\u0026gt; key_schema_; /** Is primary key? */ bool is_primary_key_; }; class Index { ... private: /** The Index structure owns its metadata */ std::unique_ptr\u0026lt;IndexMetadata\u0026gt; metadata_; }; fall2023 æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯å“ˆå¸Œç´¢å¼•ï¼Œåº•å±‚ä½¿ç”¨çš„å°±æ˜¯åœ¨ project2 ä¸­å®ç°çš„å¯æ‹“å±•å“ˆå¸Œã€‚\n// extendible_hash_table_index.h #define HASH_TABLE_INDEX_TYPE ExtendibleHashTableIndex\u0026lt;KeyType, ValueType, KeyComparator\u0026gt; template \u0026lt;typename KeyType, typename ValueType, typename KeyComparator\u0026gt; class ExtendibleHashTableIndex : public Index { public: ExtendibleHashTableIndex(std::unique_ptr\u0026lt;IndexMetadata\u0026gt; \u0026amp;\u0026amp;metadata, BufferPoolManager *buffer_pool_manager, const HashFunction\u0026lt;KeyType\u0026gt; \u0026amp;hash_fn); ~ExtendibleHashTableIndex() override = default; auto InsertEntry(const Tuple \u0026amp;key, RID rid, Transaction *transaction) -\u0026gt; bool override; void DeleteEntry(const Tuple \u0026amp;key, RID rid, Transaction *transaction) override; void ScanKey(const Tuple \u0026amp;key, std::vector\u0026lt;RID\u0026gt; *result, Transaction *transaction) override; protected: // comparator for key KeyComparator comparator_; // container DiskExtendibleHashTable\u0026lt;KeyType, ValueType, KeyComparator\u0026gt; container_; }; æ›´æ–°ç´¢å¼• å½“æ’å…¥æ–°è®°å½•æ—¶ï¼Œä¸ä»…éœ€è¦å°†è®°å½•æ’å…¥åˆ°è¡¨ä¸­ï¼Œè¿˜éœ€è¦å°†ç›¸åº”çš„ç´¢å¼•æ¡ç›®æ’å…¥åˆ°ç´¢å¼•ä¸­ã€‚è¿™æ ·ï¼Œåç»­çš„æŸ¥è¯¢æ“ä½œå¯ä»¥åˆ©ç”¨ç´¢å¼•å¿«é€Ÿå®šä½åˆ°ç›®æ ‡è®°å½•ã€‚å¦‚æœä¸æ›´æ–°ç´¢å¼•ï¼Œåç»­çš„æŸ¥è¯¢æ“ä½œå¯èƒ½ä¼šé”™è¿‡æ–°æ’å…¥çš„è®°å½•ï¼Œå¯¼è‡´æŸ¥è¯¢ç»“æœä¸å‡†ç¡®ã€‚\nbustub ä¸­æœ‰å“ˆå¸Œç´¢å¼•å’Œ B+Tree ç´¢å¼•ï¼Œfall2023 ç‰ˆæœ¬ä½¿ç”¨çš„æ˜¯å¯æ‹“å±•å“ˆå¸Œä½œä¸ºä½œä¸ºç´¢å¼•ã€‚ä¸è¿‡è¿™ä¸¤ä¸ªå…·ä½“çš„å®ç°éƒ½æœ‰ä¸€ä¸ªåŸºç±» Indexï¼Œå…¶ä¸­æœ‰ä»¥ä¸‹è™šå‡½æ•°éœ€è¦å­ç±»å»å®ç°ï¼š\nInsertEntry(const Tuple \u0026amp;key, RID rid, Transaction *transaction): æ’å…¥ä¸€ä¸ªç´¢å¼•æ¡ç›®ã€‚ DeleteEntry(const Tuple \u0026amp;key, RID rid, Transaction *transaction): åˆ é™¤ä¸€ä¸ªç´¢å¼•æ¡ç›®ã€‚ ScanKey(const Tuple \u0026amp;key, std::vector\u0026lt;RID\u0026gt; *result, Transaction *transaction): æ ¹æ®ç´¢å¼•é”®æœç´¢è®°å½•ï¼Œå¹¶å°†ç»“æœ RID å­˜å‚¨åœ¨æŒ‡å®šçš„å‘é‡ä¸­ã€‚ æ‰€ä»¥ä¸ç®¡ç”¨çš„æ˜¯å“ˆå¸Œè¿˜æ˜¯ B+Treeï¼Œåœ¨æ“ä½œç´¢å¼•æ—¶ç”¨çš„æ¥å£éƒ½ç›¸åŒã€‚\nå¦‚ä½•ç†è§£ç´¢å¼• å°±å¦‚ç½‘ä¸Šå¾ˆå¤šä»‹ç»ç´¢å¼•çš„åšå®¢æ‰€æè¿°çš„é‚£æ ·ï¼Œæ•°æ®åº“ç´¢å¼•æ˜¯ç”¨æ¥åŠ é€Ÿæ£€ç´¢é€Ÿåº¦çš„ï¼Œå°±å¦‚åŒæ–°åå­—å…¸ä¸­çš„éŸ³èŠ‚ç´¢å¼•ä¸€æ ·ï¼š\nå¦‚åŒ table_infoï¼Œcatalog ä¸­ä¹Ÿæœ‰è®¸å¤šçš„ index_infoï¼Œæ¯ä¸ª index_info å°±å¦‚åŒä¸Šå›¾éŸ³èŠ‚è¡¨ä¸­çš„ä¸€ä¸ªå­—æ¯ã€‚æˆ‘ä»¬å¯¹ä¸€ä¸ªå­—æ®µï¼ˆåˆ—ï¼‰æ„å»ºä¸€ä¸ªç´¢å¼•ï¼Œå°±å¦‚åŒåœ¨ä¸Šå›¾ä¸­éŸ³èŠ‚è¡¨ä¸­å¤šåŠ ä¸€ä¸ªå­—æ¯ï¼ˆä¾‹å¦‚ Xï¼‰ã€‚\néœ€è¦æ’å…¥ä¸€æ¡è®°å½•æ—¶ï¼Œå°±å¾€å¯¹åº”çš„ç´¢å¼•ä¸‹æ’å…¥ (è®°å½•ï¼Œ å¯¹åº”è®°å½•çš„åœ°å€) è¿™æ ·çš„é”®å€¼å¯¹ï¼Œä¾‹å¦‚ä¸Šå›¾çš„ (xian, 519)ï¼Œè¿™é‡Œçš„åœ°å€ä¸º RIDã€‚ éœ€è¦åˆ é™¤ä¸€æ¡è®°å½•æ—¶ï¼Œåœ¨å¯¹åº”çš„ç´¢å¼•ä¸‹åˆ æ‰åŒ¹é…çš„é”®å€¼å¯¹ã€‚ éœ€è¦æ›´æ–°ä¸€æ¡è®°å½•æ—¶ï¼Œç”±äº bustub æ²¡æœ‰æä¾›æ›´æ–°ç´¢å¼•çš„ APIï¼Œæ‰€ä»¥å¯ä»¥ç”¨å…ˆåˆ é™¤å†æ’å…¥çš„æ–¹å¼æ¨¡æ‹Ÿæ›´æ–°ã€‚ æ‰§è¡Œå™¨å¦‚ä½•ä½¿ç”¨ç´¢å¼•è·å–æ•°æ® å½“æ‰§è¡Œå™¨éœ€è¦ä»è¡¨ä¸­è·å–æ•°æ®æ—¶ï¼Œå¦‚æœæŸ¥è¯¢è®¡åˆ’ä¸­åŒ…å«ç´¢å¼•æ‰«ææ“ä½œï¼Œæ‰§è¡Œå™¨ä¼šé€šè¿‡ç´¢å¼•æ¥å¿«é€Ÿå®šä½æ•°æ®ã€‚ä»¥ä¸‹æ˜¯å…·ä½“çš„æ­¥éª¤ï¼š\nè§£ææŸ¥è¯¢è®¡åˆ’ï¼š æ‰§è¡Œå™¨æ ¹æ®æŸ¥è¯¢è®¡åˆ’ç¡®å®šéœ€è¦ä½¿ç”¨çš„ç´¢å¼•ã€‚ è·å–ç´¢å¼•çš„å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬ç´¢å¼•é”®çš„æ¨¡å¼å’Œè¡¨åˆ—çš„æ˜ å°„å…³ç³»ã€‚ æ„å»ºç´¢å¼•é”®ï¼š æ ¹æ®æŸ¥è¯¢æ¡ä»¶å’Œç´¢å¼•çš„å…ƒæ•°æ®ï¼Œæ„å»ºç´¢å¼•é”®ã€‚è¿™é€šå¸¸æ¶‰åŠåˆ°ä»æŸ¥è¯¢æ¡ä»¶ä¸­æå–åˆ—å€¼ï¼Œå¹¶æ ¹æ®ç´¢å¼•é”®çš„æ¨¡å¼è¿›è¡Œè½¬æ¢ã€‚ ä½¿ç”¨ç´¢å¼•è¿›è¡Œæœç´¢ï¼š è°ƒç”¨ç´¢å¼•çš„Â ScanKeyÂ æ–¹æ³•ï¼Œä¼ å…¥æ„å»ºå¥½çš„ç´¢å¼•é”®å’Œä¸€ä¸ªç»“æœ RID å‘é‡ã€‚ ç´¢å¼•ä¼šæ ¹æ®é”®å€¼æŸ¥æ‰¾å¯¹åº”çš„è®°å½•ï¼Œå¹¶å°†æ‰¾åˆ°çš„ RID å­˜å‚¨åœ¨ç»“æœå‘é‡ä¸­ã€‚ è¯»å–æ•°æ®é¡µï¼š ä½¿ç”¨ç»“æœå‘é‡ä¸­çš„ RIDï¼Œä»ç¼“å†²æ± ä¸­æŸ¥æ‰¾å¯¹åº”çš„é¡µã€‚å¦‚æœé¡µä¸åœ¨ç¼“å†²æ± ä¸­ï¼Œåˆ™ä»ç£ç›˜åŠ è½½åˆ°ç¼“å†²æ± ã€‚ ä»é¡µä¸­è¯»å–æ•°æ®å¹¶åˆ›å»ºÂ TupleÂ å¯¹è±¡ã€‚ å¤„ç†å’Œè¿”å›ç»“æœï¼š ä½¿ç”¨Â TupleÂ å¯¹è±¡çš„æ–¹æ³•ï¼ˆå¦‚Â GetValueã€IsNullÂ ç­‰ï¼‰è®¿é—®å’Œå¤„ç†å…ƒç»„ä¸­çš„æ•°æ®ã€‚ å°†å¤„ç†åçš„æ•°æ®ä½œä¸ºç»“æœè¿”å›ç»™ç”¨æˆ·æˆ–è¿›ä¸€æ­¥å¤„ç†ã€‚ è°“è¯ä¸‹æ¨ è°“è¯ä¸‹æ¨ï¼ˆPredicate Pushdownï¼‰æ˜¯æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ä¸­çš„ä¸€ç§æŠ€æœ¯ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯å°†æŸ¥è¯¢ä¸­çš„è¿‡æ»¤æ¡ä»¶ï¼ˆå³è°“è¯ï¼‰å°½å¯èƒ½æ—©åœ°åº”ç”¨åˆ°æŸ¥è¯¢æ‰§è¡Œè®¡åˆ’çš„åº•éƒ¨ï¼Œä¹Ÿå°±æ˜¯æ•°æ®ç”Ÿæˆçš„åœ°æ–¹ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†å‡å°‘æ•°æ®çš„ä¼ è¾“é‡å’Œå¤„ç†é‡ï¼Œä»è€Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚\nå…·ä½“æ¥è¯´ï¼Œè°“è¯ä¸‹æ¨åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nè¿‡æ»¤æ¡ä»¶å‰ç§»ï¼šåœ¨æŸ¥è¯¢æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œå°½æ—©åœ°å¯¹æ•°æ®è¿›è¡Œè¿‡æ»¤ï¼Œè¿™æ ·ä¸éœ€è¦å°†æ‰€æœ‰æ•°æ®éƒ½ä¼ é€’åˆ°ä¸Šå±‚æ“ä½œä¸­ï¼Œåªä¼ é€’æ»¡è¶³æ¡ä»¶çš„æ•°æ®ã€‚ å‡å°‘æ•°æ®ä¼ è¾“ï¼šé€šè¿‡åœ¨æ•°æ®ç”Ÿæˆçš„é˜¶æ®µå°±è¿›è¡Œè¿‡æ»¤ï¼Œå¯ä»¥å‡å°‘ä»æ•°æ®åº“å­˜å‚¨å¼•æ“åˆ°æŸ¥è¯¢å¤„ç†å¼•æ“ä¹‹é—´çš„æ•°æ®ä¼ è¾“é‡ã€‚ å‡å°‘ CPU å¤„ç†ï¼šä¸éœ€è¦å¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œåç»­çš„å¤„ç†ï¼Œåªéœ€è¦å¤„ç†å·²ç»è¿‡æ»¤çš„æ•°æ®ï¼Œè¿™æ ·å¯ä»¥å‡å°‘ CPU çš„å·¥ä½œé‡ã€‚ åˆ©ç”¨ç´¢å¼•ï¼šå¦‚æœè¿‡æ»¤æ¡ä»¶å¯ä»¥åˆ©ç”¨ç°æœ‰çš„ç´¢å¼•ï¼Œè°“è¯ä¸‹æ¨å¯ä»¥ä½¿å¾—æŸ¥è¯¢ç›´æ¥åˆ©ç”¨ç´¢å¼•æ¥å¿«é€Ÿå®šä½æ•°æ®ï¼Œè€Œä¸æ˜¯æ‰«ææ•´ä¸ªè¡¨ã€‚ ä¼˜åŒ–æŸ¥è¯¢è®¡åˆ’ï¼šæ•°æ®åº“ä¼˜åŒ–å™¨ä¼šæ ¹æ®è°“è¯ä¸‹æ¨çš„åŸåˆ™é‡æ–°è§„åˆ’æŸ¥è¯¢çš„æ‰§è¡Œæ­¥éª¤ï¼Œç”Ÿæˆæ›´é«˜æ•ˆçš„æŸ¥è¯¢è®¡åˆ’ã€‚ ä¾‹å¦‚ï¼š\nSELECT * FROM employees WHERE department_id = 5 AND salary \u0026gt; 50000; åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼ŒWHERE å­å¥åŒ…å«äº†ä¸¤ä¸ªè¿‡æ»¤æ¡ä»¶ã€‚å¦‚æœä¸è¿›è¡Œè°“è¯ä¸‹æ¨ï¼Œæ•°æ®åº“å¯èƒ½ä¼šå…ˆæ‰«ææ•´ä¸ª employees è¡¨ï¼Œç„¶åå°†æ‰€æœ‰è¡Œä¼ é€’ç»™ä¸Šå±‚æ“ä½œï¼Œä¹‹åå†åº”ç”¨è¿‡æ»¤æ¡ä»¶ã€‚è€Œé€šè¿‡è°“è¯ä¸‹æ¨ï¼Œæ•°æ®åº“å¯ä»¥åœ¨æ‰«æè¡¨çš„æ—¶å€™ç›´æ¥åº”ç”¨è¿™äº›è¿‡æ»¤æ¡ä»¶ï¼Œåªè¿”å›éƒ¨é—¨ ID ä¸º 5 ä¸”è–ªèµ„å¤§äº 50000 çš„å‘˜å·¥è®°å½•ã€‚\nè°“è¯ä¸‹æ¨æ˜¯æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ä¸­éå¸¸é‡è¦çš„ä¸€ç¯ï¼Œå®ƒæœ‰åŠ©äºæé«˜æŸ¥è¯¢æ€§èƒ½ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®é›†æ—¶ã€‚æ•°æ®åº“ä¼˜åŒ–å™¨ä¼šå°è¯•è‡ªåŠ¨åº”ç”¨è°“è¯ä¸‹æ¨ï¼Œä½†æœ‰æ—¶å¼€å‘è€…ä¹Ÿå¯ä»¥é€šè¿‡ç¼–å†™æ›´ä¼˜åŒ–çš„æŸ¥è¯¢æ¡ä»¶æ¥å¸®åŠ©ä¼˜åŒ–å™¨æ›´å¥½åœ°è¿›è¡Œè°“è¯ä¸‹æ¨ã€‚\nTask1 - Access Method Executors SeqScan é¡ºåºæ‰«ææŒ‡å®šçš„è¡¨ï¼Œè¡¨çš„éå†å¯ä»¥ä½¿ç”¨ TableIteratorã€‚\næ¯æ¬¡æ‰¾åˆ°ä¸€æ¡æ²¡æœ‰è¢«æ ‡è®°ä¸ºâ€œåˆ é™¤â€æˆ–è€…ä¸æ˜¯ where ä¹‹ç±»çš„è¿‡æ»¤å­å¥åŒ¹é…ï¼ˆè¿™é‡Œä¼šåœ¨ delete æ“ä½œä¸­è¯´æ˜ï¼‰çš„ tupleï¼ˆè®°å½•ï¼‰å°±å¹¶è¿”å›ï¼Œå¦‚æœå·²ç»æ‰«æåˆ°äº†è¡¨çš„ç»“æŸä½ç½®åˆ™è¿”å› falseã€‚\nInsert ä¸ºä»€ä¹ˆ Insert ç­‰ Executor æœ‰ child è€Œ SeqScan æ²¡æœ‰ï¼Ÿ InsertExecutorÂ çš„ä¸»è¦èŒè´£æ˜¯å°†ä¸€æ¡æˆ–å¤šæ¡è®°å½•æ’å…¥åˆ°æŒ‡å®šçš„è¡¨ä¸­ã€‚å®ƒå¯èƒ½éœ€è¦ä¾èµ–äºå…¶ä»–Â ExecutorÂ æ¥è·å–è¦æ’å…¥çš„æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå¦‚æœÂ INSERTÂ æ“ä½œæ˜¯ä»ä¸€ä¸ªÂ SELECTÂ æŸ¥è¯¢çš„ç»“æœé›†ä¸­æ’å…¥æ•°æ®ï¼Œé‚£ä¹ˆÂ InsertExecutorÂ å¯èƒ½ä¼šæœ‰ä¸€ä¸ªå­Â Executorï¼ˆå¦‚Â SeqScanExecutorÂ æˆ–å…¶ä»–ç±»å‹çš„Â Executorï¼‰ï¼Œè¯¥å­Â ExecutorÂ è´Ÿè´£æ‰§è¡ŒÂ SELECTÂ æ“ä½œå¹¶æä¾›æ•°æ®ç»™Â InsertExecutorã€‚\nå› æ­¤ï¼ŒInsertExecutorÂ æœ‰ child æ˜¯å› ä¸ºå®ƒå¯èƒ½éœ€è¦ä»å¦ä¸€ä¸ªæŸ¥è¯¢çš„ç»“æœä¸­è·å–æ•°æ®ã€‚\nSeqScanExecutor çš„ä¸»è¦èŒè´£æ˜¯å¯¹è¡¨è¿›è¡Œå…¨è¡¨æ‰«æï¼Œå³æŒ‰é¡ºåºè¯»å–è¡¨ä¸­çš„æ‰€æœ‰è®°å½•ã€‚è¿™æ˜¯ä¸€ä¸ªåŸºæœ¬çš„æ“ä½œï¼Œé€šå¸¸ä¸éœ€è¦å…¶ä»–Â ExecutorÂ çš„æ”¯æŒæ¥å®Œæˆå…¶å·¥ä½œã€‚\nå®ƒç›´æ¥ä½œç”¨äºå­˜å‚¨å±‚ï¼Œéå†è¡¨ä¸­çš„æ¯ä¸€è¡Œæ•°æ®ï¼Œå› æ­¤æ²¡æœ‰å­Â Executorã€‚å®ƒçš„ä»»åŠ¡ç›¸å¯¹ç®€å•ï¼Œå°±æ˜¯éå†å’Œè¿”å›è¡¨ä¸­çš„æ‰€æœ‰è®°å½•ã€‚\nç®€è€Œè¨€ä¹‹ï¼ŒInsertExecutor éœ€è¦ child æ˜¯å› ä¸ºå®ƒçš„æ“ä½œå¯èƒ½æ¶‰åŠä»å…¶ä»–æŸ¥è¯¢ç»“æœä¸­è·å–æ•°æ®ï¼Œè€Œ SeqScanExecutor ä¸éœ€è¦ child æ˜¯å› ä¸ºå®ƒçš„ä»»åŠ¡æ˜¯ç‹¬ç«‹å®Œæˆçš„ï¼Œåªéœ€éå†è¡¨ä¸­çš„æ‰€æœ‰è®°å½•å³å¯ã€‚è¿™åæ˜ äº†æ•°æ®åº“æ‰§è¡Œè®¡åˆ’ä¸­ä¸åŒæ“ä½œä¹‹é—´çš„ä¾èµ–å…³ç³»å’Œäº¤äº’æ–¹å¼ã€‚å…¶ä»– Executor åŒç†ã€‚\nä¸¾ä¸ªæ‰¹é‡æ’å…¥çš„ğŸŒ°ï¼š\nå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª orders è¡¨ï¼ŒåŒ…å«ä»¥ä¸‹åˆ—ï¼š\norder_idÂ (ä¸»é”®) customer_id product_id quantity order_date æˆ‘ä»¬å¸Œæœ›é€šè¿‡ä¸€ä¸ªå­æŸ¥è¯¢ï¼ˆselectï¼‰æ¥è·å–ä¸€æ‰¹è®¢å•è®°å½•ï¼Œå¹¶å°†è¿™äº›è®°å½•æ’å…¥åˆ° orders è¡¨ä¸­ï¼š\nINSERT INTO orders (customer_id, product_id, quantity, order_date) SELECT customer_id, product_id, quantity, order_date FROM pending_orders WHERE status = \u0026#39;approved\u0026#39;; å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬åœ¨æ’å…¥ä¹‹å‰è¦ä» select å­å¥ä¸­è·å–æ•°æ®ï¼Œå› æ­¤è¿™ä¸ªå­æŸ¥è¯¢æ“ä½œå°±æ˜¯ insert æ“ä½œçš„ child_executorã€‚\næ²¡æœ‰å­æ“ä½œæ—¶ï¼Œéœ€è¦æ’å…¥çš„æ•°æ®ä»å“ªé‡Œè·å–ï¼Ÿ æ¯”å¦‚æ‰§è¡Œå¦‚ä¸‹ SQL æ—¶ï¼š\ninsert into test_1 values (202, 1, 2, 3); ä»è‚‰çœ¼çœ‹å¯ä»¥çŸ¥é“éœ€è¦æ’å…¥çš„æ•°æ®ä¸º (202, 1, 2, 3)ï¼Œä½†æ˜¯åœ¨ä»£ç ä¸­åˆæ˜¯ä»å“ªé‡Œè·å–çš„å‘¢ï¼Ÿ\nè®©æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸‹ explain å·¥å…·æ¥çœ‹çœ‹è¿™æ¡ SQL è¯­å¥åœ¨ bustub å†…éƒ¨åšäº†ä»€ä¹ˆï¼š\nbustub\u0026gt; explain insert into test_1 values (202, 1, 2, 3); === BINDER === BoundInsert { table=BoundBaseTableRef { table=test_1, oid=22 }, select= BoundSelect { table=BoundExpressionListRef { identifier=__values#0, values=[[\u0026#34;202\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]] }, columns=[\u0026#34;__values#0.0\u0026#34;, \u0026#34;__values#0.1\u0026#34;, \u0026#34;__values#0.2\u0026#34;, \u0026#34;__values#0.3\u0026#34;], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } } === PLANNER === Insert { table_oid=22 } | (__bustub_internal.insert_rows:INTEGER) Projection { exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) Values { rows=1 } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) === OPTIMIZER === Insert { table_oid=22 } | (__bustub_internal.insert_rows:INTEGER) Values { rows=1 } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) å°†ç›®æ ‡èšç„¦åœ¨ç”Ÿæˆçš„æŸ¥è¯¢è®¡åˆ’ä¸Šï¼Œä»ä¸Šåˆ°ä¸‹ï¼Œåœ¨ä¸€ä¸ª Insert çš„æŸ¥è¯¢è®¡åˆ’ä¸­ï¼Œä½¿ç”¨ Projection ä»å…¶è¾“å…¥æºï¼ˆå¦‚è¡¨æ‰«æã€ç´¢å¼•æ‰«æã€è¿æ¥ç­‰ï¼‰ä¸­æå–æ‰€éœ€çš„åˆ—ï¼Œæœ€ä¸‹å±‚ä½¿ç”¨ Value è·å–åˆ°è¦æ“ä½œçš„æ•°æ®ï¼\næ‰€ä»¥å¯¹åº”çš„ï¼ŒInsertExecutor çš„ child_executor ä¸º ProjectionExecutorï¼Œè€Œ ProjectionExecutor çš„ child_executor ä¸º ValuesExecutorï¼Œä½¿ç”¨è¿­ä»£å™¨æ¨¡å‹å°±èƒ½å¾ˆæ–¹ä¾¿çš„è·å–åˆ°æ•°æ®äº†ï¼ˆValuesExecutor å°±æ˜¯æœ€åçš„ Executorï¼Œå…¶ Next å‡½æ•°ä¸ä¼šå†å¾€ä¸‹è°ƒç”¨ï¼Œå…¶æ‰€åšçš„åªæ˜¯æ ¹æ®åœ¨è§£æ SQL åŠå…¶ä¹‹åçš„ä¸€äº›æ­¥éª¤ä¸­å¾—åˆ°çš„éœ€è¦æ“ä½œçš„æ•°æ®å°è£…æˆä¸€ä¸ª tuple è¿›è¡Œè¿”å›ï¼‰ã€‚\nDelete éœ€è¦å†™çš„ä»£ç å’Œ insert æ“ä½œçš„åŸºæœ¬ç›¸åŒã€‚ä½†æœ‰ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œåœ¨æ‰§è¡Œä¸€æ¡ delete è¯­å¥æ—¶ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹åšäº†äº›ä»€ä¹ˆï¼š\nbustub\u0026gt; explain delete from test_1 where colA = 999; === BINDER === Delete { table=BoundBaseTableRef { table=test_1, oid=22 }, expr=(test_1.colA=999) } === PLANNER === Delete { table_oid=22 } | (__bustub_internal.delete_rows:INTEGER) Filter { predicate=(#0.0=999) } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) === OPTIMIZER === Delete { table_oid=22 } | (__bustub_internal.delete_rows:INTEGER) SeqScan { table=test_1, filter=(#0.0=999) } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ optimizer é˜¶æ®µï¼Œwhere å­å¥çš„ filter ä¸‹æ”¾è‡³ SeqScan å¤„ä¸å…¶åˆå¹¶äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å®ç° SeqScanExecutor æ—¶æ³¨æ„å¤„ç†ä¸€ä¸‹ filterã€‚è¿™é‡Œæç¤ºä¸€ä¸‹ï¼š\nwhile (cur_tuple.first.is_deleted_ || (plan_-\u0026gt;filter_predicate_ \u0026amp;\u0026amp; !(plan_-\u0026gt;filter_predicate_-\u0026gt;Evaluate(tuple, GetOutputSchema()).GetAs\u0026lt;bool\u0026gt;()))) å¦‚æœå…¶è¿”å› trueï¼Œè¯´æ˜ filter åŒ¹é…åˆ°äº†æ•°æ®ï¼ˆå°±å¦‚ä¾‹å­ä¸­åŒ¹é…åˆ°äº† colA åˆ—ä¸º 999 çš„ tupleï¼‰ï¼Œå¦‚æœæ­¤æ—¶è¿™ä¸ª tuple æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤ï¼Œé‚£ä¹ˆå°±è¯´æ˜æ‰¾åˆ°äº†æˆ‘ä»¬éœ€è¦åˆ é™¤çš„ tupleã€‚\nUpdate æˆ‘ä»¬å¦‚ä½•çŸ¥é“ update éœ€è¦æ›´æ–°çš„æ•°æ®ä»å“ªé‡Œå–å‘¢ï¼Ÿ\nbustub\u0026gt; explain(p, o) update test_1 set colB = 15445; === PLANNER === Update { table_oid=22, target_exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;15445\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } Filter { predicate=true } SeqScan { table=test_1 } === OPTIMIZER === Update { table_oid=22, target_exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;15445\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } SeqScan { table=test_1, filter=true } çœ‹çœ‹ Update ä¸­ï¼Œæœ‰ä¸€ä¸ª target_exprs æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„å¯ä¸å°±æ˜¯æˆ‘ä»¬çš„ä¸€è¡Œæ•°æ®å—ï¼Œå¹¶ä¸”æ˜¯éœ€è¦æ›´æ–°çš„é‚£è¡Œæ•°æ®ï¼šupdate è¯­å¥å¯ä»¥ä¸åŠ  where å­å¥ï¼Œè¿™æ ·å°±æ˜¯é€‰ä¸­è¡¨ä¸­çš„æ‰€æœ‰è¡Œï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œå°†è¡¨ä¸­ colB åˆ—çš„æ•°æ®éƒ½ update ä¸º 15445ï¼\nå¯¹äº target_exprs è¿™ä¸ªæ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ plan_-\u0026gt;target_expressions_ è·å–ï¼Œç„¶åç”¨å…¶æ„å»ºä¸€ä¸ªæ–°çš„ tupleã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå¹¶æ²¡æœ‰æä¾›ç›´æ¥æ›´æ–° tuple çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ update æ“ä½œå¯ä»¥ç”¨å…ˆåˆ é™¤åæ’å…¥çš„æ–¹å¼æ¥æ¨¡æ‹Ÿã€‚\nIndexScan æˆ‘ä»¬é¦–å…ˆéœ€è¦å®Œæˆ OptimizeSeqScanAsIndexScan è¿™ä¸ªä¼˜åŒ–æ­¥éª¤ã€‚\nå‡è®¾ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªè¡¨å«â€œtest_1â€ï¼Œå…¶åˆ—å¦‚ä¸‹ï¼š\n+-------------+-------------+-------------+-------------+ | test_1.colA | test_1.colB | test_1.colC | test_1.colD | +-------------+-------------+-------------+-------------+ ç°åœ¨æˆ‘ä»¬å¸Œæœ›è¿™æ¡ SQL èƒ½æ‰§è¡Œçš„æ›´å¿«ï¼š\nselect * from test_1 where colB = 11; é‚£æ¯”è¾ƒä¸é”™çš„æ–¹æ³•å°±æ˜¯ç»™ colB åˆ—åŠ ä¸Šç´¢å¼•ï¼š\ncreate index v1 on test_1(colB); è¿™æ ·åœ¨æ‰§è¡Œæ—¶å¯ä»¥æ›´å¿«é€Ÿçš„æŸ¥æ‰¾æ•°æ®ã€‚\né‚£ä¹ˆä¸ºäº†å®ç°è¿™ä¸€ç›®æ ‡ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡ OptimizeSeqScanAsIndexScan å°† plan æ ‘ä¸­çš„ SeqScanPlanNode è½¬æ¢æˆ IndexScanPlanNodeï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½ä½¿ç”¨ IndexScanPlanNode å¯¹åº”çš„ç®—å­ \u0026mdash;IndexScanExecutor å»ä½¿ç”¨ç´¢å¼•ã€‚ä½†æ˜¯ç”±äº bustub çš„ä¸€äº›è®¾è®¡ï¼Œéœ€è¦éµå¾ªä»¥ä¸‹è§„åˆ™æ‰å¯ä»¥è½¬åŒ–ï¼š\nå½“å‰çš„èŠ‚ç‚¹çš„ç±»å‹å¿…é¡»æ˜¯ PlanType::SeqScan å½“å‰èŠ‚ç‚¹å¿…é¡»æœ‰ filter è°“è¯ï¼Œå¦‚æœåªæ˜¯ select * from test_1; è¿™æ ·çš„æ˜¯ä¸éœ€è¦ä½¿ç”¨ç´¢å¼•çš„ å½“å‰è¡¨ä¸­å¿…é¡»æœ‰ç´¢å¼•ï¼Œæ²¡æœ‰ç´¢å¼•è¿˜ç©å•¥å‘¢ fileter è°“è¯ä¸­çš„é€»è¾‘è¡¨è¾¾å¼åªèƒ½æœ‰ä¸€ä¸ªï¼Œå¹¶ä¸”å…¶ç±»å‹å¿…é¡»æ˜¯ ComparisonType::Equalï¼ˆæˆ‘æƒ³è¿™é‡Œå¿…é¡»æ˜¯â€œç­‰äºâ€æ˜¯ä¸æ˜¯å› ä¸º fall2023 ä½¿ç”¨çš„ç´¢å¼•æ˜¯å“ˆå¸Œç´¢å¼•ï¼‰ åœ¨å½“å‰è¡¨çš„ç´¢å¼•ä¿¡æ¯ä¸­æ‰¾åˆ°ä¸ filter è°“è¯ç›¸å¯¹åº”çš„ç´¢å¼•åæ‰èƒ½è¿”å›ä¸€ä¸ª IndexScanPlanNode åœ¨ select * from test_1 where colB = 11; ä¸­ï¼ŒåŠ äº†ç´¢å¼•åï¼Œæœ€éœ€è¦å…³æ³¨çš„å°±æ˜¯ where colB = 11 è¿™ä¸€ä¸ªè¿‡æ»¤æ¡ä»¶ã€‚bustub ä¸­è¦æ±‚ IndexScan è¿‡æ»¤è¿ç®—ç¬¦å¿…é¡»æ˜¯ =ï¼Œä¸”åªèƒ½æœ‰ä¸€ä¸ªæ¡ä»¶ã€‚å¦‚æœ colA å’Œ colB éƒ½æ˜¯ç´¢å¼•ï¼Œç„¶åæ‰§è¡Œ select * from test_1 where colB = 11 and colA = 1;ï¼Œè¿™æ ·æ˜¯ä¸ä¼šèµ°ç´¢å¼•ä¼˜åŒ–çš„ã€‚\næˆ‘ä»¬å°†æŸ¥è¯¢è®¡åˆ’ä¸­çš„è¿‡æ»¤è°“è¯è½¬åŒ–æˆ ComparisonExpression ç±»å‹ï¼Œæ®æˆ‘çš„ç†è§£ï¼Œå…¶å¯é€šè¿‡ GetChildAt å‡½æ•°è·å–æ¯”è¾ƒè°“è¯å·¦è¾¹çš„åˆ—åè¡¨è¾¾å¼ï¼ˆå³è¿™é‡Œçš„â€œcolBâ€ï¼Œæœ‰äº†è¿™ä¸ªåˆ—åçš„è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥è·å–åˆ°è¿™ä¸ªåˆ—çš„ col_id å€¼ï¼‰å’Œå³è¾¹çš„å€¼ï¼ˆå³â€œ11â€ï¼‰ã€‚ä¹‹åéœ€è¦å»è¿™å¼ è¡¨ä¸­çš„æ‰€æœ‰ç´¢å¼•ä¸­å»æ‰¾æ˜¯å¦æœ‰ colB çš„ç´¢å¼•ï¼Œæ€ä¹ˆç¡®å®šæ˜¯å¦æœ‰å‘¢ï¼Œé‚£å°±è¦çœ‹è¿™ä¸ªè¡¨ä¸­çš„æ¯ä¸ª Index çš„ key_attrs_ï¼š\nåœ¨ Index ä¸­ï¼Œkey_attrs_ å†³å®šäº†ç´¢å¼•çš„å…³é”®å­—ç”±å“ªäº›åˆ—ç»„æˆï¼Œå¯¹åº”äº†æ¯ä¸ªåˆ—çš„ä¸‹æ ‡ã€‚ä¾‹å¦‚ï¼š\nå¦‚æœè¡¨çš„ schema å®šä¹‰æœ‰ 5 åˆ—ï¼Œåˆ†åˆ«ä¸º A, B, C, D, Eã€‚ æŸä¸ªç´¢å¼•çš„ key_attrs_ æ˜¯ [0, 2]ï¼Œåˆ™è¡¨ç¤ºè¯¥ç´¢å¼•ä½¿ç”¨äº†ç¬¬ 0 åˆ—ï¼ˆAï¼‰å’Œç¬¬ 2 åˆ—ï¼ˆCï¼‰ä½œä¸ºå…¶å…³é”®å­—ã€‚ å¦‚æœä¹‹å‰æˆ‘ä»¬è·å–çš„åˆ—çš„ col_id å€¼å’ŒæŸä¸ª Index çš„ key_attrs_ ä¸­çš„å€¼ç›¸åŒï¼Œé‚£ä¹ˆå°±å­˜åœ¨ç›¸åº”çš„ç´¢å¼•ï¼è¿™æ—¶æ„é€ ä¸€ä¸ª IndexScanPlanNode è¿”å›å³å¯ï¼ˆå‚è€ƒ merge_filter_scan.cpp ä¸­æ˜¯å¦‚ä½•åšçš„ï¼‰ã€‚\nå½“ä¼˜åŒ–å™¨æˆåŠŸæ›´æ¢èŠ‚ç‚¹åï¼Œåœ¨æ‰§è¡Œæ—¶å°±ä¼šèµ°ç´¢å¼•ï¼Œå…¶åº•å±‚ç®—å­å°±ä¼šä½¿ç”¨åˆ° IndexScanExecutorã€‚åˆ°è¿™é‡Œï¼Œè¿™ä¸ªç®—å­éœ€è¦åšçš„äº‹æƒ…å°±å¾ˆç®€å•äº†ï¼Œå°±æ˜¯è°ƒç”¨å“ˆå¸Œç´¢å¼•çš„ ScanKey è¿›è¡ŒæŸ¥æ‰¾ï¼Œä¸è¿‡è¿™é‡Œæœ‰ 3 ç‚¹éœ€è¦æ³¨æ„ï¼š\nåœ¨ project2 ä¸­ï¼Œæˆ‘ä»¬å®ç°çš„ç´¢å¼•å¼•æ“åªæ”¯æŒä¸€ä¸ªé”®å¯¹åº”ä¸€ä¸ªå€¼ï¼ˆä¸åªæ˜¯è¿™ä¸ªç‰ˆæœ¬çš„å¯æ‹“å±•å“ˆå¸Œï¼Œå…¶ä»–ç‰ˆæœ¬ä¸­çš„ B+Tree ä¹Ÿåªè¦æ±‚è¿™æ ·å®ç°ï¼‰ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„è¿™ä¸ªç®—å­åœ¨åº•å±‚ç´¢å¼•å¼•æ“ä¸æ‰©å±•çš„æƒ…å†µä¸‹æœ€å¤šæŸ¥åˆ°ä¸€æ¡è®°å½•ï¼Œè¿™æ ·çš„è¯å°±å¯ä»¥åœ¨ç®—å­çš„ Init å‡½æ•°ä¸­è°ƒç”¨ ScanKey æŸ¥æ‰¾è®°å½•å°±è¡Œã€‚ å¯æ‹“å±•å“ˆå¸Œä¸­æ˜¯å°†ä¸€ä¸ª Tuple çš„ data è½¬åŒ–ä¸€ä¸‹å½“ä½œ keyï¼Œæ‰€ä»¥åœ¨ç´¢å¼•ä¸­ï¼Œå…¶æ˜¯å°†ç´¢å¼•åˆ—çš„å€¼ä½œä¸º keyï¼Œå…¶å¯¹åº”çš„ oid ä½œä¸ºå€¼ã€‚åœ¨ä½¿ç”¨ ScanKey æ—¶ï¼Œç¬¬ä¸€ä¸ªå‚æ•°éœ€è¦çš„ tuple å°†ç”¨æŸ¥è¯¢è®¡åˆ’èŠ‚ç‚¹ IndexScanPlanNode ä¸­çš„ pred_key_ æ„é€ ã€‚ è¡¨ä¸­çš„ tuple çš„å…ƒæ•°æ®ä¸­ï¼Œå…¶ is_deleted_ å¯èƒ½ä¸º trueï¼Œè¿™è¯´æ˜è¿™ä¸ª tuple åœ¨é€»è¾‘ä¸Šå·²ç»åˆ é™¤äº†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬é€šè¿‡ 2 ä¸­è·å–çš„ oid å¯¹åº”çš„ tuple æ˜¯è¿™ç§æƒ…å†µï¼Œå°±ä¸ç”¨å‘ä¸Šè¿”å›æ•°æ®ã€‚ Task2 - Aggregation \u0026amp; Join Executors Aggregation åˆ†æä¸€ä¸ªä¾‹å­ï¼š\nbustub\u0026gt; EXPLAIN SELECT MAX(colC), MIN(colB) FROM test_1 GROUP BY colA HAVING MAX(colB) \u0026gt; 10; === BINDER === BoundSelect { table=BoundBaseTableRef { table=test_1, oid=22 }, columns=[\u0026#34;max([\\\u0026#34;test_1.colC\\\u0026#34;])\u0026#34;, \u0026#34;min([\\\u0026#34;test_1.colB\\\u0026#34;])\u0026#34;], groupBy=[\u0026#34;test_1.colA\u0026#34;], having=(max([\u0026#34;test_1.colB\u0026#34;])\u0026gt;10), where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (\u0026lt;unnamed\u0026gt;:INTEGER, \u0026lt;unnamed\u0026gt;:INTEGER) Filter { predicate=(#0.1\u0026gt;10) } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) Agg { types=[\u0026#34;max\u0026#34;, \u0026#34;max\u0026#34;, \u0026#34;min\u0026#34;], aggregates=[\u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.1\u0026#34;], group_by=[\u0026#34;#0.0\u0026#34;] } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) === OPTIMIZER === Projection { exprs=[\u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (\u0026lt;unnamed\u0026gt;:INTEGER, \u0026lt;unnamed\u0026gt;:INTEGER) Filter { predicate=(#0.1\u0026gt;10) } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) Agg { types=[\u0026#34;max\u0026#34;, \u0026#34;max\u0026#34;, \u0026#34;min\u0026#34;], aggregates=[\u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.1\u0026#34;], group_by=[\u0026#34;#0.0\u0026#34;] } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) å¯¹äº AggregationExecutorï¼Œæˆ‘ä»¬å¯ä»¥è·å–åˆ° SQL è¯­å¥ä¸­ï¼š\nèšåˆæ“ä½œçš„ typesï¼ˆè¿›è¡Œèšåˆæ“ä½œçš„ç±»å‹ï¼‰å’Œ aggregatesï¼ˆéœ€è¦èšåˆæ“ä½œçš„åˆ—ï¼‰ï¼ŒäºŒè€…ä¸€ä¸€å¯¹åº” éœ€è¦ group by è¿›è¡Œåˆ†ç»„çš„åˆ— å†çœ‹çœ‹ lecture ä¸­çš„è¿™ä¸ªä¾‹å­ï¼Œå…¶å¯¹åˆ— cid ä½¿ç”¨ group by è¿›è¡Œåˆ†ç»„ï¼Œå…¶ä¸­æ¶‰åŠçš„èšåˆæ“ä½œä¸º AVGï¼Œå¯è½¬æ¢æˆ COUNT å’Œ SUM æ“ä½œã€‚è¿™é‡Œç›¸å½“äºï¼š\ntypes = [\u0026#39;count\u0026#39;, \u0026#39;sum\u0026#39;] aggregates = [\u0026#39;s.gpa\u0026#39;, \u0026#39;s.gpa\u0026#39;] æˆ‘çš„ç†è§£æ˜¯æ ¹æ® group by çš„å­—æ®µçš„å€¼è¿›è¡Œ hash å‡½æ•°å¤„ç†ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ï¼Œä¾‹å¦‚å›¾ä¸­çš„â€œ15-445â€ï¼Œâ€œ15-826â€ç­‰ï¼›ç„¶åå“ˆå¸Œè¡¨çš„å€¼ä¸ºä¸€ä¸ªé›†åˆï¼Œè¿™ä¸ªé›†åˆçš„å¤§å°å’Œ types å’Œ aggregates çš„å¤§å°ç›¸åŒï¼Œå¹¶ä¸”å¯¹åº”çš„ä½ç½®å°±ä¸º aggregates çš„å€¼ï¼šä¾‹å¦‚å›¾ä¸­é”®â€œ15-445â€çš„å€¼ä¸­ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ å°±ä¸º COUNT æ“ä½œä¸‹ s.gpa ä¸º 15-445 çš„ä¸ªæ•°ã€‚\nåœ¨ lab ä¸­éœ€è¦å®ç° countã€sumã€maxã€min æ“ä½œï¼Œå…¶å®å°±æ˜¯åœ¨ SimpleAggregationHashTableï¼šï¼šCombineAggregateValues ä¸­å®ç°å¯¹åº”çš„æ“ä½œå³å¯ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹å“ˆå¸Œè¡¨çš„å‡ ä¸ªå¾ˆç®€å•çš„æ“ä½œã€‚\naggregation é€šå¸¸éœ€è¦å¯¹ä¸€ç»„æ•°æ®è¿›è¡Œè®¡ç®—ï¼Œè¿™äº›è®¡ç®—å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\néœ€è¦å®Œæ•´è¾“å…¥ï¼šAggregation é€šå¸¸éœ€è¦ä»ä¸‹å±‚æ‹‰å–æ‰€æœ‰ç›¸å…³æ•°æ®æ‰èƒ½è®¡ç®—ç»“æœï¼Œä¾‹å¦‚è®¡ç®— SUM éœ€è¦éå†æ‰€æœ‰è¡Œã€‚ é˜»å¡æ€§ï¼šåœ¨ä¼ ç»Ÿå®ç°ä¸­ï¼ŒAggregation ç®—å­é€šå¸¸è¢«ç§°ä¸ºâ€œé˜»å¡ç®—å­â€ï¼Œå› ä¸ºå®ƒå¿…é¡»ç­‰å¾…æ‰€æœ‰è¾“å…¥æ•°æ®éƒ½æ‹‰å–å®Œæˆæ‰èƒ½äº§å‡ºç»“æœã€‚è¿™æ„å‘³ç€ next() è°ƒç”¨ä¼šè¢«å»¶è¿Ÿï¼Œç›´åˆ°èšåˆè®¡ç®—å®Œæˆã€‚ åœ¨æˆ‘ä»¬çš„ç«å±±æ¨¡å‹ä¸­ aggregation æ˜¯é˜»å¡ç®—å­ï¼š\nå½“ä¸Šå±‚ç®—å­è°ƒç”¨ next() æ—¶ï¼Œaggregation ä¼šå‘ä¸‹å±‚ç®—å­è¿ç»­è°ƒç”¨ next()ï¼Œç›´åˆ°æ‹‰å–å®Œå…¨éƒ¨æ•°æ®å¹¶å®Œæˆèšåˆã€‚ åœ¨æ•°æ®å°šæœªå®Œå…¨æ‹‰å–å¹¶èšåˆå®Œæˆä¹‹å‰ï¼Œä¸Šå±‚çš„ next() è°ƒç”¨æ— æ³•ç›´æ¥è¿”å›ç»“æœã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nSQL ä¸­è¿›è¡Œ group by åä½¿ç”¨ countï¼Œç»Ÿè®¡çš„æ˜¯æ¯ç»„æ•°æ®ä¸­çš„è®°å½•æ•°ï¼Œè€Œéåˆ†ç»„åæ–°è¡¨çš„è¡Œæ•°ã€‚ distinct å…¶å®å°±æ˜¯å¯¹æŸä¸ªå­—æ®µè¿›è¡Œ group by æ“ä½œ count(*) ç»Ÿè®¡ nullï¼Œè€Œ count(å­—æ®µ) ä¸ç»Ÿè®¡ null NestedLoopJoin Inner Joinï¼š\nbustub\u0026gt; EXPLAIN SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE; === BINDER === BoundSelect { table=BoundCrossProductRef { left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 } }, columns=[\u0026#34;__mock_table_1.colA\u0026#34;, \u0026#34;__mock_table_1.colB\u0026#34;, \u0026#34;__mock_table_3.colE\u0026#34;, \u0026#34;__mock_table_3.colF\u0026#34;], groupBy=[], having=, where=(__mock_table_1.colA=__mock_table_3.colE), limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) Filter { predicate=(#0.0=#0.2) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Inner, predicate=true } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) bustub\u0026gt; EXPLAIN SELECT * FROM __mock_table_1 INNER JOIN __mock_table_3 ON colA = colE; === BINDER === BoundSelect { table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 }, condition=(__mock_table_1.colA=__mock_table_3.colE) }, columns=[\u0026#34;__mock_table_1.colA\u0026#34;, \u0026#34;__mock_table_1.colB\u0026#34;, \u0026#34;__mock_table_3.colE\u0026#34;, \u0026#34;__mock_table_3.colF\u0026#34;], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) å¯ä»¥çœ‹åˆ°ï¼Œå³ä¾¿æˆ‘ä»¬ä¸åŠ  inner joinï¼Œé»˜è®¤æƒ…å†µä¸‹ä¹Ÿæ˜¯ä½¿ç”¨çš„ Inner Joinï¼šNestedLoopJoin ä¸­çš„ type å‡ä¸º Innerã€‚\nLeft Joinï¼š\nbustub\u0026gt; EXPLAIN SELECT * FROM __mock_table_1 LEFT OUTER JOIN __mock_table_3 ON colA = colE; === BINDER === BoundSelect { table=BoundJoin { type=Left, left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 }, condition=(__mock_table_1.colA=__mock_table_3.colE) }, columns=[\u0026#34;__mock_table_1.colA\u0026#34;, \u0026#34;__mock_table_1.colB\u0026#34;, \u0026#34;__mock_table_3.colE\u0026#34;, \u0026#34;__mock_table_3.colF\u0026#34;], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\u0026#34;#0.0\u0026#34;, \u0026#34;#0.1\u0026#34;, \u0026#34;#0.2\u0026#34;, \u0026#34;#0.3\u0026#34;] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Left, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Left, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) ç”±äºç«å±±æ¨¡å‹ä¸­çš„ Next æ¯æ¬¡è¿”å›ä¸€æ¡ tupleï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨ Init ä¸­å¾—åˆ° join åçš„æ‰€æœ‰ tupleã€‚Nested Loop Join å…¶å®å°±æ˜¯ç”¨ä¸¤ä¸ª for å¾ªç¯å»éå†ä¸¤å¼ è¡¨ï¼Œä¿å­˜æ»¡è¶³ç­›é€‰æ¡ä»¶çš„ tupleã€‚\ninner join åªä¼šè¿”å›ä¸¤ä¸ªè¡¨ä¸­æ»¡è¶³è¿æ¥æ¡ä»¶çš„ tupleï¼›è€Œ left join ä¼šè¿”å›å·¦è¡¨ä¸­çš„æ‰€æœ‰è®°å½•ï¼Œä»¥åŠå³è¡¨ä¸­æ»¡è¶³æ¡ä»¶çš„ tupleã€‚æ‰€ä»¥åœ¨åµŒå¥— for å¾ªç¯ä¸­ï¼Œå¦‚æœå³è¡¨ä¸­æœ‰æœªèƒ½æ»¡è¶³æ¡ä»¶çš„ tupleï¼Œé‚£ä¹ˆå°±ä¿å­˜å·¦è¡¨ä¸­çš„æ¯ä¸€åˆ—çš„å€¼ï¼Œå¹¶ä¸”åŠ ä¸Šå³è¡¨ä¸­æ¯ä¸€åˆ—çš„ null å€¼ã€‚\nTask3 - HashJoin Executor and Optimization ä¸ºä»€ä¹ˆéœ€è¦ hash join å‘¢ï¼Ÿå¦‚æœä¸¤å¼ è¦è¿›è¡Œ join çš„è¡¨éå¸¸å¤§ï¼Œè¿™æ—¶ä½¿ç”¨ NLJ çš„æ—¶é—´å¤æ‚åº¦å°±ä¸º O(n*m)ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬ä½¿ç”¨ hash joinï¼Œå…ˆå¯¹ä¸€å¼ è¡¨å»ºç«‹å“ˆå¸Œæ˜ å°„ï¼Œç„¶åå†å¯¹å¦ä¸€å¼ è¡¨è¿›è¡Œå“ˆå¸Œæ£€æµ‹æ¥åˆ¤æ–­æ˜¯å¦æ»¡è¶³è¿æ¥æ¡ä»¶ï¼Œè¿™æ ·å°±åªè¦å„æ‰«æä¸€æ¬¡ä¸¤å¼ è¡¨ï¼Œæ—¶é—´å¤æ‚åº¦å°±é™ä¸ºäº† O(n+m)ã€‚\nå°† NL Join ä¼˜åŒ–ä¸º Hash Join å®éªŒæŒ‡å¯¼ä¸­è¯´ï¼Œä¼˜åŒ–å™¨éœ€è¦å°† nl join ä¼˜åŒ–ä¸º hash join çš„æƒ…å†µä¸ºï¼šè¿æ¥æ¡ä»¶ä¸­æœ‰å¤šä¸ªç­‰å€¼ AND æ“ä½œï¼Œå³ x = y AND a = b AND ...ã€‚é‚£æˆ‘ä»¬åªè¦åœ¨ç¢°åˆ° NestedLoopPlanNode æ—¶è·å–å…¶è°“è¯ï¼Œåˆ¤æ–­ä¸€ä¸‹æ˜¯å¦æ»¡è¶³è¯¥æƒ…å†µå°±å¥½äº†ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“è°“è¯ä»…ä¸º a = b æ—¶ï¼Œè¿™ä¸ªè°“è¯æ˜¯ä¸€ä¸ª ComparationExpressionï¼›è€Œå½“å®ƒä¸º x = y AND a = b AND ... æ—¶ï¼Œå®ƒæ˜¯ä¸€ä¸ª LogicExpressionã€‚è¿™é‡Œåœ¨åˆ¤æ–­çš„æ˜¯å¦éœ€è¦åŒºåˆ†ï¼Œè€Œåœ¨ä¹‹å‰çš„å®éªŒä¸­ï¼Œæœ‰å­¦ä¹ åˆ°å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„ std::dynamic_pointer_cast å‡½æ•°æ¥å°†è°“è¯ä» ExpressionåŸºç±» è½¬æ¢ä¸ºæŒ‡å®šçš„ Expressionæ´¾ç”Ÿç±»ï¼Œå½“è½¬æ¢å¤±è´¥æ—¶ï¼Œä¼šè¿”å›ç©ºæŒ‡é’ˆï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿”å›çš„æŒ‡é’ˆæ¥åˆ¤æ–­æ˜¯å¦æ˜¯æƒ³è¦çš„ Expressionï¼Œå¦‚æœä¸ºç©ºï¼Œå°±ä»£è¡¨æ˜¯å¦ä¸€ä¸ª Expressionã€‚\nç”±äºè°“è¯ä¸­å¾ˆæœ‰å¯èƒ½æ˜¯ LogicExpression åµŒå¥—ç€ LogicExpression å’Œ ComparationExpressionï¼Œæ•°é‡ä¹Ÿä¸ç¡®å®šï¼Œä¸”å­ LogicExpression å¾ˆå¯èƒ½è¿˜æœ‰åµŒå¥—ï¼Œè¿™æ ·çš„è¯ä½¿ç”¨é€’å½’æ¥å¤„ç†å°±éå¸¸æ–¹ä¾¿ã€‚\nå®ç° Hash Join hash join çš„æ ¸å¿ƒå°±æ˜¯ï¼šå…ˆå¯¹ä¸€å¼ è¡¨å»ºç«‹å“ˆå¸Œæ˜ å°„ï¼Œç„¶åå†å¯¹å¦ä¸€å¼ è¡¨è¿›è¡Œå“ˆå¸Œæ£€æµ‹æ¥åˆ¤æ–­æ˜¯å¦æ»¡è¶³è¿æ¥æ¡ä»¶ã€‚å“ˆå¸Œè¡¨ä¸­çš„ key ä¸ºè¿æ¥æ¡ä»¶ä¸­å¯¹åº”çš„å€¼çš„æ‹¼æ¥ï¼Œvalue ä¸ºæ•´ä¸ª tupleã€‚è€Œä¸€å¼ è¡¨ä¸­çš„æ‰€æœ‰ tupleï¼Œå¾ˆæœ‰å¯èƒ½ä¼šæœ‰å‡ ä¸ªåˆ—æ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œå¦‚æœè¿™äº›åˆ—åˆšå¥½ä½œä¸ºè¿æ¥æ¡ä»¶ï¼Œé‚£è¿›è¡Œå“ˆå¸Œæ—¶å°±ä¼šé€ æˆ key ç›¸åŒçš„æƒ…å†µï¼Œè¿™å°±é€ æˆäº†å“ˆå¸Œç¢°æ’ã€‚\nè§£å†³æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼š\nä½¿ç”¨ std::unordered_mapï¼Œå°†æ‹¼æ¥çš„åˆ—å€¼ä½œä¸º keyï¼Œè€Œå€¼çš„ç±»å‹ä¸º std::vector\u0026lt;Tuple\u0026gt;; ä½¿ç”¨ std::unordered_multimap æ¥å¤„ç†ã€‚ å½“æˆ‘ä»¬æ„å»ºå¥½å“ˆå¸Œè¡¨åï¼Œæ¯æ¬¡è·å–äº†å¦ä¸€å¼ è¡¨ä¸­çš„ tuple åè¿›è¡Œä¸€æ¬¡å“ˆå¸Œæ£€æµ‹ï¼Œå¦‚æœ key å­˜åœ¨ï¼Œéœ€è¦å°†æ‰€æœ‰ value éƒ½è¿›è¡Œè¿æ¥æ‹¼æ¥ã€‚åŒ nested loop join ä¸€æ ·ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†è¿æ¥ç±»å‹ä¸º left çš„æƒ…å†µã€‚\nTask4 - Sort + Limit Executors + Window Functions + Top-N Optimization Sort è¿™ä¸ªç®—å­çš„å®ç°æ€è·¯å¾ˆç®€å•ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼š\norder by åé¢å¯ä»¥è·Ÿå¤šä¸ªå…³é”®å­—ï¼Œä¹Ÿå°±æ˜¯éœ€è¦åœ¨ std::sort ä¸­å¯¹å¤šä¸ªå…³é”®å­—è¿›è¡Œæ’åºï¼ˆåˆ©ç”¨ for å¾ªç¯ï¼‰ã€‚ è¿™äº›å…³é”®å­—ä¸­å¯èƒ½è¿›è¡Œç®—æ•°è¿ç®—ï¼ˆç®—æ•°å¯¹è±¡ç±»å‹ä¸º ArithmeticExpressionï¼Œææ¸…æ¥šè¿›è¡Œè¿ç®—çš„å‡½æ•°å°±å¯ï¼‰ã€‚ Limit è¿™ä¸ªå°±æ›´ç®€å•äº†ï¼Œæ ¹æ® limit çš„è¿”å›å¯¹åº”æ•°é‡çš„ tupleã€‚\nTopN topn ç®—å­çš„ä¼˜åŒ–åªæœ‰ sort å’Œ limit åŒæ—¶å‡ºç°çš„æ˜¯å¦æ‰ä¼šè§¦å‘ï¼Œè¿™é‡Œçš„ä¼˜åŒ–é€»è¾‘æ¯”è¾ƒç®€å•ã€‚\nè€Œå…·ä½“çš„ç®—å­çš„å®ç°å…¶å®å°±æ˜¯ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œç°åœ¨ tuple æŒ‰ç…§æŸä¸ªå…³é”®å­—å‡åºæ’åˆ—ï¼Œå¹¶ä¸” limit ä¸º 10ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ„é€ ä¸€ä¸ªå°æ ¹å †ï¼Œå¹¶ç»´æŠ¤å…¶å¤§å°æœ€å¤šä¸º 10ï¼Œæœ€åç•™åœ¨å †ä¸­çš„å°±æ˜¯ç»“æœã€‚å¦‚æœåŠ›æ‰£åˆ·äº†ä¸€ç‚¹é¢˜çš„è¯å¾ˆå®¹æ˜“å°±èƒ½ç†è§£è¿™é‡Œã€‚\nWindow Function è¯´æ¥æƒ­æ„§ï¼Œå­¦ SQL çš„æ—¶å€™å¹¶ä¸çŸ¥é“çª—å£å‡½æ•°è¿™ä¸ªä¸œè¥¿\u0026hellip;ç®€å•æ¥ç†è§£ï¼Œå°±æ˜¯åœ¨ä½¿ç”¨èšåˆå‡½æ•°çš„åé¢åŠ ä¸Š over ([å¯é€‰æ“ä½œ]) å³å¯å¯¹åŒºé—´è¿›è¡Œèšåˆæ“ä½œã€‚\nå¯¹äºä¸‹é¢çš„ SQLï¼Œæœ€åè¾“å‡ºçš„ schema åº”è¯¥å’Œ WindowFunc.columns ç›¸åŒï¼Œå¹¶ä¸”è¡Œæ•°ä¹Ÿå’Œå­ executor è¿”å›çš„è¡Œæ•°ç›¸åŒï¼ˆä¸‹æ–‡å°†å­ executor è¿”å›çš„ tuple ç§°ä¸º child_tuplesï¼‰ï¼Œåªæ˜¯å¤šäº†ä¸€äº›é¢å¤–çš„è®¡ç®—åˆ—ã€‚\nbustub\u0026gt; explain(o) select v1, min(v1) over () as min_v1, max(v1) over () as max_v1, count(v1) over () as count_v1, sum(v1) over () as sum_v1 from t1; === OPTIMIZER === WindowFunc { columns=#0.0, placeholder, placeholder, placeholder, placeholder, , window_functions={ 1=\u0026gt;{ function_arg=#0.0, type=min, partition_by=[], order_by=[] }, 2=\u0026gt;{ function_arg=#0.0, type=max, partition_by=[], order_by=[] }, 3=\u0026gt;{ function_arg=#0.0, type=count, partition_by=[], order_by=[] }, 4=\u0026gt;{ function_arg=#0.0, type=sum, partition_by=[], order_by=[] } } } SeqScan { table=t1 } åœ¨è¿™æ¡ SQL ä¸­ï¼Œè¿”å›çš„ tuple çš„æ ¼å¼åº”è¯¥ä¸ºï¼š\nè¿™æ¡ tuple çš„ v1 åˆ—çš„å€¼ æ‰€æœ‰ tuple ä¸­æœ€å°çš„ v1 çš„å€¼ æ‰€æœ‰ tuple ä¸­æœ€å¤§çš„ v1 çš„å€¼ æ‰€æœ‰ tuple ä¸­ v1 çš„ä¸ªæ•° æ‰€æœ‰ tuple ä¸­ v1 çš„å€¼çš„å’Œ è¿™å…¶å®å’Œ WindowFunc.columns æœ‰å¾ˆå¤§çš„å…³ç³»ï¼Œplaceholder è¯´æ˜è¿™åªæ˜¯ä¸ªå ä½ç¬¦ï¼Œå…¶åº”è¯¥ä¸º window_functions[ä¸‹æ ‡] å¯¹åº”çš„çª—å£å‡½æ•°ã€‚ä¾‹å¦‚ç¬¬äºŒä¸ª placeholder åœ¨ columns çš„ä¸‹è¡¨ä¸º 1ï¼Œå…¶å¯¹åº”çš„çª—å£å‡½æ•°å°±æ˜¯ { function_arg=#0.0, type=min, partition_by=[], order_by=[] }ã€‚é‚£ä¹ˆå°±å¯ä»¥é€šè¿‡ column æ¥æ‰¾åˆ°æ¯ä¸ªçª—å£å¯¹åº”çš„å“ˆå¸Œè¡¨ã€‚\nï¸éœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nå¦‚æœæŒ‰ç…§ ORDER BY è¿›è¡Œæ’åºåï¼Œæ¯ä¸€è¡Œçš„çª—å£èŒƒå›´ä»ç¬¬ä¸€è¡Œå¼€å§‹æ‰©å±•åˆ°å½“å‰è¡Œ å¦åˆ™æ¯ä¸€è¡Œçš„çª—å£èŒƒå›´æ˜¯æ•´ä¸ª child_tuples æ—¢ç„¶å¦‚æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å…ˆä» child_executor è·å–åˆ°æ‰€æœ‰çš„ child_tuplesï¼Œç„¶åå¯¹ child_tuples éå†ï¼šå¦‚æœæœ‰åˆ†ç»„è¡Œä¸ºï¼Œé‚£å°±éœ€è¦æŒ‰ç…§æŸä¸€åˆ—ï¼ˆæˆ–å¤šåˆ—ï¼‰è¿›è¡Œåˆ†ç»„ï¼Œç„¶åå¯¹äºæ¯ä¸€ä¸ª tupleï¼Œéƒ½è®©å…¶æ‰§è¡Œä¸€æ¬¡ WindowFunc.window_functions ä¸­çš„çª—å£å‡½æ•°ã€‚\nç¨æœ‰ä¸åŒçš„æ˜¯ï¼Œä¹‹å‰çš„ aggregation æ“ä½œåˆ†ç»„åå¯èƒ½éœ€è¦å®Œæˆå¤šä¸ªèšåˆå‡½æ•°ï¼Œä½†æ˜¯è¿™é‡Œæˆ‘ä»¬åˆ†ç»„ä¹‹åï¼Œåªä¼šå®Œæˆä¸€ä¸ªèšåˆå‡½æ•°ï¼Œå› ä¸ºæ¯ä¸ªçª—å£ä¸­åªæœ‰ä¸€ä¸ªèšåˆå‡½æ•°ã€‚\nç°åœ¨çœ‹æ¥ï¼Œè¿™ä¸ªçª—å£å‡½æ•°ä¹Ÿæ— éå°±æ˜¯å¯¹æŸä¸ªèŒƒå›´å†…çš„ tuple è¿›è¡Œåˆ†ç»„å’Œèšåˆæ“ä½œï¼Œå®éªŒæŒ‡å¯¼ä¸­ä¹Ÿæç¤ºæˆ‘ä»¬å¯ä»¥å»åˆ©ç”¨ task2 ä¸­å†™çš„ä»£ç ã€‚åœ¨æˆ‘çš„å®ç°æ–¹æ¡ˆä¸­ï¼Œå¹¶ä¸åƒ task2 ä¸­åªä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå› ä¸ºåœ¨ä¸€æ¡ SQL å‡½æ•°ä¸­ï¼Œå¯èƒ½æœ‰å¤šä¸ªçª—å£å‡½æ•°ï¼Œæ¯ä¸€ä¸ªçª—å£å‡½æ•°åˆå¯èƒ½åˆä¸åŒçš„åˆ†ç»„å’Œä¸åŒçš„èšåˆæ“ä½œï¼Œå› æ­¤æˆ‘å¯¹äºæ¯ä¸€ä¸ªçª—å£å‡½æ•°éƒ½è®¾ç½®äº†ä¸€ä¸ªå“ˆå¸Œè¡¨ã€‚\nè¯¥ task ä¸­ bustub å¾ˆä»æ…ˆåœ°ç®€åŒ–äº†éš¾åº¦ï¼šå¦‚æœçª—å£å‡½æ•°ä»»æ„ä¸€ä¸ªä¸­æœ‰ order byï¼Œé‚£ä¹ˆæ‰€æœ‰çª—å£å‡½æ•°çš„ order by éƒ½ç›¸åŒã€‚ä¸è¿‡åœ¨æœ‰æ’åºå’Œæ²¡æœ‰æ’åºçš„æƒ…å†µä¸‹ï¼Œçª—å£çš„èŒƒå›´æœ‰æ‰€ä¸åŒï¼Œå¤„ç†èµ·æ¥çš„æ–¹æ³•ä¹Ÿä¸åŒã€‚\næ— æ’åºçš„æƒ…å†µ è¿™ä¸ªæƒ…å†µä¸‹ï¼Œæ¯ä¸ªçª—å£å‡½æ•°çš„èŒƒå›´å°±æ˜¯æ•´ä¸ª child_tuplesã€‚ä¹‹åå†æ¬¡éå†æ¯ä¸€æ¡ tupleï¼ŒæŒ‰ç…§è¾“å‡ºçš„ schema æ¥æ„å»ºè¿”å›çš„ tupleã€‚é‚£ä¹ˆå®ç°æ“ä½œåº”è¯¥å¦‚ä¸‹ï¼š\nå…ˆææ‰€æœ‰ tupleï¼Œç”Ÿæˆè¿™æ¡ tuple å¯¹åº”çš„ key å’Œ valueï¼Œå†æŠŠ key å’Œ value åŠ å…¥å¯¹åº”çš„å“ˆå¸Œè¡¨ã€‚\nç„¶åå¯¹äºæ¯ä¸€æ¡ tupleï¼Œéå† WindowFunc.columnsï¼š\nå¦‚æœ column ä¸æ˜¯ placeholderï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸ªä½ç½®æ˜¯è¿™ä¸ª tuple ä¸­çš„ä¸€åˆ—ï¼Œè·å–è¿™ä¸€åˆ—å¯¹åº”çš„ Value å°±å¥½ã€‚ å¦‚æœ column æ˜¯ placeholderï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸ªä½ç½®çš„å€¼åº”è¯¥æ˜¯å¯¹åº”çš„çª—å£å‡½æ•°çš„æ‰§è¡Œç»“æœï¼Œé‚£ä¹ˆä» column å¯¹åº”çš„å“ˆå¸Œè¡¨ä¸­æ‰¾å‡ºè¿™ä¸ª tuple å¯¹åº”çš„å€¼å°± okã€‚ æœ‰æ’åºçš„æƒ…å†µ åœ¨è¿™ä¸ªæƒ…å†µä¸‹ï¼Œæ’åºå·åæ¯æ¡ tuple çš„èŒƒå›´æ˜¯è‡ªèº«åŠä¹‹å‰çš„æ‰€æœ‰ tupleï¼Œè€Œä¸æ˜¯åƒä¹‹å‰ä¸€æ ·çš„æ‰€æœ‰ tupleã€‚è¿™å°±æœ‰ç‚¹åƒä¸€å¥è¯ï¼šâ€œèµ°ä¸€æ­¥çœ‹ä¸€æ­¥â€ã€‚\nè¿˜æ˜¯éå†æ¯ä¸€æ¡ tupleï¼Œå¯¹æ¯ä¸€æ¡ tuple åˆéå† WindowFunc.columnsï¼š\nå¦‚æœ column ä¸æ˜¯ placeholderï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸ªä½ç½®æ˜¯è¿™ä¸ª tuple ä¸­çš„ä¸€åˆ—ï¼Œè·å–è¿™ä¸€åˆ—å¯¹åº”çš„ Value å°±å¥½ã€‚è¿™é‡Œå’Œæ— æ’åºçš„æƒ…å†µä¸€è‡´ã€‚ å¦‚æœ column æ˜¯ placeholderï¼Œ ç”Ÿæˆè¿™æ¡ tuple å¯¹åº”çš„ key ç”Ÿæˆè¿™æ¡ tuple å¯¹åº”çš„ valueï¼Œå¹¶å°† {key, value} æ’å…¥ column å¯¹åº”çš„å“ˆå¸Œè¡¨ï¼ˆåœ¨ task2 ä¸­å¯çŸ¥ï¼Œè¿™é‡Œçš„â€œæ’å…¥â€å…¶å®æ˜¯å¯¹ key å¤„çš„æ—§å€¼ old_value ä¸æ–°å€¼ value è¿›è¡Œèšåˆæ“ä½œï¼‰ ä»å“ˆå¸Œè¡¨ä¸­å–å‡º key å¯¹åº”çš„ value è¿™é‡Œçš„ 2.2 å’Œ 2.3 å°±æ˜¯ä¹‹å‰æ‰€è¯´çš„â€œèµ°ä¸€æ­¥çœ‹ä¸€æ­¥â€ï¼šå½“å‰ tuple çš„ç»“æœæ˜¯åœ¨ä¹‹å‰çš„ tuple ä¸Šèšåˆè€Œæ¥çš„ã€‚\næ€»ç»“ è¿™ä¸ª Project éœ€è¦æˆ‘ä»¬å»æ·±å…¥ç†è§£ bustub çš„æºç ï¼ŒçŸ¥é“ä¸€æ¡ SQL ä¼šè¢«è§£ææˆä¸€æ£µä»€ä¹ˆæ ·çš„ plan æ ‘ï¼Œåœ¨ç»è¿‡åŸºäºè§„åˆ™çš„ä¼˜åŒ–å™¨ä¼˜åŒ–åæ‰ä¼šæ˜¯æœ€ç»ˆçš„ç‰©ç† plan æ ‘ï¼Œè¿™æ—¶åˆè¦å»ç†è§£è¿™æ£µæ ‘ä¸Šæ¯ä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç®—å­åº”è¯¥æ˜¯æ€ä¹ˆå®ç°çš„ã€‚å…¶å®çŸ¥é“äº† plan æ ‘æ˜¯ä»€ä¹ˆæ ·å­åï¼ŒèŠ‚ç‚¹å¯¹åº”çš„ç®—å­å°±æŒ‰ç…§è¦æ±‚å»è®¾è®¡å°±å¥½äº†ã€‚\nåœ¨ä¼—å¤š AI ä¾‹å¦‚ ChatGPTã€DeepSeekã€Kimi ç­‰å¸®åŠ©ä¸‹ï¼Œè¿˜æ˜¯æ…¢æ…¢ç†è§£å¹¶å®Œæˆäº†è¿™ä¸ª Projectï¼ä½†æ˜¯æœ‰çš„åœ°æ–¹æˆ‘å¯èƒ½è¿˜æ²¡æœ‰åšçš„æ¯”è¾ƒå¥½ï¼Œä»¥åæœ‰æ—¶é—´å†ä¼˜åŒ–ä¸€ä¸‹ã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/","summary":"è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™ Lab æ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨ Github å’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nè¿™ä¸ª project å’Œä¹‹å‰å°±ä¸ä¸€æ ·äº†ï¼Œå¼€å§‹æ·±å…¥æ•°æ®åº“å†…æ ¸çš„å®ç°äº†ã€‚éœ€è¦ç†æ¸…æ¥šä¸€æ¡ sql è¯­å¥æ˜¯å¦‚ä½•è¢«æ‰§è¡Œçš„ï¼Œæ–¹æ‰èƒ½å†™å‡ºä»£ç ã€‚\nå‰ç½®å¥¶é…ª ä¸€æ¡ SQL è¯­å¥çš„æ‰§è¡Œ è¿™é‡Œéœ€è¦å»çœ‹çœ‹ä¸€æ¡ sql è¯­å¥ä¼ å…¥ bustub å†…éƒ¨ä¹‹åçš„ä»£ç ï¼šsrc/common/bustub_instance.cpp:ExecuteSqlTxnï¼š\nauto BustubInstance::ExecuteSqlTxn(const std::string \u0026amp;sql, ResultWriter \u0026amp;writer, Transaction *txn, std::shared_ptr\u0026lt;CheckOptions\u0026gt; check_options) -\u0026gt; bool { if (!sql.empty() \u0026amp;\u0026amp; sql[0] == \u0026#39;\\\\\u0026#39;) { // å¤„ç†å…ƒå‘½ä»¤ ... } // binderï¼Œä½†æ˜¯åœ¨å…¶ä¸­ä¼šä½¿ç”¨libpg_queryæ¥è§£æsqlè¯­å¥ bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // ç»è¿‡ä¸Šä¸€æ­¥åï¼Œbinderä¸­çš„statement_nodes_å­˜å‚¨ç€æ‰€æœ‰çš„è¯­å¥è§£æèŠ‚ç‚¹ for (auto *stmt : binder.statement_nodes_) { // å°†stmtè½¬æ¢æˆBoundStatementå¯¹è±¡ï¼Œæ–¹ä¾¿åé¢å¤„ç†æ•°æ® auto statement = binder.BindStatement(stmt); // åªæœ‰ä¸éœ€è¦æ„å»ºplanæ ‘ã€ä¸éœ€è¦è¿›è¡Œä¼˜åŒ–çš„sqlè¯­å¥æ‰ä¼šåœ¨switchä¹‹åç»§ç»­æ‰§è¡Œ switch (statement-\u0026gt;type_) { ... } // ç”Ÿæˆåˆæ­¥çš„æ‰§è¡Œè®¡åˆ’ bustub::Planner planner(*catalog_); planner.","title":"ã€CMU15-445 Fall2023ã€‘Project3 Query Execution å°ç»“"},{"content":"æœ€è¿‘æŠŠåšå®¢çš„æ„å»ºå·¥å…·ä»Hexoæ¢æˆäº†Hugoï¼Œæ„Ÿè§‰Hugoé…ç½®å’Œä½¿ç”¨èµ·æ¥æ›´ç®€æ´æ–¹ä¾¿ã€‚\nç”±äºæˆ‘çš„åšå®¢æ€»ä½“æ¥è¯´æœ‰ä¸¤ä¸ªä»“åº“ï¼Œä¸€ä¸ªç§æœ‰ä»“åº“æ˜¯æ”¾ç½®å»ºç«™å·¥å…·çš„ç›®å½•ï¼Œå…¶ä¸­åŒ…å«åšå®¢ Markdown å†…å®¹ã€ä¸€äº›é…ç½®è¿˜æœ‰ä¸»é¢˜ï¼›å¦ä¸€ä¸ªå°±æ˜¯é€šè¿‡ GitHub Pages æ¥è®¿é—®å…¬å…±ä»“åº“ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œä¹‹å‰åœ¨ä½¿ç”¨ Hexo çš„ä½¿ç”¨ä½¿ç”¨äº† Github Actions æ¥ä¸€é”®éƒ¨ç½²åšå®¢ï¼Œæ¢æˆ Hugo åè¿™ä¸ª actions éœ€è¦ä¿®æ”¹ä¸€ä¸‹ã€‚\n.github/workflows/hugo.ymlï¼š\nname: GitHub Pages on: push: branches: - master # ç›‘å¬ master åˆ†æ”¯çš„æ¨é€äº‹ä»¶ pull_request: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: true # æ‹‰å– Hugo ä¸»é¢˜å­æ¨¡å— fetch-depth: 0 # è·å–å®Œæ•´æäº¤å†å² - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.126.2\u0026#39; extended: true - name: Build run: hugo --minify # å¯ç”¨å‹ç¼©ä¼˜åŒ– - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.ACCESS_TOKEN }} # ä»“åº“è®¿é—®ä»¤ç‰Œ external_repository: kerolt/kerolt.github.io # å‘å¸ƒçš„ä»“åº“åœ°å€ PUBLISH_BRANCH: master # éƒ¨ç½²åˆ†æ”¯ PUBLISH_DIR: ./public # Hugo è¾“å‡ºç›®å½• å…³é”®ç‚¹è¯´æ˜ï¼š\nå­æ¨¡å—å¤„ç†\nsubmodules: trueï¼Œç¡®ä¿èƒ½æ­£ç¡®æ‹‰å– Hugo ä¸»é¢˜ï¼ˆå› ä¸ºæˆ‘çš„åšå®¢ä¸»é¢˜æ˜¯é€šè¿‡ git submodule æ·»åŠ çš„ï¼‰ Hugo æ‰©å±•ç‰ˆ\nextended: trueÂ ï¼Œå› ä¸ºå¤§å¤šæ•° Hugo ä¸»é¢˜éœ€è¦ Sass/SCSS æ”¯æŒ å®‰å…¨å‡­è¯\né€šè¿‡Â secrets.ACCESS_TOKENÂ å®ç°å®‰å…¨éƒ¨ç½²ï¼Œéœ€è¦åœ¨ Repo Settings â†’ Secrets ä¸­æ·»åŠ ä¸€ä¸ªå…·æœ‰ repo æƒé™çš„ Personal Access Token åŒä»“åº“æ¨¡å¼\nä½¿ç”¨Â external_repositoryÂ å°†æ„å»ºç»“æœå‘å¸ƒåˆ°ç‹¬ç«‹çš„ GitHub Pages ä»“åº“ï¼Œå®ç°æºç ä¸éƒ¨ç½²åˆ†ç¦» ","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/hugo%E9%85%8D%E7%BD%AEgithub-actions/","summary":"æœ€è¿‘æŠŠåšå®¢çš„æ„å»ºå·¥å…·ä»Hexoæ¢æˆäº†Hugoï¼Œæ„Ÿè§‰Hugoé…ç½®å’Œä½¿ç”¨èµ·æ¥æ›´ç®€æ´æ–¹ä¾¿ã€‚\nç”±äºæˆ‘çš„åšå®¢æ€»ä½“æ¥è¯´æœ‰ä¸¤ä¸ªä»“åº“ï¼Œä¸€ä¸ªç§æœ‰ä»“åº“æ˜¯æ”¾ç½®å»ºç«™å·¥å…·çš„ç›®å½•ï¼Œå…¶ä¸­åŒ…å«åšå®¢ Markdown å†…å®¹ã€ä¸€äº›é…ç½®è¿˜æœ‰ä¸»é¢˜ï¼›å¦ä¸€ä¸ªå°±æ˜¯é€šè¿‡ GitHub Pages æ¥è®¿é—®å…¬å…±ä»“åº“ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œä¹‹å‰åœ¨ä½¿ç”¨ Hexo çš„ä½¿ç”¨ä½¿ç”¨äº† Github Actions æ¥ä¸€é”®éƒ¨ç½²åšå®¢ï¼Œæ¢æˆ Hugo åè¿™ä¸ª actions éœ€è¦ä¿®æ”¹ä¸€ä¸‹ã€‚\n.github/workflows/hugo.ymlï¼š\nname: GitHub Pages on: push: branches: - master # ç›‘å¬ master åˆ†æ”¯çš„æ¨é€äº‹ä»¶ pull_request: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: true # æ‹‰å– Hugo ä¸»é¢˜å­æ¨¡å— fetch-depth: 0 # è·å–å®Œæ•´æäº¤å†å² - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.126.2\u0026#39; extended: true - name: Build run: hugo --minify # å¯ç”¨å‹ç¼©ä¼˜åŒ– - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.","title":"Hugoé…ç½®Github Actions"},{"content":"å¾®ä¿¡åœ¨ä¸ä¹…å‰ç»ˆäºæœ‰äº†LinuxåŸç”Ÿç‰ˆæœ¬ï¼Œæˆ‘çš„ç”µè„‘æ˜¯Fedora41ï¼Œä¹‹å‰å®‰è£…çš„æ˜¯flatpakæ‰“åŒ…çš„å¾®ä¿¡ï¼Œç°åœ¨åœ¨å®˜ç½‘ä¸‹è½½rpmåŒ…åè¿è¡Œå‘ç°æ— æ³•ä½¿ç”¨fcitxçš„ä¸­æ–‡è¾“å…¥æ³•ï¼Œæ‰¾äº†ä¸€ä¸‹æ˜¯ç¯å¢ƒéå†çš„é—®é¢˜ã€‚\néœ€è¦æ·»åŠ çš„ç¯å¢ƒå˜é‡ä¸ºï¼š\nexport XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; export GTK_IM_MODULE=\u0026#34;fcitx\u0026#34; export QT_IM_MODULE=\u0026#34;fcitx\u0026#34; ä½†æ˜¯åœ¨KDE6 Waylandä¸‹å¦‚æœæŠŠå®ƒå†™å…¥/etc/profileä¸­å¥½åƒä¼šæœ‰é—®é¢˜ï¼Ÿæ‰€ä»¥æˆ‘æŠŠè¿™ä¸ªç¯å¢ƒå˜é‡æ”¾åˆ°wechat.desktopä¸­å»ï¼Œç›¸å½“äºç»™/usr/bin/wechatè¿™ä¸ªç¨‹åºè¿›è¡Œéš”ç¦»ï¼ˆé‡ç‚¹åœ¨Execä¸­ï¼‰ï¼š\n[Desktop Entry] Name=wechat Name[zh_CN]=å¾®ä¿¡ Exec=env XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; GTK_IM_MODULE=\u0026#34;fcitx\u0026#34; QT_IM_MODULE=\u0026#34;fcitx\u0026#34; /usr/bin/wechat %U StartupNotify=true Terminal=false Icon=/opt/wechat/icons/wechat.png Type=Application Categories=Utility; Comment=Wechat Desktop Comment[zh_CN]=å¾®ä¿¡æ¡Œé¢ç‰ˆ ","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/linux%E4%B8%8B%E5%BE%AE%E4%BF%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","summary":"\u003cp\u003eå¾®ä¿¡åœ¨ä¸ä¹…å‰ç»ˆäºæœ‰äº†LinuxåŸç”Ÿç‰ˆæœ¬ï¼Œæˆ‘çš„ç”µè„‘æ˜¯Fedora41ï¼Œä¹‹å‰å®‰è£…çš„æ˜¯flatpakæ‰“åŒ…çš„å¾®ä¿¡ï¼Œç°åœ¨åœ¨å®˜ç½‘ä¸‹è½½rpmåŒ…åè¿è¡Œå‘ç°æ— æ³•ä½¿ç”¨fcitxçš„ä¸­æ–‡è¾“å…¥æ³•ï¼Œæ‰¾äº†ä¸€ä¸‹æ˜¯ç¯å¢ƒéå†çš„é—®é¢˜ã€‚\u003c/p\u003e","title":"Linuxä¸‹å¾®ä¿¡æ— æ³•ä½¿ç”¨ä¸­æ–‡è¾“å…¥æ³•é—®é¢˜è§£å†³"},{"content":"ä¸ºäº† CMake Tool èƒ½è°ƒè¯•ä»£ç ï¼Œå…ˆè£…å¥½ codelldb æ’ä»¶ï¼Œç„¶åè¿˜éœ€è¦ä¸€ä¸ª launch.json æ–‡ä»¶ï¼Œä»¥ä¸‹å†…å®¹å¯ä»¥ä¸€é”®é…ç½®å¥½è°ƒè¯•ï¼š\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;LLDB\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${command:cmake.launchTargetPath}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, } ] } ","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%9C%A8vscode%E4%B8%AD%E9%85%8D%E7%BD%AElldb/","summary":"ä¸ºäº† CMake Tool èƒ½è°ƒè¯•ä»£ç ï¼Œå…ˆè£…å¥½ codelldb æ’ä»¶ï¼Œç„¶åè¿˜éœ€è¦ä¸€ä¸ª launch.json æ–‡ä»¶ï¼Œä»¥ä¸‹å†…å®¹å¯ä»¥ä¸€é”®é…ç½®å¥½è°ƒè¯•ï¼š\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;LLDB\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${command:cmake.launchTargetPath}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, } ] } ","title":"åœ¨VSCodeä¸­é…ç½®LLDB"},{"content":"ä»€ä¹ˆæ˜¯mmapï¼Ÿ mmap æ˜¯ä¸€ç§ç”¨äºå°†æ–‡ä»¶æˆ–è®¾å¤‡ä¸è¿›ç¨‹çš„åœ°å€ç©ºé—´å…³è”èµ·æ¥çš„å†…å­˜æ˜ å°„æŠ€æœ¯ã€‚é€šè¿‡ mmapï¼Œå¯ä»¥å°†æ–‡ä»¶çš„å†…å®¹ç›´æ¥æ˜ å°„åˆ°è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ï¼Œä½¿å¾—æ–‡ä»¶çš„å†…å®¹å¯ä»¥åƒæ“ä½œæ™®é€šå†…å­˜ä¸€æ ·è¿›è¡Œè¯»å–å’Œå†™å…¥ã€‚\nåœ¨Linuxä¸­ï¼Œè™šæ‹Ÿå†…å­˜çš„å¸ƒå±€å¦‚ä¸‹ï¼š\nå›¾ç‰‡æ¥æºï¼šå°æ—coding\nå½“æˆ‘ä»¬åœ¨Linuxä¸Šä½¿ç”¨mmapç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå¾—åˆ°çš„æ–‡ä»¶æ˜ å°„å°±ä¼šæ”¾åœ¨å›¾ä¸­çš„â€œæ–‡ä»¶æ˜ å°„ä¸åŒ¿åæ˜ å°„åŒºâ€ã€‚æ¯å½“æˆ‘ä»¬éœ€è¦è¯»å–æˆ–ä¿®æ”¹æ–‡ä»¶æ—¶ï¼Œåªéœ€è¦å»æ“ä½œè¿™ä¸€å—è™šæ‹Ÿå†…å­˜å³å¯ï¼Œè€Œçœå»äº†å°†æ–‡ä»¶çš„å†…å®¹ä»ç£ç›˜è¯»å–åˆ°å†…æ ¸ç¼“å†²åŒºï¼Œç„¶åå†æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºï¼Œè¿™å¤§å¤§å‡å°äº†èµ„æºå¼€é”€ã€‚\nç³»ç»Ÿè°ƒç”¨å‚æ•°è¯´æ˜ è¯¥labå¸Œæœ›æˆ‘ä»¬å®ç°xv6ä¸Šçš„mmapå’Œmunmapç³»ç»Ÿè°ƒç”¨ï¼Œå…¶å‡½æ•°å£°æ˜ä¸ºï¼š\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t len); è¿™ä¸Linuxä¸Šçš„ä½¿ç”¨æ˜¯ç›¸åŒçš„ï¼Œå¯¹å…¶ä¸­çš„å‚æ•°è§£é‡Šå¦‚ä¸‹ï¼š\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);ï¼š\naddr (void *): è¿™æ˜¯å»ºè®®çš„æ˜ å°„èµ·å§‹åœ°å€ã€‚é€šå¸¸è®¾ç½®ä¸º NULLï¼Œç”±å†…æ ¸è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„åœ°å€ã€‚å¦‚æœæŒ‡å®šäº†éç©ºåœ°å€ï¼Œåˆ™å†…æ ¸å°½é‡åœ¨è¿™ä¸ªåœ°å€å¤„åˆ›å»ºæ˜ å°„ï¼ˆä½†ä¸ä¿è¯ï¼‰ã€‚ï¼ˆxv6ä¸­ä¸è¦æ±‚å®ç°ï¼Œaddråªè¦è€ƒè™‘ä¸º0/NULLçš„æƒ…å†µï¼‰ å¦‚æœä½¿ç”¨äº† MAP_FIXED æ ‡å¿—ï¼Œåˆ™å¿…é¡»å°†æ˜ å°„å»ºç«‹åœ¨ addr æ‰€æŒ‡å‘çš„åœ°å€ï¼Œå¦åˆ™æ˜ å°„ä¼šå¤±è´¥ã€‚ï¼ˆxv6ä¸­ä¸è¦æ±‚å®ç°ï¼‰ len (size_t): è¦æ˜ å°„çš„å†…å­˜é•¿åº¦ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚å¦‚æœä¸æ˜¯é¡µå¤§å°çš„å€æ•°ï¼Œé€šå¸¸ä¼šå‘ä¸Šèˆå…¥åˆ°æœ€è¿‘çš„é¡µè¾¹ç•Œã€‚ prot (int): æ˜ å°„åŒºåŸŸçš„ä¿æŠ¤æƒé™ã€‚å¯ä»¥æ˜¯ä»¥ä¸‹æƒé™çš„ç»„åˆï¼š PROT_READ: æ˜ å°„åŒºåŸŸå¯è¯»ã€‚ PROT_WRITE: æ˜ å°„åŒºåŸŸå¯å†™ã€‚ PROT_EXEC: æ˜ å°„åŒºåŸŸå¯æ‰§è¡Œã€‚ PROT_NONE: æ˜ å°„åŒºåŸŸä¸å¯è®¿é—®ã€‚ flags (int): æ§åˆ¶æ˜ å°„å¯¹è±¡çš„ç±»å‹ã€æ˜ å°„é¡µæ˜¯å¦å¯å…±äº«ã€æ˜ å°„æ˜¯å¦åŒæ­¥åˆ°ç£ç›˜ç­‰ã€‚å¸¸è§çš„æ ‡å¿—æœ‰ï¼š MAP_SHARED: å…±äº«æ˜ å°„ï¼Œå¯¹æ˜ å°„åŒºåŸŸçš„ä¿®æ”¹ä¼šåŒæ­¥åˆ°åº•å±‚æ–‡ä»¶ï¼Œå…¶ä»–æ˜ å°„åˆ°åŒä¸€æ–‡ä»¶çš„è¿›ç¨‹ä¹Ÿä¼šçœ‹åˆ°ä¿®æ”¹ã€‚ MAP_PRIVATE: ç§æœ‰æ˜ å°„ï¼Œå¯¹æ˜ å°„åŒºåŸŸçš„ä¿®æ”¹ä¸ä¼šå½±å“åº•å±‚æ–‡ä»¶ï¼Œä¿®æ”¹æ˜¯å†™æ—¶å¤åˆ¶çš„ï¼ˆCopy-On-Writeï¼‰ã€‚ MAP_ANONYMOUS: åˆ›å»ºä¸€ä¸ªåŒ¿åæ˜ å°„ï¼Œä¸æ–‡ä»¶æ— å…³ã€‚fd å‚æ•°è¢«å¿½ç•¥ï¼Œé€šå¸¸ä¸ MAP_PRIVATE ç»“åˆä½¿ç”¨ã€‚ï¼ˆxv6ä¸è¦æ±‚å®ç°ï¼‰ fd (int): æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œè¡¨ç¤ºè¦æ˜ å°„çš„æ–‡ä»¶ã€‚å¦‚æœä½¿ç”¨ MAP_ANONYMOUS æ ‡å¿—ï¼Œåˆ™æ­¤å‚æ•°è¢«å¿½ç•¥ï¼Œé€šå¸¸è®¾ä¸º -1ã€‚ offset (off_t): æ–‡ä»¶æ˜ å°„çš„èµ·å§‹åç§»é‡ã€‚å¿…é¡»æ˜¯é¡µå¤§å°çš„æ•´æ•°å€ã€‚ï¼ˆxv6ä¸­ä¸è¦æ±‚å®ç°ï¼Œå³åªè¦è¾“å…¥0ï¼‰ int munmap(void *addr, size_t len)ï¼š\naddr (void *): è¦è§£é™¤æ˜ å°„çš„èµ·å§‹åœ°å€ã€‚è¿™ä¸ªåœ°å€å¿…é¡»æ˜¯ç”±ä¹‹å‰çš„ mmap è°ƒç”¨è¿”å›çš„åœ°å€ï¼Œæˆ–è€…æ˜¯ç”± mmap åˆ›å»ºçš„æŸä¸ªæ˜ å°„åŒºåŸŸçš„åœ°å€ã€‚ len (size_t): è¦è§£é™¤æ˜ å°„çš„å†…å­˜é•¿åº¦ï¼Œå¿…é¡»ä¸ mmap è°ƒç”¨ä¸­çš„ len ç›¸åŒ¹é…ã€‚å¦‚æœé•¿åº¦å°äº mmap æ—¶æŒ‡å®šçš„é•¿åº¦ï¼Œå¯èƒ½ä¼šå¯¼è‡´éƒ¨åˆ†æ˜ å°„åŒºåŸŸä»ç„¶ä¿ç•™ã€‚ å¦‚ä½•å®ç°ï¼Ÿ åœ¨xv6çš„è™šæ‹Ÿå†…å­˜å¸ƒå±€ä¸­ï¼Œå¯ä»¥çœ‹åˆ°å †åŒºå’Œtrapframeä¹‹é—´æœ‰ä¸€ç‰‡æ²¡æœ‰ä½¿ç”¨çš„åŒºåŸŸï¼Œæˆ‘ä»¬å¯ä»¥æ‹¿å®ƒä½œä¸ºæ–‡ä»¶æ˜ å°„åŒºåŸŸã€‚ï¼ˆxv6å’ŒLinuxçš„è™šæ‹Ÿå†…å­˜å¸ƒå±€æœ‰ç‚¹åŒºåˆ«ï¼Œxv6çš„å †åŒºåœ¨æ ˆåŒºä¸Šé¢ï¼‰\nå½“ä½¿ç”¨mmapç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ‡’åˆ†é…çš„ç­–ç•¥ï¼ˆç±»ä¼¼äºCopy On Writeï¼‰ï¼šæˆ‘ä»¬åœ¨mmapç³»ç»Ÿè°ƒç”¨ä¸­ æ ‡è¯†ï¼ˆä¸æ˜¯åˆ†é…ï¼‰ æ–‡ä»¶æ˜ å°„åŒºä¸­æœ‰ä¸€ä¸ªåŒºåŸŸä¸æ–‡ä»¶ç›¸å…³è”ï¼Œä½†è¿™æ—¶è¿˜ä¸ä¼šåˆ†é…ç‰©ç†å—ï¼Œè‡ªç„¶è¿˜ä¸æ€¥ç€å°†æ–‡ä»¶è¯»å…¥è¿™ç‰‡å†…å­˜åŒºåŸŸï¼›å½“æˆ‘ä»¬éœ€è¦è®¿é—®è¿™ç‰‡åŒºåŸŸçš„å†…å­˜æ—¶ï¼Œå¯ä»¥é€šè¿‡è§¦å‘page faultæ¥åˆ†é…ç‰©ç†å—ï¼Œç„¶åè¯»å…¥æ–‡ä»¶å†…å®¹åˆ°å†…å­˜å—ä¸­ï¼Œå¹¶å°†è™šæ‹Ÿå†…å­˜æ˜ å°„åˆ°è¿™å—ç‰©ç†å†…å­˜ä¸Šã€‚\nä½¿ç”¨munmapç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œä¼šè§£é™¤æ–‡ä»¶åœ¨æ˜ å°„åŒº[addr, addr + len]èŒƒå›´å†…çš„æ˜ å°„ï¼Œå°†è¿™å—åŒºåŸŸçš„å†…å­˜å†™å›æ–‡ä»¶ï¼Œå¹¶é‡Šæ”¾æ‰è¿™å—å†…å­˜ã€‚å®éªŒä¸­ä¿è¯é‡Šæ”¾çš„åŒºåŸŸå¤§å°ä¸€å®šæ˜¯é¡µçš„æ•´æ•°å€ã€‚\næˆ‘ä»¬ä¹Ÿä»¿ç…§Linuxä¸Šçš„ï¼Œè®©æ–‡ä»¶æ˜ å°„åŒºä»é«˜åœ°å€å¤„å¼€å§‹å‘ä½åœ°å€å¢é•¿ã€‚ä¸‹å›¾æ˜¯æ–‡ä»¶æ˜ å°„çš„æ ·å­ï¼Œå·¦è¾¹ä¸ºæ˜ å°„åŒºåŸŸå¤§å°ä¸å›ºå®šï¼Œå³è¾¹ä¸ºæ˜ å°„å¤§å°ä¸ºé¡µæ¡†çš„æ•´æ•°å€ï¼š\nåœ¨å®éªŒçš„æç¤ºä¸­ï¼Œæœ‰è¯´åˆ°mmaptestä¸­æ²¡æœ‰ä½¿ç”¨çš„åŠŸèƒ½å¯ä»¥ä¸å®ç°ï¼Œå…¶ä¸­æ¯æ¬¡ä½¿ç”¨mmapéƒ½æ˜¯æ˜ å°„çš„PGSIZEçš„æ•´æ•°å€ï¼Œé‚£ä¹Ÿå°±è¯´æ˜æˆ‘ä»¬å¯ä»¥ä¹‹ç”¨è€ƒè™‘å³è¾¹çš„æƒ…å†µï¼Œè¿™è®©å®éªŒé™ä½äº†ä¸€ç‚¹å¤æ‚åº¦ã€‚\næ ‡è¯†æ˜ å°„åŒºåŸŸ æ ¹æ®å®éªŒæç¤ºï¼Œæˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªè¿›ç¨‹è®¾ç½®ç”¨äºæ ‡è¯†æ˜ å°„åŒºåŸŸçš„ç»“æ„ä½“ï¼š\n// proc.h #define NVMA 16 struct vma { uint len; // æ˜ å°„åŒºåŸŸå¤§å° uint prot; // æ˜ å°„åŒºåŸŸçš„ä¿æŠ¤æƒé™ struct file *file; // éœ€è¦æ˜ å°„çš„æ–‡ä»¶ int used; // æ˜¯å¦è¢«ä½¿ç”¨ int flags; // æ˜ å°„ç±»å‹ int offset; // åç§»é‡ uint64 start; // æ˜ å°„åŒºåŸŸå¼€å§‹çš„åœ°å€ uint64 end; // æ˜ å°„åŒºåŸŸç»“æŸçš„åœ°å€ }; struct proc { ... struct vma vmas[NVMA]; // Virtual memory area }; å®ç°sys_mmap åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ³¨å†Œmmapå’Œmunmapç³»ç»Ÿè°ƒç”¨ï¼Œè¿™é‡Œæˆ‘ä»¬å°±ä¸èµ˜è¿°äº†\nè·å¾—æ˜ å°„åŒºä¸­çš„å¯ç”¨åŒºåŸŸ ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿæˆ‘ä»¬çš„æ˜ å°„åŒºè®¾è®¡çš„æ˜¯ä»é«˜åœ°å€å‘ä½åœ°å€å¢é•¿ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯æ¬¡éœ€è¦å¢é•¿æ—¶ï¼Œæœ€ç®€å•çš„å°±æ˜¯åœ¨å·²æœ‰çš„æ˜ å°„åŒºä¸­æ‰¾åˆ°åœ°å€æœ€ä½çš„ï¼Œå¹¶å°†æ–°çš„æ˜ å°„åŒºæ”¾åœ¨å…¶ä¹‹åï¼Œå³åœ°å€æœ€ä½çš„æ˜ å°„åŒºçš„startå°±æ˜¯æ–°çš„æ˜ å°„åŒºçš„endï¼š\nå¯æ˜¯è¿™æ ·çš„ç®—æ³•æœ‰å¾ˆå¤§çš„é—®é¢˜ï¼šå¦‚æœæˆ‘ä»¬å–æ¶ˆäº†æ–‡ä»¶2çš„æ˜ å°„åï¼Œæœ‰ä¸€ä¸ªåªéœ€è¦ä¸€ä¸ªé¡µæ¡†çš„æ˜ å°„åŒºï¼ŒæŒ‰ç…§è¿™ä¸ªç®—æ³•å®ƒä¼šè¢«å®‰æ’åˆ°æ–‡ä»¶3çš„æ˜ å°„åŒºä¸‹é¢ï¼Œè¿™æ ·å°±æµªè´¹äº†ä¹‹å‰é‡Šæ”¾çš„æ˜ å°„åŒºã€‚\nä¸è¿‡å˜›ï¼Œåœ¨è¿™ä¸ªå®éªŒä¸­è¿™ä¹ˆåšæ²¡ä»€ä¹ˆé—®é¢˜ğŸ˜œï¼Œå¦‚æœæƒ³çŸ¥é“æ›´å¥½çš„æ–¹æ³•ï¼Œå¯ä»¥å‚è€ƒè¿™ç¯‡åšå®¢ã€‚\næˆ‘çš„å®ç°å¦‚ä¸‹ï¼š\n// sysfile.c // è·å–ä¸€ä¸ªå¯ä½¿ç”¨çš„vmaçš„endåœ°å€ static uint64 vma_end() { struct proc *p = myproc(); struct vma *v = 0; uint64 min_vma_end = TRAPFRAME; for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used \u0026amp;\u0026amp; p-\u0026gt;vmas[i].end \u0026lt;= min_vma_end) { min_vma_end = p-\u0026gt;vmas[i].end; v = \u0026amp;p-\u0026gt;vmas[i]; } } // å¦‚æœè¿›ç¨‹ä¸­è¿˜æ²¡æœ‰æ–‡ä»¶æ˜ å°„ï¼Œå°±ä»trapframeåå¼€å§‹è®¾ç½®æ˜ å°„åŒº if (!v) { return min_vma_end; } // è¿™é‡Œå¯ä»¥ç›´æ¥è¿”å›v-\u0026gt;startï¼Œè¿™æ ·åšå¯ä»¥å¤„ç†æ˜ å°„åŒºåŸŸå¤§å°ä¸å›ºå®šçš„æƒ…å†µï¼ˆåº”è¯¥å§ï¼‰ return PGROUNDDOWN(v-\u0026gt;start); } sys_mmap è™½ç„¶åˆšåˆšæˆ‘ä»¬æœ‰äº†å¯ä»¥è·å–æ˜ å°„åŒºåœ°å€çš„å‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸ªç³»ç»Ÿè°ƒç”¨å¹¶ä¸ç”¨çœŸæ­£åˆ†é…å†…å­˜ï¼Œå®ƒåªéœ€è¦è¿›è¡Œæ ‡è®°vmaå³å¯ã€‚\næ‰¾åˆ°ä¸€ä¸ªå¯ä»¥ä½¿ç”¨çš„vmaåŒºåŸŸçš„endåœ°å€ åˆå§‹åŒ–vma è¿”å›vmaçš„startåœ°å€ è¿™é‡Œæˆ‘è§‰å¾—æœ€é‡è¦çš„å°±æ˜¯è®¾ç½®startå’Œendåœ°å€ï¼Œä¸€ä¸ªæ˜ å°„åŒºçš„èŒƒå›´ä¸º[start, end)ï¼Œå…¶é•¿åº¦å°±ä¸ºlenï¼Œé€šè¿‡vma_endå‡½æ•°æˆ‘ä»¬å¯ä»¥è·å–æ–°æ˜ å°„åŒºçš„endåœ°å€ï¼Œå†é€šè¿‡end - lenå³å¯å¾—åˆ°startåœ°å€ã€‚\n// sysfile.c uint64 sys_mmap(void) { // void *mmap(void *addr, int len, int prot, int flags, int fd, int offset); uint64 addr; int len, prot, flags, fd, offset; struct proc *p = myproc(); struct file *f; argaddr(0, \u0026amp;addr); argint(1, \u0026amp;len); argint(2, \u0026amp;prot); argint(3, \u0026amp;flags); argfd(4, \u0026amp;fd, \u0026amp;f); argint(5, \u0026amp;offset); if (addr \u0026lt; 0 || len \u0026lt; 0 || prot \u0026lt; 0 || flags \u0026lt; 0 || fd \u0026lt; 0 || offset \u0026lt; 0) { return -1; } if (!f-\u0026gt;readable \u0026amp;\u0026amp; (prot \u0026amp; PROT_READ) \u0026amp;\u0026amp; (flags \u0026amp; MAP_SHARED)) { return -1; } if (!f-\u0026gt;writable \u0026amp;\u0026amp; (prot \u0026amp; PROT_WRITE) \u0026amp;\u0026amp; (flags \u0026amp; MAP_SHARED)) { return -1; } // æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„vma struct vma *v = 0; for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used == 0) { v = \u0026amp;p-\u0026gt;vmas[i]; break; } } if (!v) { return -1; } // åˆå§‹åŒ–vma uint64 end = vma_end(); v-\u0026gt;len = len; v-\u0026gt;prot = prot; v-\u0026gt;file = f; v-\u0026gt;used = 1; v-\u0026gt;flags = flags; v-\u0026gt;offset = offset; v-\u0026gt;end = end; v-\u0026gt;start = end - len; // æœ‰æ–‡ä»¶æ˜ å°„æ—¶ï¼Œå¯¹åº”çš„æ–‡ä»¶çš„å¼•ç”¨è®¡æ•°ä¹Ÿ+1 filedup(f); return v-\u0026gt;start; } æ‡’åˆ†é…ç­–ç•¥ æ‰¾åˆ°è§¦å‘faultçš„åœ°å€ï¼Œå¹¶æ®æ­¤æ‰¾åˆ°å¯¹åº”çš„vma æ ¡éªŒ åˆ†é…ç‰©ç†å†…å­˜å— è®¾ç½®æƒé™ è¯»å–æ–‡ä»¶å†…å®¹åˆ°å†…å­˜å—ä¸­ï¼Œæ³¨æ„åç§»é‡ è®¾ç½®ç‰©ç†å†…å­˜ä¸è™šæ‹Ÿå†…å­˜çš„æ˜ å°„ // trap.c // å¤„ç†mmapçš„æ‡’åˆ†é…ç­–ç•¥ static int handle_mmap_fault(uint64 addr) { struct proc *p = myproc(); struct vma *v = 0; // æ ¹æ®è§¦å‘faultçš„åœ°å€ï¼Œå¹¶æ®æ­¤æ‰¾åˆ°å¯¹åº”çš„vma for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used \u0026amp;\u0026amp; addr \u0026gt;= p-\u0026gt;vmas[i].start \u0026amp;\u0026amp; addr \u0026lt; p-\u0026gt;vmas[i].end) { v = \u0026amp;p-\u0026gt;vmas[i]; break; } } if (!v) { printf(\u0026#34;no no no\\n\u0026#34;); return -1; } // æ ¡éªŒ if (!v-\u0026gt;file-\u0026gt;readable \u0026amp;\u0026amp; r_scause() == 13 \u0026amp;\u0026amp; (v-\u0026gt;flags \u0026amp; MAP_SHARED)) { return -1; } if (!v-\u0026gt;file-\u0026gt;writable \u0026amp;\u0026amp; r_scause() == 15 \u0026amp;\u0026amp; (v-\u0026gt;flags \u0026amp; MAP_SHARED)) { return -1; } // è®¾ç½®å†…å­˜å—æƒé™ uint perm = PTE_V | PTE_U; if (v-\u0026gt;prot \u0026amp; PROT_READ) { perm |= PTE_R; } if (v-\u0026gt;prot \u0026amp; PROT_WRITE) { perm |= PTE_W; } if (v-\u0026gt;prot \u0026amp; PROT_EXEC) { perm |= PTE_X; } // åˆ†é…ç‰©ç†å— char *pa = kalloc(); if (!pa) { return -1; } memset(pa, 0, PGSIZE); // è¯»å–æ–‡ä»¶å†…å®¹åˆ°å†…å­˜å— uint offset = addr - v-\u0026gt;start; ilock(v-\u0026gt;file-\u0026gt;ip); if (readi(v-\u0026gt;file-\u0026gt;ip, 0, (uint64)pa, offset, PGSIZE) == 0) { iunlock(v-\u0026gt;file-\u0026gt;ip); return -1; } iunlock(v-\u0026gt;file-\u0026gt;ip); // è®¾ç½®è™šæ‹Ÿå†…å­˜ä¸ç‰©ç†å†…å­˜çš„æ˜ å°„ mappages(p-\u0026gt;pagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)pa, perm); return 0; } ç„¶ååœ¨usertrapä¸­å¤„ç†è¯»å†™é€ æˆçš„page faultï¼š\n// trap.c void usertrap(void) { ... if(r_scause() == 8){ ... } else if((which_dev = devintr()) != 0){ // ok } else if (r_scause() == 13 || r_scause() == 15) { if (handle_mmap_fault(r_stval()) != 0) { printf(\u0026#34;usertrap(): unexpected scause %p pid=%d\\n\u0026#34;, r_scause(), p-\u0026gt;pid); printf(\u0026#34; sepc=%p stval=%p\\n\u0026#34;, r_sepc(), r_stval()); setkilled(p); } } else { ... } .. } å®ç°sys_munmap sys_munmap sys_munmapéœ€è¦å°†å†…å­˜å—ä¸­çš„å†…å®¹å†™å›æ–‡ä»¶ï¼Œå¹¶é‡Šæ”¾è¿™ä¸ªå†…å­˜å—ã€‚è¿™é‡Œæˆ‘ä»¬å°†è¿™ä¸ªæ“ä½œé¢å¤–å°è£…ä¸€å±‚ï¼Œå³ä¸å°†å…·ä½“å®ç°æ”¾åœ¨sys_munmapä¸­ï¼Œè¿™æ˜¯å› ä¸ºåœ¨è¿›ç¨‹é”€æ¯ä¹Ÿéœ€è¦ä½¿ç”¨è¿™ä¸ªæ“ä½œã€‚\n// sysfile.c uint64 sys_munmap(void) { // int munmap(void *addr, int len); uint64 addr; int len; argaddr(0, \u0026amp;addr); argint(1, \u0026amp;len); if (addr \u0026lt; 0 || len \u0026lt; 0) { return -1; } return munmap(addr, len); } è§£é™¤æ˜ å°„ éå†æ‰€æœ‰çš„vmaï¼Œæ‰¾åˆ°addræ‰€åœ¨çš„vmaï¼Œè¦æ±‚addrä¸èƒ½æ˜¯vmaåŒºåŸŸçš„ä¸­é—´ä½ç½®ï¼Œå¯ä»¥æ˜¯å¼€å¤´å’Œç»“æŸä½ç½®ã€‚ ä½¿ç”¨mmap_writebackå°†è¿™addrçš„å†…å®¹å†™å›å¯¹åº”çš„æ–‡ä»¶ æ›´æ–°vmaçš„èŒƒå›´ å¦‚æœvmaçš„lenå°äºç­‰äº0ï¼Œè¯´æ˜è¯¥æ–‡ä»¶çš„æ˜ å°„å·²ç»ç»“æŸï¼Œå¯ä»¥å…³é—­æ–‡ä»¶äº†ï¼ŒåŒæ—¶è¿™ä¸ªvmaä¹Ÿåº”è¯¥é‡Šæ”¾äº† // vm.c // è§£é™¤åŒºåŸŸ [addr, addr + len) çš„æ–‡ä»¶æ˜ å°„ uint64 munmap(uint64 addr, int len) { struct proc *p = myproc(); struct vma *v = 0; for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used \u0026amp;\u0026amp; addr \u0026gt;= p-\u0026gt;vmas[i].start \u0026amp;\u0026amp; addr \u0026lt; p-\u0026gt;vmas[i].end) { v = \u0026amp;p-\u0026gt;vmas[i]; break; } } if (!v) { return -1; } // ä¸åœ¨åˆæ³•çš„ä½ç½® if (addr \u0026gt; v-\u0026gt;start \u0026amp;\u0026amp; addr + len \u0026lt; v-\u0026gt;end) { return -1; } // å°†æ˜ å°„åŒºåŸŸå†™å›æ–‡ä»¶ mmap_writeback(p-\u0026gt;pagetable, addr, len, v); // ä¿®æ”¹æ˜ å°„åŒºåŸŸå¤§å° if (addr == v-\u0026gt;start) { v-\u0026gt;start += len; } else if (addr == v-\u0026gt;end - len) { v-\u0026gt;end = addr; } v-\u0026gt;len -= len; // æ˜ å°„åŒºåŸŸå¤§å°ä¸º0 if (v-\u0026gt;len \u0026lt;= 0) { fileclose(v-\u0026gt;file); v-\u0026gt;used = 0; } return 0; } å°†æ˜ å°„åŒºå†…å®¹å†™å›æ–‡ä»¶ éå†è¿™ä¸ªvmaä¸­çš„æ‰€æœ‰é¡µæ¡†ï¼Œå¯¹äºå…¶ä¸­çš„æ¯ä¸€ä¸ªé¡µå¸§ï¼Œè·å–å¯¹åº”çš„pteï¼Œéœ€è¦è€ƒè™‘åˆ°ç”±äºæ‡’åˆ†é…å¸¦æ¥çš„å½±å“ã€‚ å¦‚æœè¿™ä¸ªé¡µå¸§è¢«ä¿®æ”¹è¿‡ï¼Œå¹¶ä¸”è¿™å—vmaçš„ç­–ç•¥æ˜¯å¯å†™ï¼Œé‚£ä¹ˆå°±å°†è¿™ä¸ªé¡µå†™å›æ–‡ä»¶ï¼Œæ³¨æ„åç§»é‡ é‡Šæ”¾è¿™å—é¡µå¸§å¯¹åº”çš„ç‰©ç†å†…å­˜ // å°†æ˜ å°„åŒºåŸŸå†™å›æ–‡ä»¶ï¼Œå¹¶é‡Šæ”¾æ˜ å°„åŒºåŸŸçš„å†…å­˜ static int mmap_writeback(pagetable_t pgtbl, uint64 src_va, int len, struct vma *vma) { pte_t *pte; uint64 addr; // éå†åŒºåŸŸçš„é¡µæ¡† for (addr = PGROUNDDOWN(src_va); addr \u0026lt; PGROUNDDOWN(src_va + len); addr += PGSIZE) { // è·å–é¡µå¸§å¯¹åº”çš„pte if ((pte = walk(pgtbl, addr, 0)) == 0) { panic(\u0026#34;mmap_writeback\u0026#34;); } // è¿™æ˜¯ä¸ºäº†å¤„ç†è¿™æ ·ä¸€ç§æƒ…å†µï¼šä½¿ç”¨äº†mmapç³»ç»Ÿè°ƒç”¨å´æ²¡æœ‰æœ‰è®¿é—®æ˜ å°„çš„æ–‡ä»¶ï¼Œç”±äºæ‡’åˆ†é…çš„ç­–ç•¥ï¼Œ // åœ¨å†™å›æ–‡ä»¶æ—¶vmaè™½ç„¶æœ‰æ•ˆï¼Œä½†æ˜¯å¯¹åº”çš„pteå¹¶æ²¡æœ‰è®¾ç½®PTE_Vï¼Œæ˜ å°„åŒºåŸŸä¹Ÿè¿˜æ²¡æœ‰çœŸæ­£çš„æ˜ å°„æ–‡ä»¶ if (!(*pte \u0026amp; PTE_V)) { continue; } // æ˜ å°„åŒºåŸŸè¢«ä¿®æ”¹äº†ï¼Œå¯ä»¥å†™å›æ–‡ä»¶ if ((*pte \u0026amp; PTE_D) \u0026amp;\u0026amp; (vma-\u0026gt;flags \u0026amp; MAP_SHARED)) { begin_op(); ilock(vma-\u0026gt;file-\u0026gt;ip); uint offset = addr - src_va; writei(vma-\u0026gt;file-\u0026gt;ip, 1, addr, offset, PGSIZE); iunlock(vma-\u0026gt;file-\u0026gt;ip); end_op(); } kfree((void *)PTE2PA(*pte)); *pte = 0; } return 0; } æˆ‘ä»¬ä½¿ç”¨åˆ°äº†pteä¸­çš„ä¸€ä¸ªæ ‡å¿—ä½PTE_Dï¼Œå®ƒæ˜¯ç”¨æ¥æ ‡è¯†ä¸€ä¸ªé¡µæ¡†æ˜¯å¦è¢«ä¿®æ”¹äº†ï¼ˆå³è„ä½ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦åœ¨riscv.hä¸­å®šä¹‰å®ƒï¼š\n// riscv.h #define PTE_D (1L \u0026lt;\u0026lt; 7) åœ¨exitæ—¶éœ€è¦æ¸…ç©ºæ˜ å°„åŒº å½“è¿›ç¨‹é€€å‡ºæ—¶ï¼Œå…¶æ˜ å°„åŒºä¸­çš„å†…å®¹ä¹Ÿéœ€è¦é‡Šæ”¾ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦å°†munmapç‹¬ç«‹å‡ºæ¥çš„åŸå› ã€‚\n// proc.c void exit(int status) { struct proc *p = myproc(); if(p == initproc) panic(\u0026#34;init exiting\u0026#34;); for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used) { if (munmap(p-\u0026gt;vmas[i].start, p-\u0026gt;vmas[i].len) != 0) { panic(\u0026#34;exit: munmap\u0026#34;); } } } ... } åœ¨forkæ—¶éœ€è¦â€œå¤åˆ¶â€æ˜ å°„åŒº æˆ‘ä»¬è¿™é‡Œæ‰€è¯´çš„å¤åˆ¶å¹¶ä¸æ˜¯å°†æ˜ å°„åŒºçš„å†…å­˜å—åœ¨forkæ—¶éƒ½å¤åˆ¶ç»™å­è¿›ç¨‹ï¼Œå¯åˆ«å¿˜äº†COWå“¦ï¼Œæˆ‘ä»¬åªéœ€è¦å¤åˆ¶çˆ¶è¿›ç¨‹ä¸­çš„vmaæ•°ç»„ï¼ŒçŸ¥é“æ˜ å°„çš„å“ªäº›ä½ç½®æœ‰ä»€ä¹ˆæ ·çš„æ–‡ä»¶æ˜ å°„ï¼Œåœ¨çœŸæ­£è®¿é—®æ—¶å†æŒ‰éœ€åŠ è½½å³å¯ã€‚\n// proc.c int fork(void) { ... for (int i = 0; i \u0026lt; NVMA; i++) { if (p-\u0026gt;vmas[i].used) { np-\u0026gt;vmas[i] = p-\u0026gt;vmas[i]; // å­è¿›ç¨‹ä¹Ÿæ˜ å°„äº†å’Œçˆ¶è¿›ç¨‹ç›¸åŒçš„æ–‡ä»¶ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–‡ä»¶çš„å¼•ç”¨è®¡æ•°ä¹Ÿè¦å¢åŠ  filedup(p-\u0026gt;vmas[i].file); } } ... } Code Details ä»£ç å®ç°è¯¦æƒ…è¯·è§ï¼šGithub\nReference https://xiaolincoding.com/os/3_memory/linux_mem.html#_3-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4 https://ttzytt.com/2022/08/xv6_lab11_record/index.html Summary è¿™ä¸ªlabçš„ä»£ç è¿˜æ˜¯æ¯”è¾ƒå¤šçš„ï¼Œä¸è¿‡å®ƒè¿˜ç»™æˆ‘ä»¬æ”¾äº†äº›æ°´ï¼Œåªè®©æˆ‘ä»¬å®ç°ä¸€äº›åŸºç¡€çš„åŠŸèƒ½ã€‚åœ¨labä¸­æ›´é‡è¦çš„æ˜¯è¦ææ¸…æ¥šmmapçš„å®ç°åŸç†ï¼Œä¸€å®šè¦å»ç†è§£å…¶ä¸­çš„ç»†èŠ‚ã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/","summary":"\u003ch2 id=\"ä»€ä¹ˆæ˜¯mmap\"\u003eä»€ä¹ˆæ˜¯mmapï¼Ÿ\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emmap\u003c/code\u003e æ˜¯ä¸€ç§ç”¨äºå°†æ–‡ä»¶æˆ–è®¾å¤‡ä¸è¿›ç¨‹çš„åœ°å€ç©ºé—´å…³è”èµ·æ¥çš„å†…å­˜æ˜ å°„æŠ€æœ¯ã€‚é€šè¿‡ \u003ccode\u003emmap\u003c/code\u003eï¼Œå¯ä»¥å°†æ–‡ä»¶çš„å†…å®¹ç›´æ¥æ˜ å°„åˆ°è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ï¼Œä½¿å¾—æ–‡ä»¶çš„å†…å®¹å¯ä»¥åƒæ“ä½œæ™®é€šå†…å­˜ä¸€æ ·è¿›è¡Œè¯»å–å’Œå†™å…¥ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab10 mmap"},{"content":"Intro åœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œæˆ‘ä»¬éœ€è¦è®©xv6æ”¯æŒæ›´å¤§çš„æ–‡ä»¶å’Œè½¯é“¾æ¥ã€‚å®éªŒæ€»ä½“ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä¸è¿‡éœ€è¦æˆ‘ä»¬ç†è§£å¥½æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚Lab8 lockä¸­çš„Buffer Cacheä¹Ÿæ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œä¸è¿‡å®ƒä½äºæ–‡ä»¶ç³»ç»Ÿçš„ä¸‹å±‚ï¼Œè¿™é‡Œæˆ‘ä»¬éœ€è¦å¤„ç†çš„æ›´å¤šåœ¨ä¸Šå±‚ï¼Œååº”ç”¨å±‚ã€‚\nLarge files å¦‚ä½•æ‰©å¤§å•ä¸ªæ–‡ä»¶çš„å¤§å°ä¸Šé™ï¼Ÿ è¦æ±‚æˆ‘ä»¬æ‰©å¤§å•ä¸ªæ–‡ä»¶çš„å¤§å°ï¼Œå®ç°æœºåˆ¶å°±æ˜¯é€šè¿‡ä¿®æ”¹inodeçš„å—ç´¢å¼•ï¼Œå°†åŸæ¥çš„12ä¸ªç›´æ¥ç´¢å¼•å’Œä¸€ä¸ªä¸€çº§é—´æ¥ç´¢å¼•å˜ä¸º11ä¸ªç›´æ¥ç´¢å¼•ã€ä¸€ä¸ªä¸€çº§é—´æ¥ç´¢å¼•å’Œä¸€ä¸ªäºŒçº§é—´æ¥ç´¢å¼•ã€‚\nåœ¨xv6ä¸­ï¼Œä¸€ä¸ªæ•°æ®å—çš„å¤§å°ä¸º1KBï¼Œç”±äºé—´æ¥å—ä¸­å­˜æ”¾çš„æ˜¯ä¸‹ä¸€ä¸ªå—çš„åœ°å€ï¼ˆå…¶å®ä¸ªäººè®¤ä¸ºæ›´å‡†ç¡®çš„è¯´æ˜¯å—å·ï¼‰ï¼Œä½¿ç”¨çš„ç±»å‹æ˜¯uintï¼Œé‚£ä¹ˆä¸€ä¸ªé—´æ¥å—èƒ½å­˜æ”¾è¿™æ ·çš„åœ°å€å…±1KB / sizeof(uint) = 1KB / 4B = 256ä¸ªã€‚\nè¿™æ ·çš„è¯ï¼Œå•ä¸ªæ–‡ä»¶å¤§å°æœ€å¤§ä¸º12 * 1KB + 256 * 1KB = 268KBå˜ä¸ºäº†11 * 1KB + 256 * 1KB + 256 * 256 * 1KB = 65803KBã€‚\nä¿®æ”¹inodeç»“æ„ä½“ å…¶æ•°æ®å—åœ°å€ä¸­ï¼šæœ‰11ä¸ªç›´æ¥å—åœ°å€ï¼Œ1ä¸ªä¸€çº§é—´æ¥å—åœ°å€ï¼Œ1ä¸ªäºŒçº§é—´æ¥å—åœ°å€\nåœ¨åŸæœ¬çš„ä»£ç ä¸­ï¼Œè¡¨ç¤ºç›´æ¥å—æ•°é‡çš„å®ä¸ºNDIRECTï¼Œå…¶å®šä¹‰åœ¨fs.hä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹å…¶å€¼ä¸º11ï¼Œå¹¶ä¸”ç”±äºæˆ‘ä»¬æ‰©å¤§äº†æ–‡ä»¶å¤§å°ä¸Šé™ï¼Œæ‰€ä»¥ä¹Ÿè¦ä¿®æ”¹å¯¹åº”çš„å®MAXFILEï¼Œæ‰©å¤§åçš„åº”è¯¥ä¸ºï¼šNDIRECT + NINDIRECT + NINDIRECT * NINDIRECTï¼›åŒæ—¶è¿˜è¦ä¿®æ”¹inodeç»“æ„ä½“ï¼š\n// fs.h #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT) // On-disk inode structure struct dinode { short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT+2]; // Data block addresses }; å†…å­˜ä¸­ä¿å­˜çš„inodeç»“æ„ä½“ä¹Ÿéœ€è¦ä¿®æ”¹ï¼š\n// file.h // in-memory copy of an inode struct inode { uint dev; // Device number uint inum; // Inode number int ref; // Reference count struct sleeplock lock; // protects everything below here int valid; // inode has been read from disk? short type; // copy of disk inode short major; short minor; short nlink; uint size; uint addrs[NDIRECT+2]; }; ä¿®æ”¹bmapå‡½æ•° bmapå‡½æ•°ä¼šæ ¹æ®ä¼ å…¥å‚æ•°çš„æ•°æ®å—å·æ¥è¿”å›å…¶å¯¹åº”çš„åœ°å€\næˆ‘ä»¬åœ¨bmapä¸­çœ‹åˆ°å¦‚æœæ•°æ®å—è¿˜æ²¡æœ‰åˆ†é…çš„æ—¶å€™ï¼Œä¼šä½¿ç”¨ballocæ¥åˆ†é…ï¼Œå¹¶è¿”å›åˆ†é…çš„å—çš„å—å·ã€‚\nè¿™ä¸ªå‡½æ•°æˆ‘ä¸€å¼€å§‹çœ‹çš„æ—¶å€™å¯¹äºå¦‚ä½•åˆ†é…çš„æ¯”è¾ƒå¥‡æ€ªï¼Œåæ¥åœ¨AIçš„å¸®åŠ©ä¸‹æ…¢æ…¢ç†è§£äº†ã€‚åœ¨xv6ä¸­çš„ç¡¬ç›˜å¸ƒå±€æ˜¯è¿™æ ·çš„ï¼š\n[ boot block | super block | log | inode blocks | free bit map | data blocks] åœ¨å­¦ä¹ æ“ä½œç³»ç»Ÿæ—¶ï¼Œæˆ‘ä»¬æœ‰å­¦åˆ°è¿‡ä¸€ä¸ªå«ä½å›¾çš„ä¸œè¥¿ï¼Œå°†å¤šä¸ªå—åˆå¹¶ä½œä¸ºä¸€ä¸ªä½å›¾ï¼Œå…¶ä¸­çš„æ¯ä¸€ä½ï¼ˆbitï¼‰ç”¨æ¥å”¯ä¸€è¡¨ç¤ºä¸€ä¸ªæ•°æ®å—æ˜¯å¦è¢«ä½¿ç”¨äº†ï¼ˆä¾‹å¦‚0è¡¨ç¤ºä¸ºä½¿ç”¨ï¼Œ1è¡¨ç¤ºä½¿ç”¨ï¼‰ã€‚åœ¨xv6ä¸­ï¼Œæˆ‘ä»¬åœ¨éœ€è¦åˆ†é…æ•°æ®å—æ—¶ï¼Œä¼šå»ä½å›¾ä¸­å¯»æ‰¾å¯ç”¨çš„æ•°æ®å—çš„ç¼–å·ï¼Œåœ¨å»è·å–å¯¹åº”çš„æ•°æ®å—ï¼š\nstatic uint balloc(uint dev) { int b, bi, m; struct buf *bp; bp = 0; // æ–‡ä»¶ç³»ç»Ÿæ€»å…±æœ‰ 200000 ä¸ªå—ï¼ˆsb.size = 200000ï¼‰ï¼Œä¸”æ¯ä¸ªä½å›¾å—å¯ä»¥ç®¡ç† 8192 ä¸ªå—ï¼ˆBPB = 8192ï¼‰ // åœ¨ç¬¬ä¸€æ¬¡è¿­ä»£ä¸­ï¼Œb = 0ï¼Œè¯»å–ç®¡ç†ç¬¬ 0 åˆ°ç¬¬ 8191 ä¸ªå—çš„ä½å›¾å—ã€‚ // å†…å±‚å¾ªç¯éå†è¿™ 8192 ä¸ªå—ï¼Œå¯»æ‰¾ç©ºé—²å—ã€‚ // åœ¨ç¬¬äºŒæ¬¡è¿­ä»£ä¸­ï¼Œb = 8192ï¼Œè¯»å–ç®¡ç†ç¬¬ 8192 åˆ°ç¬¬ 16383 ä¸ªå—çš„ä½å›¾å—ã€‚ for(b = 0; b \u0026lt; sb.size; b += BPB){ bp = bread(dev, BBLOCK(b, sb)); // è·å–åœ¨ç¬¬næ¬¡è¿­ä»£ä¸­ç®¡ç†ä¸€ä¸ªBPBå¤§å°çš„ä½å›¾å— // éå†è¿™ä¸ªä½å›¾å—ä¸­çš„æ¯ä¸€ä½ï¼Œæ‰¾åˆ°æœªä½¿ç”¨çš„å—å·å¹¶è¿”å› for(bi = 0; bi \u0026lt; BPB \u0026amp;\u0026amp; b + bi \u0026lt; sb.size; bi++){ m = 1 \u0026lt;\u0026lt; (bi % 8); if((bp-\u0026gt;data[bi/8] \u0026amp; m) == 0){ // Is block free? bp-\u0026gt;data[bi/8] |= m; // Mark block in use. log_write(bp); brelse(bp); bzero(dev, b + bi); return b + bi; } } brelse(bp); } printf(\u0026#34;balloc: out of blocks\\n\u0026#34;); return 0; } è¦å®ç°å¤§æ–‡ä»¶çš„bmapï¼Œæˆ‘ä»¬å¯ä»¥ä»¿ç…§åŸæœ¬çš„bmapæ˜¯å¦‚ä½•å¤„ç†ä¸€çº§é—´æ¥å—çš„ï¼š\nstatic uint bmap(struct inode *ip, uint bn) { ... // å—å·ï¼ˆbnï¼‰å‡å»11ä¸ªï¼Œè¿™æ ·æ˜¯ä¸ºäº†æ–¹ä¾¿ä¹‹åå¯ä»¥æŒ‰åç§»å€¼ä¸º0å¼€å§‹è®¡ç®— bn -= NDIRECT; // å¦‚æœbnè¶…å‡ºäº†11ä¸ªï¼Œä¹Ÿå°±è¯´æ˜éœ€è¦é€šè¿‡ä¸€çº§é—´æ¥å—å»è·å– if(bn \u0026lt; NINDIRECT){ // Load indirect block, allocating if necessary. // ip-\u0026gt;addrs[11]ä»£è¡¨äº†ä¸€çº§é—´æ¥å—çš„åœ°å€ if((addr = ip-\u0026gt;addrs[NDIRECT]) == 0){ // æ­¤æ—¶è¿˜æœªåˆ†é…ä¸€çº§é—´æ¥å—ï¼Œåˆ†é… addr = balloc(ip-\u0026gt;dev); if(addr == 0) return 0; ip-\u0026gt;addrs[NDIRECT] = addr; } // ä»ç¡¬ç›˜ä¸­è¯»å‡ºè¿™ä¸ªå— bp = bread(ip-\u0026gt;dev, addr); // è·å–è¿™ä¸ªå—ä¸­çš„æ•°æ®ï¼ˆä¸è¿‡è¿™é‡Œåªæ˜¯é€šè¿‡æŒ‡é’ˆæ¥æ›´å¥½çš„æ“ä½œï¼‰ a = (uint*)bp-\u0026gt;data; if((addr = a[bn]) == 0){ // å¦‚æœè¿˜æ²¡æœ‰åˆ†é…bnæ‰€è¡¨ç¤ºçš„æ•°æ®å—ï¼Œåˆ†é… addr = balloc(ip-\u0026gt;dev); if(addr){ a[bn] = addr; log_write(bp); } } brelse(bp); return addr; } ... } åŒæ ·çš„ï¼ŒäºŒçº§é—´æ¥å—ä¹Ÿæ˜¯ç±»ä¼¼çš„æ“ä½œæ‰‹æ³•ï¼š\nstatic uint bmap(struct inode *ip, uint bn) { ... // å¦‚æœbnè¶…å‡ºäº†11ä¸ªï¼Œä¹Ÿå°±è¯´æ˜éœ€è¦é€šè¿‡ä¸€çº§é—´æ¥å—å»è·å– if(bn \u0026lt; NINDIRECT){ ... } // å¦‚æœè¿è¡Œåˆ°äº†è¿™é‡Œï¼Œè¯´æ˜è¦ä»äºŒçº§é—´æ¥å—ä¸­å¯»æ‰¾ï¼Œè¿™é‡Œå‡å»NINDIRECTï¼ˆ256ï¼‰ä¹Ÿæ˜¯åƒä¹‹å‰ä¸€æ ·æ–¹ä¾¿è®¡ç®— bn -= NINDIRECT; // ä»äºŒçº§é—´æ¥å—ä¸­æ‰¾ if (bn \u0026lt; NINDIRECT * NINDIRECT) { // inodeçš„äºŒçº§é—´æ¥å—è¿˜æœªåˆ†é… if ((addr = ip-\u0026gt;addrs[NDIRECT + 1]) == 0) { addr = balloc(ip-\u0026gt;dev); if(addr == 0) return 0; ip-\u0026gt;addrs[NDIRECT + 1] = addr; } int level1 = bn / NINDIRECT; int level2 = bn % NINDIRECT; // è¯»å–äºŒçº§é—´æ¥å— bp = bread(ip-\u0026gt;dev, addr); a = (uint *)bp-\u0026gt;data; if ((addr = a[level1]) == 0){ a[level1] = addr = balloc(ip-\u0026gt;dev); log_write(bp); // ä¿®æ”¹äº†å°±è¦è®°å½•æ—¥å¿— } brelse(bp); bp = bread(ip-\u0026gt;dev, addr); a = (uint *)bp-\u0026gt;data; if ((addr = a[level2]) == 0) { a[level2] = addr = balloc(ip-\u0026gt;dev); log_write(bp); // ä¿®æ”¹äº†å°±è¦è®°å½•æ—¥å¿— } brelse(bp); return addr; } } å¤šçš„æ­¥éª¤å°±æ˜¯äºŒçº§é—´æ¥ç´¢å¼•éœ€è¦å¤šä¸€æ¬¡è¯»å–æ•°æ®å—å’ŒæŸ¥æ‰¾ï¼š\nå‡è®¾ä¼ å…¥bmapçš„å—å·ä¸º524ï¼Œé‚£ä¹ˆå…¶ä¸åœ¨ç›´æ¥å—ä¸­ï¼Œä¹Ÿä¸åœ¨ä¸€çº§é—´æ¥å—ä¸­ï¼Œè€Œæ˜¯åœ¨äºŒçº§é—´æ¥å—ä¸­ã€‚é€šè¿‡bmapä¸­çš„å‰ä¸¤ä¸ªifä¹‹åå¯¹äºbnçš„å‡æ³•æ“ä½œï¼Œæ­¤æ—¶çš„bn = 524 - 11 - 256 = 257ã€‚é‚£ä¹ˆåœ¨äºŒçº§é—´æ¥å—çš„ç¬¬ä¸€å±‚ä¸­ï¼ˆlevel1ï¼‰ï¼Œç´¢å¼•ä¸º257 / 256 = 1ï¼Œåœ¨ç¬¬äºŒå±‚ä¸­ï¼ˆlevel2ï¼‰ç´¢å¼•ä¸º257 % 256 = 1 ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nSymbolic links é¦–å…ˆè¦ææ¸…æ¥šè½¯ç¡¬é“¾æ¥çš„åŒºåˆ«ï¼š\nè½¯é“¾æ¥ï¼ˆç¬¦å·é“¾æ¥ï¼‰ï¼š è½¯é“¾æ¥æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œå®ƒåŒ…å«æŒ‡å‘å¦ä¸€ä¸ªæ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ã€‚å®ƒç±»ä¼¼äºWindowsä¸­çš„å¿«æ·æ–¹å¼ã€‚ å­˜å‚¨çš„æ˜¯ç›®æ ‡æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ä¿¡æ¯ã€‚ ç¡¬é“¾æ¥ï¼š ç¡¬é“¾æ¥æ˜¯æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ™®é€šæ–‡ä»¶åï¼Œåªæ˜¯å®ƒä¸å…¶ä»–æ–‡ä»¶åæŒ‡å‘åŒä¸€ä¸ªç‰©ç†æ–‡ä»¶æ•°æ®å—ã€‚ å­˜å‚¨çš„æ˜¯ç›®æ ‡æ–‡ä»¶çš„æ•°æ®æœ¬èº«ï¼Œä¸åŒ…å«è·¯å¾„ä¿¡æ¯ã€‚ é‚£ä¹ˆè¦æˆ‘ä»¬å®ç°è½¯é“¾æ¥ï¼Œæˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…æœ‰ä¸¤ä¸ªï¼š\nå®ç°è½¯é“¾æ¥çš„ç³»ç»Ÿè°ƒç”¨ å¤„ç†ä½¿ç”¨openæ‰“å¼€ä¸€ä¸ªè½¯é“¾æ¥æ–‡ä»¶ ç³»ç»Ÿè°ƒç”¨çš„å®ç° å®éªŒä¸­è®©æˆ‘ä»¬å®ç°çš„ç³»ç»Ÿè°ƒç”¨æ¥å—è¿ä¸ªå‚æ•°(char *target, char *path)ï¼Œå®ƒåœ¨pathå¤„åˆ›å»ºäº†ä¸€ä¸ªè½¯é“¾æ¥ï¼Œè¯¥é“¾æ¥æŒ‡å‘æ–‡ä»¶åä¸ºtargetçš„æ–‡ä»¶ã€‚\nå¦‚ä½•æ³¨å†Œç³»ç»Ÿè°ƒç”¨å•¥çš„è¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚\né¦–å…ˆæˆ‘ä»¬éœ€è¦å‡†å¤‡ä¸€äº›å®ï¼š\n// stat.h #define T_SYMLINK 4 // symbolic link // fcntl.h #define O_NOFOLLOW 0x800 å®ç°sys_symlinkç³»ç»Ÿè°ƒç”¨ï¼š\næˆ‘ä»¬åˆ›å»ºä¸€ä¸ªè½¯é“¾æ¥æ—¶éœ€è¦ä½¿ç”¨createæ–°å»ºä¸€ä¸ªinodeï¼Œå› ä¸ºè½¯é“¾æ¥ä¹Ÿæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼›ç„¶åè°ƒç”¨writeiå°†ç›®æ ‡è·¯å¾„çš„å­—ç¬¦ä¸²targetå†™å…¥è½¯é“¾æ¥æ–‡ä»¶çš„æ•°æ®å—ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯åœ¨å®Œæˆè¿™ä¸¤æ­¥ä¹‹åéœ€è¦ä½¿ç”¨iunlockput(ip)æ¥é‡Šæ”¾åœ¨createä¸­åŠ ä¸Šçš„é”ã€‚\nuint64 sys_symlink(void) { char target[MAXPATH], path[MAXPATH]; if (argstr(0, target, MAXPATH) \u0026lt; 0 || argstr(1, path, MAXPATH) \u0026lt; 0) { return -1; } begin_op(); // è½¯é“¾æ¥æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–‡ä»¶ï¼Œå…¶å­˜å‚¨çš„æ•°æ®ä¸ºç›®æ ‡æ–‡ä»¶çš„è·¯å¾„ä¿¡æ¯ï¼Œå› æ­¤æˆ‘ä»¬åœ¨åˆ›å»ºè½¯é“¾æ¥æ—¶éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„inode struct inode *ip = create(path, T_SYMLINK, 0, 0); if (ip == 0) { end_op(); return -1; } // å°†targetå­—ç¬¦ä¸²å†™å…¥inodeçš„ç¬¬ä¸€ä¸ªç›´æ¥å—ä¸­ if (writei(ip, 0, (uint64)target, 0, strlen(target)) \u0026lt; 0) { end_op(); return -1; } iunlockput(ip); end_op(); return 0; } å¤„ç†openä¸€ä¸ªè½¯é“¾æ¥çš„æƒ…å†µ è¿™é‡Œå¯èƒ½æ˜¯è¿™ä¸ªlabçš„ä¸€ä¸ªéš¾ç‚¹äº†ã€‚ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å¤„ç†è¿™æ ·çš„æƒ…å†µå‘¢ï¼Ÿ\nè¿˜è®°å¾—æˆ‘ä»¬åˆšåˆšå‡†å¤‡çš„ä¸€ä¸ªå®O_NOFOLLOWå—ï¼Œåœ¨Linuxä¸­ï¼Œå®ƒæœ‰è¿™æ ·äº›ç‰¹ç‚¹ï¼š\nç¬¦å·é“¾æ¥æ£€æŸ¥ï¼šå½“O_NOFOLLOWæ ‡å¿—è¢«è®¾ç½®æ—¶ï¼Œå¦‚æœæŒ‡å®šçš„æ–‡ä»¶åæ˜¯ä¸€ä¸ªè½¯é“¾æ¥ï¼Œæ‰“å¼€æ“ä½œå°†ä¸ä¼šè·Ÿéšè¿™ä¸ªé“¾æ¥ï¼Œè€Œæ˜¯ä¼šå¤±è´¥ï¼Œå¹¶è¿”å›ä¸€ä¸ªé”™è¯¯ã€‚ é”™è¯¯è¿”å›ï¼šå¦‚æœå°è¯•æ‰“å¼€ä¸€ä¸ªè½¯é“¾æ¥ï¼Œå¹¶ä¸”O_NOFOLLOWæ ‡å¿—è¢«è®¾ç½®ï¼Œç³»ç»Ÿä¼šè¿”å›ELOOPé”™è¯¯ï¼Œè¡¨ç¤ºé‡åˆ°äº†å¤ªå¤šçš„ç¬¦å·é“¾æ¥ã€‚ ç”¨é€”ï¼šè¿™ä¸ªæ ‡å¿—é€šå¸¸ç”¨äºå®‰å…¨ç›®çš„ï¼Œé˜²æ­¢åº”ç”¨ç¨‹åºæ— æ„ä¸­æ‰“å¼€ä¸€ä¸ªè½¯é“¾æ¥ï¼Œè¿™å¯èƒ½è¢«æ¶æ„ç”¨æˆ·ç”¨æ¥ç»•è¿‡å®‰å…¨é™åˆ¶ã€‚ ä¾‹å¦‚ï¼š\nint fd = open(\u0026#34;/path/to/symlink\u0026#34;, O_RDONLY | O_NOFOLLOW); å¦‚æœ/path/to/symlinkæ˜¯ä¸€ä¸ªè½¯é“¾æ¥ï¼Œè¿™ä¸ªè°ƒç”¨å°†å¤±è´¥ã€‚\næˆ‘ä»¬éœ€è¦åœ¨sys_openä¸­å¤„ç†ï¼šå½“éœ€è¦æ‰“å¼€çš„æ–‡ä»¶ç±»å‹æ˜¯è½¯é“¾æ¥ç±»å‹å¹¶ä¸”æ²¡æœ‰ä½¿ç”¨O_NOFOLLOWæ ‡å¿—æ—¶ï¼Œé€’å½’æ‰¾åˆ°æœ€ç»ˆçš„ç›®æ ‡æ–‡ä»¶ã€‚ä¸ºä»€ä¹ˆè¯´æ˜¯â€œé€’å½’â€å‘¢ï¼Œå› ä¸ºå¯èƒ½æœ‰è¿™æ ·ä¸€ç§æƒ…å†µï¼šä¸€ä¸ªè½¯é“¾æ¥æŒ‡å‘äº†å¦ä¸€ä¸ªè½¯é“¾æ¥ï¼Œç”šè‡³å¦‚æ­¤ä»¥å¾€ã€‚ä¸ºäº†é¿å…â€œå­å­å­™å­™æ— ç©·æ— å°½â€çš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦è®¾ç½®ä¸€ä¸ªé€’å½’å±‚æ•°çš„é™åˆ¶ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨å¾ªç¯æ¥ä»£æ›¿é€’å½’ã€‚\nuint64 sys_open(void) { ... if(ip-\u0026gt;type == T_DEVICE \u0026amp;\u0026amp; (ip-\u0026gt;major \u0026lt; 0 || ip-\u0026gt;major \u0026gt;= NDEV)){ ... } // æ–‡ä»¶çš„ç±»å‹æ˜¯è½¯é“¾æ¥ï¼Œä¸”æ²¡æœ‰ä½¿ç”¨O_NOFOLLOWæ ‡å¿—ï¼Œå°±é€’å½’åœ°æŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æœ€ç»ˆçš„ç›®æ ‡æ–‡ä»¶çš„inode // å¦åˆ™ï¼Œå°±å½“ä½œæ˜¯æ­£å¸¸çš„æ–‡ä»¶è¿›è¡Œæ‰“å¼€ if (ip-\u0026gt;type == T_SYMLINK \u0026amp;\u0026amp; !(omode \u0026amp; O_NOFOLLOW)) { // å¦‚æœå¾ªç¯10æ¬¡åæ‰¾åˆ°çš„æ–‡ä»¶ç±»å‹è¿˜æ˜¯è½¯é“¾æ¥ï¼Œé‚£ä¹ˆè¯´æ˜æœ‰é”™è¯¯äº† for (int i = 0; i \u0026lt; 10; i++) { // ä»è½¯é“¾æ¥æ–‡ä»¶çš„inodeä¸­è¯»å–ç›®æ ‡æ–‡ä»¶çš„è·¯å¾„å­—ç¬¦ä¸² // æ³¨æ„ï¼Œåœ¨è¿™ä¸€æ­¥ä¹‹å‰å·²ç»å¯¹ipä¸Šé”ï¼Œå› æ­¤è¿™é‡Œæ“ä½œå®Œåéœ€è¦è§£é” if (readi(ip, 0, (uint64)path, 0, strlen(path)) \u0026lt; 0) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); ip = namei(path); if (ip == 0) { end_op(); return -1; } ilock(ip); if (ip-\u0026gt;type != T_SYMLINK) { break; } } if (ip-\u0026gt;type == T_SYMLINK) { iunlockput(ip); end_op(); return -1; } } if((f = filealloc()) == 0 || (fd = fdalloc(f)) \u0026lt; 0){ ... } ... } Code Detail ä»£ç å®ç°è¯¦æƒ…è¯·è§Githubï¼š\nLarge files Symbolic links Reference https://pdos.csail.mit.edu/6.S081/2023/labs/fs.html https://xv6.dgs.zone/labs/answers/lab9.html Summary æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªæœ‰æ„æ€çš„ä¸œè¥¿ï¼ŒåŒæ—¶ä¹Ÿå¾ˆå¤æ‚ï¼Œxv6ä¸­è®¾è®¡äº†ä¸€ä¸ªç®€åŒ–çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶é‡‡ç”¨äº†åˆ†å±‚çš„è®¾è®¡ã€‚è™½ç„¶è¿™é‡Œå°†å®éªŒåšå®Œäº†ï¼Œä½†æ˜¯æˆ‘è§‰å¾—è‡ªå·±è¿˜æœ‰å¾ˆå¤šç»†èŠ‚æ²¡æœ‰ææ‡‚ã€‚ä¾‹å¦‚å…¶ä¸­çš„æ—¥å¿—å±‚ï¼Œå…¶æ˜¯å¦‚ä½•å®ç°crashä¹‹åèƒ½æ¢å¤è¿‡æ¥çš„ä»£ç æ˜¯å¦‚ä½•è®¾è®¡ç¼–å†™çš„ï¼Œè¿˜æœ‰å…¶ä¸­çš„é”çš„è·å–ä¸é‡Šæ”¾ç­‰ç­‰ã€‚å¸Œæœ›ä¹‹åèƒ½ç»“åˆå®é™…å†åˆ†æåˆ†æã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab9-file-system/","summary":"\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003eåœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œæˆ‘ä»¬éœ€è¦è®©xv6æ”¯æŒæ›´å¤§çš„æ–‡ä»¶å’Œè½¯é“¾æ¥ã€‚å®éªŒæ€»ä½“ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä¸è¿‡éœ€è¦æˆ‘ä»¬ç†è§£å¥½æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚\u003ccode\u003eLab8 lock\u003c/code\u003eä¸­çš„Buffer Cacheä¹Ÿæ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œä¸è¿‡å®ƒä½äºæ–‡ä»¶ç³»ç»Ÿçš„ä¸‹å±‚ï¼Œè¿™é‡Œæˆ‘ä»¬éœ€è¦å¤„ç†çš„æ›´å¤šåœ¨ä¸Šå±‚ï¼Œååº”ç”¨å±‚ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab9 file system"},{"content":"Intro è¿™ä¸ªå®éªŒä¸ªäººæ„Ÿè§‰æŒºéš¾çš„ï¼Œéœ€è¦æˆ‘ä»¬é‡æ–°è®¾è®¡æ•°æ®ç»“æ„ï¼Œè¿˜è¦è€ƒè™‘åœ¨å¹¶å‘ï¼ˆå¹¶è¡Œï¼‰æƒ…å†µä¸‹å¯¹äºé”çš„æ“ä½œï¼Œä»¥å‡å°‘å¤šæ ¸æƒ…å†µä¸‹å¯¹äºé”çš„ç«äº‰ã€‚å…¶ä¸­ä¸»è¦æ¶‰åŠå†…å­˜åˆ†é…å’ŒIOç¼“å†²å—åˆ†é…ï¼Œåœ¨è¿™ä¸ªlabä¹‹å‰ï¼Œxv6å¯¹äºè¿™ä¸¤ä¸ªåˆ†é…éƒ½æ˜¯ä½¿ç”¨çš„å…¨å±€å¯¹è±¡ï¼Œå¹¶åªæœ‰ä¸€æŠŠå…¨å±€é”è¿›è¡Œæ“ä½œï¼Œè¿™æ ·çš„è¯åœ¨å¹¶è¡Œæƒ…å†µä¸‹é”çš„ç«äº‰æ˜¯å¾ˆæ¿€çƒˆçš„ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯é‡æ–°è®¾è®¡è¿™ä¸¤ä¸ªåˆ†é…å™¨ï¼Œå®ƒä»¬çš„é‡æ„æ€è·¯å¹¶ä¸å®Œå…¨ä¸€è‡´ï¼Œéœ€è¦å…·ä½“é—®é¢˜å…·ä½“åˆ†æã€‚\nMemory Allocator åœ¨xv6ä¸­ï¼Œå†…å­˜é€šè¿‡kalloc()æ¥åˆ†é…ï¼Œåœ¨å…¶å†…éƒ¨ï¼Œä¼šä½¿ç”¨ä¸€ä¸ªkmemçš„ç»“æ„ä½“å˜é‡ï¼š\n// kernel/kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; kmem.freelistä¿å­˜ç€æœªä½¿ç”¨çš„å†…å­˜å—ï¼ˆæ¯å—å¤§å°ä¸º4KBï¼‰ï¼Œåœ¨å†…æ ¸åˆå§‹åŒ–æ—¶ï¼Œä¼šé€šè¿‡kinit()å°†åœ°å€KERNBASE ~ PHYSTOPçš„ç‰©ç†å†…å­˜ï¼ˆä¸€å…±128MBï¼‰æ”¾å…¥freelistä¸­ï¼š\nvoid kinit() { initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); freerange(end, (void*)PHYSTOP); // endä¸ºkernel.ldä¸­å®šä¹‰çš„ï¼Œå€¼ä¸º0x80000000ï¼Œå³KERNBASE } void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE \u0026lt;= (char*)pa_end; p += PGSIZE) kfree(p); // ä½¿ç”¨kfreeå°†å†…å­˜å—æ”¾å…¥freelistä¸­ } é€šè¿‡ä¸Šé¢çš„æºç åˆ†ææˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ•´ä¸ªxv6å†…æ ¸éƒ½æ˜¯é€šè¿‡ä¸€ä¸ªå…¨å±€çš„kmemæ¥åˆ†é…å’Œå›æ”¶å†…å­˜å—ï¼Œé‚£ä¹ˆå¦‚æœå½“å¤šä¸ªCPUï¼ˆå¤šä¸ªcoreï¼‰éœ€è¦æ“ä½œå†…å­˜å—æ—¶ï¼Œå°±å¿…é¡»å¾—ç”¨é”æ‰èƒ½ä¿è¯æ•´ä½“çš„ç¨³å®šå’Œæ­£ç¡®ã€‚\nä½†æ˜¯è¿™æ ·åšåˆä¼šæœ‰ä¸€ä¸ªå¤§é—®é¢˜ï¼Œé‚£å°±æ˜¯ä¸€ä¸ªcpuåœ¨æ“ä½œkmemæ—¶ï¼Œå¦ä¸€ä¸ªCPUå³ä¾¿æƒ³è·å–å†…å­˜å—æˆ–é‡Šæ”¾å†…å­˜å—ï¼Œå› ä¸ºé”çš„ç¼˜æ•…ä¹Ÿåªèƒ½ç­‰å¾…ã€‚æ•…æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆæ˜¯ä¸ºæ¯ä¸ªCPUéƒ½è®¾ç½®ä¸€ä¸ªkmemï¼Œè¿™æ ·ï¼Œå“ªä¸ªCPUéœ€è¦æ“ä½œå†…å­˜å—æ—¶å°±å¯ä»¥åªé”ä¸Šå®ƒè‡ªå·±çš„kmemï¼Œå…¶ä»–CPUå—åˆ°çš„å¹²æ‰°ä¼šå¤§å¤§å‡å°‘ã€‚\nä¸ºä»€ä¹ˆè¯´æ˜¯å¤§å¤§å‡å°‘è€Œä¸æ˜¯å®Œå…¨å‡å°‘å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºå½“æŸä¸ªCPUçš„kmem.freelistä¸­æ²¡æœ‰å¯åˆ†é…çš„å†…å­˜å—æ—¶ï¼Œéœ€è¦å»å…¶ä»–CPUçš„kmem.freelistä¸­å»æ‹¿ä¸€ä¸ªè¿‡æ¥ï¼Œè¿™æ—¶å°±éœ€è¦å¤„ç†å¥½è¿™ä¸¤ä¸ªCPUçš„é”çš„å¤„ç†äº†ã€‚\nstruct { struct spinlock lock; struct run *freelist; char lock_name[8]; // æ¯ä¸ªkmemçš„é”çš„åç§° } kmem[NCPU]; // ä¸ºæ¯ä¸ªCPUéƒ½è®¾ç½®ä¸€ä¸ªkmem void kinit() { // åˆå§‹åŒ–æ—¶è¦å¯¹æ¯ä¸ªkmeméƒ½åˆå§‹é” for (int i = 0; i \u0026lt; NCPU; i++) { initlock(\u0026amp;kmem[i].lock, \u0026#34;kmem\u0026#34;); snprintf(kmem[i].lock_name, sizeof(kmem[i].lock_name), \u0026#34;kmem%d\u0026#34;, i); } // è¿™é‡Œä¼šå…ˆå°†æ‰€æœ‰å†…å­˜å—éƒ½åˆ†é…ç»™kmem[0]ï¼Œå› ä¸ºå†…æ ¸å¯åŠ¨æ—¶æ˜¯cpus[0]åœ¨åšåˆå§‹åŒ–æ“ä½œ // ä¹‹åå…¶ä»–CPUéœ€è¦å†…å­˜å—æ—¶ï¼Œä»cpus[0]è¿™é‡Œæ‹¿ freerange(end, (void*)PHYSTOP); } void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; // ---------------------------------------- // kfreeæ—¶åªéœ€è¦å°†å†…å­˜å—æ”¾åˆ°è‡ªå·±æ‰€å±cpuçš„kmem.freelistä¸­ push_off(); int cid = cpuid(); acquire(\u0026amp;kmem[cid].lock); r-\u0026gt;next = kmem[cid].freelist; kmem[cid].freelist = r; release(\u0026amp;kmem[cid].lock); pop_off(); // ---------------------------------------- } void * kalloc(void) { struct run *r; // ---------------------------------------- push_off(); int cid = cpuid(); acquire(\u0026amp;kmem[cid].lock); r = kmem[cid].freelist; if (r) { // å¦‚æœå½“å‰çš„freelistä¸­è¿˜æœ‰å†…å­˜å—ï¼Œåˆ™ç›´æ¥ç”¨ kmem[cid].freelist = r-\u0026gt;next; } else { // æ²¡æœ‰ï¼Ÿé‚£å°±æ‹¿ï¼ // éå†ä¸€ä¸‹å…¶ä»–CPUçš„kmemï¼Œå¦‚æœæ‰¾åˆ°çš„freelistä¸­è¿˜æœ‰å†…å­˜å—ï¼Œå°±æ‹¿å®ƒçš„ for (int next_cid = 0; next_cid \u0026lt; NCPU; next_cid++) { // ä¸æ‰¾è‡ªå·± if (next_cid == cid) continue; acquire(\u0026amp;kmem[next_cid].lock); r = kmem[next_cid].freelist; if (r) { kmem[next_cid].freelist = r-\u0026gt;next; release(\u0026amp;kmem[next_cid].lock); break; } release(\u0026amp;kmem[next_cid].lock); } } release(\u0026amp;kmem[cid].lock); pop_off(); // ---------------------------------------- if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } Buffer Cache å…ˆä»‹ç»ä¸‹å®éªŒåˆå§‹çš„bcacheï¼š\nstruct { struct spinlock lock; struct buf buf[NBUF]; // Linked list of all buffers, through prev/next. // Sorted by how recently the buffer was used. // head.next is most recent, head.prev is least. struct buf head; } bcache; struct spinlock lockï¼šbcacheçš„å…¨å±€é” struct buf buf[NBUF]ï¼šç¼“å†²å—æ± ï¼Œå³åŒ…å«äº†æ‰€æœ‰çš„buffer cache struct buf headï¼šä¸€ä¸ªLRUé“¾è¡¨ï¼Œç”¨äºæ“ä½œç¼“å†²å—ï¼Œä½¿ç”¨head.nextè·å–çš„æ˜¯æœ€è¿‘åˆšä½¿ç”¨è¿‡çš„bufferï¼Œhead.prevè·å–çš„æ˜¯æœ€è¿‘æœªä½¿ç”¨æ—¶é—´æœ€ä¹…çš„bufferï¼ˆæˆ–è€…è¯´æ˜¯æœªè¢«ä½¿ç”¨çš„bufferï¼Œå³å¼•ç”¨è®¡æ•°ä¸º0ï¼‰ åŸæ¥çš„bcacheä¸­çš„bufæ•°ç»„åœ¨binitæ—¶å°±ç»™LRUé“¾è¡¨åˆå§‹åŒ–ç”¨äº†ï¼š\nvoid binit(void) { struct buf *b; initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); // Create linked list of buffers bcache.head.prev = \u0026amp;bcache.head; bcache.head.next = \u0026amp;bcache.head; for(b = bcache.buf; b \u0026lt; bcache.buf+NBUF; b++){ b-\u0026gt;next = bcache.head.next; b-\u0026gt;prev = \u0026amp;bcache.head; initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); bcache.head.next-\u0026gt;prev = b; bcache.head.next = b; } } è€Œè¿™æ ·è®¾è®¡çš„buffer cacheæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œç”±äºbuffer cacheåªæœ‰ä¸€ä¸ªå…¨å±€é”ï¼Œå½“åœ¨é«˜å¹¶å‘çš„æƒ…å†µä¸‹ï¼Œè¿›ç¨‹éœ€è¦å¹¶å‘è®¿é—®bcacheæ—¶ï¼Œæ— æ³•è¾¾åˆ°å¤šè¿›ç¨‹å¸¦æ¥çš„ä¼˜åŠ¿ï¼Œä¸€ä¸ªè¿›ç¨‹å¿…é¡»è¦å…ˆç­‰å‰ä¸€ä¸ªè¿›ç¨‹é‡Šæ”¾é”åæ‰å¯ä»¥æ“ä½œã€‚\nè€ƒè™‘å‰ä¸€ä¸ªå®éªŒä¸­çš„kallocï¼Œæˆ‘ä»¬èƒ½å¦ä¹Ÿä½¿ç”¨é‚£æ ·çš„ç­–ç•¥ï¼Ÿ\nReducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won\u0026rsquo;t work for the block cache.\nä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´å‘¢ï¼Ÿæ˜¯å› ä¸ºblock cacheå¹¶ä¸åƒå†…å­˜é¡µé‚£æ ·å…·æœ‰é€šç”¨æ€§ã€‚block cacheå¯¹åº”ç€çœŸå®çš„ç‰©ç†å¤–å­˜å—ï¼Œæ¯ä¸€ä¸ªCPUéƒ½å¯èƒ½ä½¿ç”¨åŒä¸€ä¸ªblock cacheï¼Œæ‰€ä»¥æ— æ³•åƒkallocä¸­é‚£æ ·ä¸ºæ¯ä¸ªCPUåˆ†é…å…¶å¯¹åº”çš„cacheã€‚\næ—¢ç„¶æˆ‘ä»¬æ— æ³•åˆ†åˆ«ä¸ºæ¯ä¸ªCPUåˆ†é…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¢ä¸€ä¸ªè§’åº¦ï¼Œå¯¹æ‰€æœ‰çš„blockå—è¿›è¡Œåˆ†ç»„ï¼šæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå“ˆå¸Œæ¡¶hash bucketsï¼ˆè¿™é‡Œä½¿ç”¨çš„å®¹é‡ä¸º13ï¼‰ï¼Œé‚£ä¹ˆå¯¹æ¯ä¸ªblockå—çš„å—å·è¿›è¡Œå–ä½™æ“ä½œï¼ˆmod 13ï¼‰å³å¯å°†å®ƒä»¬æ˜ å°„åˆ°å…¶ä¸­ä¸€ä¸ªå“ˆå¸Œæ¡¶ä¸­ã€‚è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ ‡å·ä¸ºblocknoçš„å—æ—¶ï¼Œåˆ°å…¶æ˜ å°„çš„å“ˆå¸Œæ¡¶ä¸­å»å¯»æ‰¾å³å¯ï¼Œå¹¶ä¸”ï¼Œåœ¨å¹¶å‘æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¸Šé”çš„å•ä½ä»æ•´ä¸ªbcacheå˜ä¸ºäº†å…¶ä¸­çš„ä¸€ä¸ªæ¡¶ï¼Œé”çš„ç²’åº¦å¤§å¤§å‡å°äº†ã€‚\né‚£ä¹ˆæˆ‘ä»¬ä¿®æ”¹ä¸€ä¸‹bcacheçš„æ•°æ®ç»“æ„ï¼š\n#define NBUCKET 13 #define BLOCK_HASH(blockno) (blockno % NBUCKET) struct { struct spinlock g_lock; // å…¨å±€é”ï¼Œè¿™é‡Œç›¸è¾ƒä¹‹å‰åªæ˜¯æ”¹äº†ä¸ªåå­— struct buf buf[NBUF]; struct spinlock bk_lock[NBUCKET]; // æ¯ä¸ªhash bucketéƒ½å¯¹åº”æœ‰ä¸€æŠŠé” struct buf bucket[NBUCKET]; // hash bucket int size; // ç¼“å†²å—æ± ï¼ˆbuf[NBUF]ï¼‰ä¸­å·²ä½¿ç”¨çš„å—æ•° } bcache; æˆ‘ä»¬åœ¨é‡æ„çš„æ–¹æ¡ˆä¸­ï¼Œä¸å†ä½¿ç”¨LRUé“¾è¡¨ï¼Œä½†è¿˜æ˜¯ä½¿ç”¨äº†LRUç®—æ³•çš„æ€æƒ³ï¼Œåªæ˜¯ç”¨æ—¶é—´æˆ³æ¥ä»£æ›¿LRUé“¾è¡¨ï¼š\nstruct buf { int valid; // has data been read from disk? int disk; // does disk \u0026#34;own\u0026#34; buf? uint dev; uint blockno; struct sleeplock lock; uint refcnt; // struct buf *prev; // LRU cache list struct buf *next; uchar data[BSIZE]; uint timestamp; }; è¿™ä¸ªæ—¶é—´æˆ³é€šè¿‡ä¸€ä¸ªå…¨å±€å˜é‡ticksï¼ˆtrap.cï¼‰æ¥è·å–ï¼š\nextern uint ticks; é‚£ä¹ˆåœ¨åˆå§‹åŒ–bcacheæ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦åˆå§‹åŒ–å…¶ä¸­çš„é”å’Œbcache.sizeå³å¯ï¼š\nvoid binit(void) { struct buf *b; bcache.size = 0; initlock(\u0026amp;bcache.g_lock, \u0026#34;bcache\u0026#34;); for (int i = 0; i \u0026lt; NBUCKET; i++) { initlock(\u0026amp;bcache.bk_lock[i], \u0026#34;bk_lock\u0026#34;); } for(b = bcache.buf; b \u0026lt; bcache.buf+NBUF; b++){ initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); } } ç”±äºæˆ‘ä»¬å¯¹äºé”çš„æ“ä½œå•ä½å˜ä¸ºäº†bucketï¼Œæ‰€ä»¥ä¸‹é¢ä¸¤ä¸ªå‡½æ•°ä¹Ÿéœ€è¦ä¿®æ”¹ï¼š\nvoid bpin(struct buf *b) { int idx = BLOCK_HASH(b-\u0026gt;blockno); acquire(\u0026amp;bcache.bk_lock[idx]); b-\u0026gt;refcnt++; release(\u0026amp;bcache.bk_lock[idx]); } void bunpin(struct buf *b) { int idx = BLOCK_HASH(b-\u0026gt;blockno); acquire(\u0026amp;bcache.bk_lock[idx]); b-\u0026gt;refcnt--; release(\u0026amp;bcache.bk_lock[idx]); } åœ¨åŸå…ˆçš„é‡Šæ”¾bufferå—çš„brelse(struct buf *b)å‡½æ•°ä¸­ï¼Œä¼šå…ˆå¯¹bçš„å¼•ç”¨è®¡æ•°-1ï¼Œå½“å…¶å€¼ä¸º0æ—¶ï¼Œå°†å…¶è½¬ç§»è‡³LRUé“¾è¡¨çš„head-\u0026gt;prevä½ç½®ï¼Œè¯´æ˜è¿™ä¸ªbufferæ²¡æœ‰è¢«ä»»ä½•è¿›ç¨‹ä½¿ç”¨äº†ã€‚è€Œåœ¨é‡æ„æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨æ—¶é—´æˆ³ä»£æ›¿äº†LRUé“¾è¡¨ï¼Œæ¯ä¸ªbucketä¸­æˆ‘ä»¬å¹¶æ²¡æœ‰ç»´æŠ¤ä¸€ä¸ªLRUé“¾è¡¨ï¼Œè€Œæ˜¯è®¤ä¸ºå¼•ç”¨è®¡æ•°ä¸º0ä¸”æ—¶é—´æˆ³æœ€å°çš„çš„bufferæ˜¯æ²¡æœ‰è¢«ä»»ä½•è¿›ç¨‹ä½¿ç”¨çš„ï¼Œæ•…åœ¨å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œåªéœ€è¦æ›´æ–°bufferçš„æ—¶é—´æˆ³å³å¯ï¼š\nvoid brelse(struct buf *b) { if(!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;brelse\u0026#34;); releasesleep(\u0026amp;b-\u0026gt;lock); int idx = BLOCK_HASH(b-\u0026gt;blockno); acquire(\u0026amp;bcache.bk_lock[idx]); b-\u0026gt;refcnt--; if (b-\u0026gt;refcnt == 0) { // no one is waiting for it. b-\u0026gt;timestamp = ticks; // æœªä½¿ç”¨çš„bufferçš„æ—¶é—´æˆ³ä¸€å®šæ˜¯æœ€å°çš„ } release(\u0026amp;bcache.bk_lock[idx]); } å¯¹äºbcacheæœ€é‡è¦çš„bget()å‡½æ•°ï¼Œæˆ‘ä»¬é‡æ„çš„æ€è·¯ä¸ºï¼š\næ£€æŸ¥æ ‡å·ä¸ºblocknoçš„å—çš„ç¼“å­˜æ˜¯å¦åœ¨cacheä¸­ï¼Œå¦‚æœåœ¨ï¼Œåˆ™å…¶å¼•ç”¨è®¡æ•°+1ï¼Œè¿”å›è¯¥ç¼“å­˜å— åœ¨ç¼“å­˜ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œå…ˆåœ¨ç¼“å†²å—æ± ä¸­å¯»æ‰¾è¿˜æœªåˆ†é…ç»™bucketçš„ç¼“å­˜å— å¦‚æœç¼“å†²å—æ± ä¸­éƒ½åˆ†é…å‡ºå»äº†ï¼Œå°±åˆ°æ¯ä¸ªbucketä¸­å»æ‰¾ã€‚å¦‚æœå½“å‰éå†çš„bucketä¸­æœ‰bufferçš„å¼•ç”¨è®¡æ•°ä¸º0ï¼Œæ‹¿åˆ°å…¶ä¸­æ—¶é—´æˆ³æœ€å°çš„bufferï¼ˆè¿™ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªbufferæ˜¯è·ç¦»ç°åœ¨æœ€ä¹…æ²¡æœ‰ä½¿ç”¨çš„åˆæ³•å—ï¼‰ å¦‚æœè¿™ä¸ªbufferåœ¨åŸå…ˆçš„bucketä¸­ï¼Œè¿”å›è¿™ä¸ªbuffer å¦åˆ™éœ€è¦å°†è¿™ä¸ªbufferä»å½“å‰bucketä¸­è½¬ç§»åˆ°ç›®æ ‡bucketä¸­ è¿™æ˜¯ä¸€ä¸ªå¤§è‡´çš„æ€è·¯ï¼Œå…·ä½“ç»†èŠ‚å‚è€ƒå¦‚ä¸‹ä»£ç ï¼š\nstatic struct buf* bget(uint dev, uint blockno) { struct buf *b; int bucket_idx = BLOCK_HASH(blockno); // å…ˆå¯¹blocknoå¯¹åº”çš„bucketä¸Šé”å³å¯ acquire(\u0026amp;bcache.bk_lock[bucket_idx]); // Is the block already cached? for(b = \u0026amp;bcache.bucket[bucket_idx]; b; b = b-\u0026gt;next){ if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;bcache.bk_lock[bucket_idx]); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } // åœ¨ç¼“å­˜ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œå…ˆåœ¨ç¼“å†²å—æ± ä¸­å¯»æ‰¾è¿˜æœªåˆ†é…ç»™bucketçš„ç¼“å­˜å— // éœ€è¦ä½¿ç”¨å…¨å±€é”æ¥ä¿è¯bcache.size++çš„åŸå­æ€§ // è¿™é‡Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆbufferæ—¶é—´æˆ³ä¸éœ€è¦åˆå§‹åŒ–çš„åŸå› ï¼šæ¯ä¸€æ¬¡éœ€è¦ä½¿ç”¨bufferæ—¶ï¼ˆä¼šè°ƒç”¨bgetï¼‰ï¼Œ // å¦‚æœbufferæ± ä¸­è¿˜æœ‰ç©ºé—²bufferï¼Œåˆ™ä¼šç›´æ¥ä½¿ç”¨è¿™ä¸ªbufferï¼Œå®Œæˆæ“ä½œåä¼šè°ƒç”¨releseé‡Šæ”¾bufferï¼Œæ­¤æ—¶å°±ä¼šæ›´æ–°bufferçš„æ—¶é—´æˆ³ acquire(\u0026amp;bcache.g_lock); if (bcache.size \u0026lt; NBUF) { struct buf *b = \u0026amp;bcache.buf[bcache.size++]; b-\u0026gt;next = bcache.bucket[bucket_idx].next; bcache.bucket[bucket_idx].next = b; b-\u0026gt;dev = dev; b-\u0026gt;blockno = blockno; b-\u0026gt;valid = 0; b-\u0026gt;refcnt = 1; release(\u0026amp;bcache.g_lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } release(\u0026amp;bcache.g_lock); // åœ¨è¿™æ—¶æ‰èƒ½é‡Šæ”¾è¯¥bucketçš„é”ï¼Œå‡è®¾åœ¨æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨åé‡Šæ”¾ï¼š // å¦‚æœæœ‰ä¸¤ä¸ªè¿›ç¨‹1å’Œ2ï¼Œæ­¤æ—¶ç¼“å†²å—æ± è¿˜æœ‰å¤šä¸ªæœªåˆ†é…çš„å—ï¼Œè¿›ç¨‹1æ£€æŸ¥bucketï¼Œå‘ç°æ²¡æœ‰ç¼“å­˜ï¼Œé‡Šæ”¾é”ï¼Œå‡†å¤‡å»ç¼“å†²å—æ± ä¸­æ‹¿ // æ­¤æ—¶åˆ‡æ¢åˆ°è¿›ç¨‹2ï¼Œè¿›ç¨‹2æ£€æŸ¥bucket,å‘ç°æ²¡æœ‰ç¼“å­˜ï¼Œä¹Ÿå»ç¼“å†²å—æ± ä¸­æ‹¿ // è¿™æ ·å°±ä¼šå¯¼è‡´bucketä¼šæ·»åŠ ä¸¤ä¸ªblocknoçš„ç¼“å†²å— release(\u0026amp;bcache.bk_lock[bucket_idx]); // åœ¨æ¯ä¸ªbucketä¸­å»æ‰¾å¯ç”¨çš„buffer cache for (int i = 0; i \u0026lt; NBUCKET; i++) { struct buf *cur_buf, *pre_buf, *min_buf, *min_pre_buf; uint min_timestamp = -1; acquire(\u0026amp;bcache.bk_lock[bucket_idx]); pre_buf = \u0026amp;bcache.bucket[bucket_idx]; cur_buf = pre_buf-\u0026gt;next; // éå†bcache.bucket[bucket_idx] while (cur_buf) { // ä¸ºä»€ä¹ˆè¿™é‡Œéœ€è¦é‡æ–°æ£€æŸ¥ï¼Ÿè€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µï¼š // å‡è®¾ç¼“å†²å—æ± ä¸­è¿˜æœ‰ä¸€ä¸ªæœªåˆ†é…çš„ï¼Œæ­¤æ—¶æœ‰ä¸¤ä¸ªè¿›ç¨‹ï¼Œè¿›ç¨‹1å’Œ2éƒ½éœ€è¦è®¿é—®åŒä¸€ä¸ªæ ‡å·blocknoçš„å— // è¿›ç¨‹1å…ˆæ‹¿åˆ°è¿™ä¸ªæœªåˆ†é…çš„ï¼Œå¹¶å°†å…¶æ”¾å…¥äº†å¯¹åº”çš„bucketä¸­ // ä¹‹åè¿›ç¨‹2å‘ç°æ± ä¸­æ²¡æœ‰æœªåˆ†é…çš„äº†ï¼Œå¼€å§‹éå†æ‰€æœ‰bucketï¼Œ // å¦‚æœè¿™æ—¶ä¸é‡æ–°æ£€æŸ¥ä¸€ä¸‹blocknoå¯¹åº”çš„bucketï¼Œåˆ™ä¼šå¯¼è‡´ä¸€ä¸ªbucketä¸­æœ‰ä¸¤ä¸ªblocknoçš„å— if (bucket_idx == BLOCK_HASH(blockno) \u0026amp;\u0026amp; cur_buf-\u0026gt;blockno == blockno \u0026amp;\u0026amp; cur_buf-\u0026gt;dev == dev) { cur_buf-\u0026gt;refcnt++; release(\u0026amp;bcache.bk_lock[bucket_idx]); acquiresleep(\u0026amp;cur_buf-\u0026gt;lock); return cur_buf; } // åªæœ‰å¼•ç”¨è®¡æ•°ä¸º0,å¹¶ä¸”æ—¶é—´æˆ³æœ€å°çš„ç¼“å†²å—æ‰å¯è¢«é‡æ–°åˆ†é… if (cur_buf-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; cur_buf-\u0026gt;timestamp \u0026lt; min_timestamp) { min_pre_buf = pre_buf; min_buf = cur_buf; min_timestamp = cur_buf-\u0026gt;timestamp; } pre_buf = cur_buf; cur_buf = cur_buf-\u0026gt;next; } // åœ¨æœ¬è½®ä¸­æ‰¾åˆ°äº†å¯é‡æ–°åˆ†é…çš„ç¼“å†²å— if (min_buf) { min_buf-\u0026gt;dev = dev; min_buf-\u0026gt;blockno = blockno; min_buf-\u0026gt;valid = 0; min_buf-\u0026gt;refcnt = 1; // æ˜¯è‡ªèº«bucketä¸­çš„ï¼Œä¸ç”¨åšè½¬ç§»æ“ä½œ if (bucket_idx == BLOCK_HASH(blockno)) { // release(\u0026amp;bcache.hash_lock); release(\u0026amp;bcache.bk_lock[bucket_idx]); acquiresleep(\u0026amp;min_buf-\u0026gt;lock); return min_buf; } // æ˜¯å…¶ä»–bucketä¸­çš„ï¼Œéœ€è¦è½¬ç§» // å…ˆå°†ç›®æ ‡bucketä¸­çš„bufferç§»é™¤ï¼Œç„¶åé‡Šæ”¾é” min_pre_buf-\u0026gt;next = min_buf-\u0026gt;next; release(\u0026amp;bcache.bk_lock[bucket_idx]); // æ¥ç€è·å–blocknoå¯¹åº”çš„é”ï¼Œå¹¶å°†ä»ç›®æ ‡bucketä¸­ç§»é™¤çš„bufferæ”¾è‡³blocknoå¯¹åº”çš„bucketï¼Œè¿”å›è¯¥buffer bucket_idx = BLOCK_HASH(blockno); acquire(\u0026amp;bcache.bk_lock[bucket_idx]); min_buf-\u0026gt;next = bcache.bucket[bucket_idx].next; bcache.bucket[bucket_idx].next = min_buf; release(\u0026amp;bcache.bk_lock[bucket_idx]); acquiresleep(\u0026amp;min_buf-\u0026gt;lock); return min_buf; } release(\u0026amp;bcache.bk_lock[bucket_idx]); // å¦‚æœåˆ°åº•äº†ï¼Œä»å¤´æ¥ï¼Œä¿è¯éå†æ¯ä¸€ä¸ªbucket if (++bucket_idx == NBUCKET) { bucket_idx = 0; } } panic(\u0026#34;bget: no buffers\u0026#34;); } bgetæ˜¯è¿™ä¸ªlabä¸­æœ€å¤æ‚çš„åœ°æ–¹ï¼Œå…¶å¤„ç†é€»è¾‘è™½ç„¶è¾ƒå¥½ç†è§£ï¼Œä½†æ˜¯å¤šä¸ªé”çš„æ“ä½œé¡ºåºå¾ˆè®©äººå¤´ç–¼ï¼Œéœ€è¦è€ƒè™‘åˆ°å¤šç§å¹¶å‘æƒ…å†µã€‚\nCode Details ä»£ç å®ç°è¯¦æƒ…è¯·è§Githubï¼šhttps://github.com/kerolt/xv6-labs-2023/commit/ccac48e8ae6b6dde3e7c747a77f4149232420901\nReference https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab8-locks.md https://blog.csdn.net/LostUnravel/article/details/121430900 ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/","summary":"\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003eè¿™ä¸ªå®éªŒä¸ªäººæ„Ÿè§‰æŒºéš¾çš„ï¼Œéœ€è¦æˆ‘ä»¬é‡æ–°è®¾è®¡æ•°æ®ç»“æ„ï¼Œè¿˜è¦è€ƒè™‘åœ¨å¹¶å‘ï¼ˆå¹¶è¡Œï¼‰æƒ…å†µä¸‹å¯¹äºé”çš„æ“ä½œï¼Œä»¥å‡å°‘å¤šæ ¸æƒ…å†µä¸‹å¯¹äºé”çš„ç«äº‰ã€‚å…¶ä¸­ä¸»è¦æ¶‰åŠå†…å­˜åˆ†é…å’ŒIOç¼“å†²å—åˆ†é…ï¼Œåœ¨è¿™ä¸ªlabä¹‹å‰ï¼Œxv6å¯¹äºè¿™ä¸¤ä¸ªåˆ†é…éƒ½æ˜¯ä½¿ç”¨çš„å…¨å±€å¯¹è±¡ï¼Œå¹¶åªæœ‰ä¸€æŠŠå…¨å±€é”è¿›è¡Œæ“ä½œï¼Œè¿™æ ·çš„è¯åœ¨å¹¶è¡Œæƒ…å†µä¸‹é”çš„ç«äº‰æ˜¯å¾ˆæ¿€çƒˆçš„ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯é‡æ–°è®¾è®¡è¿™ä¸¤ä¸ªåˆ†é…å™¨ï¼Œå®ƒä»¬çš„é‡æ„æ€è·¯å¹¶ä¸å®Œå…¨ä¸€è‡´ï¼Œéœ€è¦å…·ä½“é—®é¢˜å…·ä½“åˆ†æã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab8 lock"},{"content":"åœ¨åšthread labçš„æ—¶å€™ï¼Œé˜…è¯»xv6çš„æºç åå¯¹äºè¿›ç¨‹è°ƒåº¦çš„å®ç°æœ‰äº†å¤§è‡´çš„äº†è§£ï¼Œä½†æ˜¯å…¶ä¸­é”çš„è·å–ä¸é‡Šæ”¾é¡ºåºè®©æˆ‘å›°æƒ‘äº†å¥½ä¹…ï¼šåœ¨yieldå‡½æ•°ä¸­ï¼Œä¸æ˜¯å…ˆè·å–äº†è¿›ç¨‹pçš„é”å—ï¼Œé‚£ä¹ˆä¹‹ååœ¨è°ƒåº¦å™¨ä¸­åˆè·å–pçš„é”ï¼Œé‚£ä¸æ˜¯ä¼šæ­»é”å—ï¼Ÿåœ¨è°ƒåº¦å™¨å†…ä½¿ç”¨swtchå‘ç”Ÿè¿›ç¨‹åˆ‡æ¢åï¼Œåˆä¼šè·³è½¬åˆ°å“ªé‡Œï¼Ÿ\nè€Œåœ¨æˆ‘è§‚æ‘©å¤§ä½¬çš„ä¸€äº›åšå®¢å’Œè§†é¢‘åï¼Œå‘ç°æˆ‘ä¹‹å‰çš„æƒ³æ³•æœ‰å¾ˆå¤§çš„é—®é¢˜ï¼Œå½’æ ¹ç»“åº•æ˜¯æ²¡æœ‰å¼„æ˜ç™½xv6ä½•æ—¶å‘ç”Ÿäº†åˆ‡æ¢ï¼Œåˆ‡æ¢ååº”è¯¥ä»å“ªé‡Œå¼€å§‹è¿è¡Œã€‚è¿™ç¯‡ç¬”è®°å°±æ˜¯å¯¹äºåˆ†æxv6è¿›ç¨‹è°ƒåº¦çš„æ€»ç»“ã€‚\nåœ¨ä½¿ç”¨allocprocåˆ›å»ºè¿›ç¨‹æ—¶ï¼Œä¼šä¸ºåˆ›å»ºçš„procè®¾ç½®raçš„å€¼ï¼Œåˆå§‹ä¼šè®¾ç½®ä¸ºforkretå‡½æ•°çš„åœ°å€ã€‚\nstatic struct proc* allocproc(void) { ... memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); p-\u0026gt;context.ra = (uint64)forkret; p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; return p; } åœ¨è°ƒåº¦å™¨schedulerå¼€å§‹è¿è¡Œåï¼Œéå†è¿›ç¨‹è¡¨ï¼Œå…ˆå¯¹éå†åˆ°çš„å½“å‰è¿›ç¨‹pä¸Šé”ï¼Œå¦‚æœè¿™ä¸ªè¿›ç¨‹æ˜¯å¯è¿è¡Œçš„ï¼ˆRUNNABLEï¼‰ï¼Œåˆ™æ‰§è¡Œswtchå‡½æ•°åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œä¿å­˜å½“å‰cpuçš„ä¸Šä¸‹æ–‡ï¼ŒåŒæ—¶åŠ è½½pçš„ä¸Šä¸‹æ–‡åˆ°å¯„å­˜å™¨ä¸­ã€‚\næ‰§è¡Œå®Œswtchåä¼šè·³è½¬åˆ°raå¯„å­˜å™¨æ‰€ä¿å­˜çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªè¿›ç¨‹åˆå§‹è®¾ç½®çš„forkretçš„ä½ç½®ï¼Œè¿™ä¸ªå‡½æ•°ä¸­ä¼šé‡Šæ”¾åœ¨schedulerä¸­å¯¹è¿›ç¨‹pä¸Šçš„é”ã€‚å¦‚æœè¿™ä¸ªå‡½æ•°æ˜¯ç¬¬ä¸€æ¬¡æ‰§è¡Œï¼Œé‚£ä¹ˆä¼šåˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿã€‚ä¹‹åæ‰§è¡Œusertrapretå‡½æ•°ã€‚\n// A fork child\u0026#39;s very first scheduling by scheduler() // will swtch to forkret. void forkret(void) { static int first = 1; // Still holding p-\u0026gt;lock from scheduler. release(\u0026amp;myproc()-\u0026gt;lock); if (first) { // File system initialization must be run in the context of a // regular process (e.g., because it calls sleep), and thus cannot // be run from main(). fsinit(ROOTDEV); first = 0; // ensure other cores see first=0. __sync_synchronize(); } usertrapret(); } usertrapretä¸­ï¼Œå°†ä¼šå…³é—­ä¸­æ–­ï¼Œæœ€åè¿™ä¼šè®©å½“å‰è¿›ç¨‹ä»å†…æ ¸æ€è¿”å›åˆ°ç”¨æˆ·æ€ï¼ˆå›åˆ°ç”¨æˆ·ç©ºé—´ï¼‰ï¼Œåˆ‡æ¢ç”¨æˆ·é¡µè¡¨å¹¶æ¢å¤ç”¨æˆ·æ€å¯„å­˜å™¨ã€‚\n// // return to user space // void usertrapret(void) { ... // we\u0026#39;re about to switch the destination of traps from // kerneltrap() to usertrap(), so turn off interrupts until // we\u0026#39;re back in user space, where usertrap() is correct. intr_off(); ... // jump to userret in trampoline.S at the top of memory, which // switches to the user page table, restores user registers, // and switches to user mode with sret. uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline); ((void (*)(uint64))trampoline_userret)(satp); } åœ¨ä¹‹åå¦‚æœè¯¥è¿›ç¨‹ä¼šè§¦å‘ä¸­æ–­ï¼ˆä¾‹å¦‚æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦ä¸­æ‰§è¡Œæ—¶é—´åˆ°äº†åè§¦å‘æ—¶é’Ÿä¸­æ–­ï¼‰æˆ–è€…ä½¿ç”¨äº†ç³»ç»Ÿè°ƒç”¨ï¼Œå°†ä¼šæ‰§è¡Œusertrapå‡½æ•°ï¼ˆä¹Ÿå³å¤„ç†é™·å…¥ï¼‰ï¼Œåœ¨å…¶ä¸­ä¼šæ‰§è¡Œyieldå‡½æ•°æ¥è®©è¯¥è¿›ç¨‹è®©å‡ºcpuï¼Œå¹¶è¿›è¡Œè¿›ç¨‹åˆ‡æ¢ã€‚\n// // handle an interrupt, exception, or system call from user space. // called from trampoline.S // void usertrap(void) { ... if(r_scause() == 8){ // system call ... } else if((which_dev = devintr()) != 0){ // ok } else { printf(\u0026#34;usertrap(): unexpected scause %p pid=%d\\n\u0026#34;, r_scause(), p-\u0026gt;pid); printf(\u0026#34; sepc=%p stval=%p\\n\u0026#34;, r_sepc(), r_stval()); setkilled(p); } if(killed(p)) exit(-1); // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); usertrapret(); } yieldå‡½æ•°ä¼šå…ˆå¯¹å½“å‰è¿›ç¨‹pä¸Šé”ï¼Œç„¶åæ‰§è¡Œshedå‡½æ•°ï¼Œshedå‡½æ•°ä¼šå…ˆè¿›è¡Œä¸€äº›æ£€æŸ¥ï¼Œç„¶åè°ƒç”¨swtchå‡½æ•°è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå…¶ä¿å­˜pçš„ä¸Šä¸‹æ–‡ï¼Œå¹¶åŠ è½½ä¹‹å‰cpuçš„ä¸Šä¸‹æ–‡ã€‚è¿™æ ·ï¼Œraå¯„å­˜å™¨ä¸­çš„å€¼å°±å˜æˆäº†schedulerä¸­çš„swtchæ‰€åœ¨åœ°å€çš„åä¸€æ¡æŒ‡ä»¤çš„åœ°å€ã€‚åœ¨schdulerä¸­ï¼Œé‡ç½®å½“å‰cpuæ‰€è¿è¡Œçš„è¿›ç¨‹åï¼Œé‡Šæ”¾è¿›ç¨‹pçš„é”ï¼Œä¹‹åå¼€å¯æ–°ä¸€è½®è°ƒåº¦ï¼ˆéå†è¿›ç¨‹è¡¨æ‰¾åˆ°ä¸‹ä¸€ä¸ªå¯è¿è¡Œçš„è¿›ç¨‹ï¼‰ã€‚\nvoid sched(void) { int intena; struct proc *p = myproc(); if(!holding(\u0026amp;p-\u0026gt;lock)) panic(\u0026#34;sched p-\u0026gt;lock\u0026#34;); if(mycpu()-\u0026gt;noff != 1) panic(\u0026#34;sched locks\u0026#34;); if(p-\u0026gt;state == RUNNING) panic(\u0026#34;sched running\u0026#34;); if(intr_get()) panic(\u0026#34;sched interruptible\u0026#34;); intena = mycpu()-\u0026gt;intena; swtch(\u0026amp;p-\u0026gt;context, \u0026amp;mycpu()-\u0026gt;context); mycpu()-\u0026gt;intena = intena; } // Give up the CPU for one scheduling round. void yield(void) { struct proc *p = myproc(); acquire(\u0026amp;p-\u0026gt;lock); p-\u0026gt;state = RUNNABLE; sched(); release(\u0026amp;p-\u0026gt;lock); } è¿™é‡Œyieldä¸­ä½¿ç”¨äº†acquireå’Œreleaseå‡½æ•°æ¥è¿›è¡Œé”çš„æ“ä½œï¼Œä½†æ˜¯è¿™ä¸ªé”çš„è·å–ä¸é‡Šæ”¾æ—¶æœºå¹¶ä¸æ˜¯å¦‚åŒä»£ç ä¸­çš„è¿™æ ·æ˜¯ä¸€ä¸ªâ€œé¡ºåºâ€çš„è¿‡ç¨‹ã€‚\nå½“æ‰§è¡Œé¡ºåºä¸ºä»è°ƒåº¦å™¨é€‰æ‹©å¯è°ƒåº¦è¿›ç¨‹ï¼ˆRUNNABLEï¼‰åè¿›è¡Œè¿›ç¨‹åˆ‡æ¢ï¼š å½“æ‰§è¡Œé¡ºåºä¸ºè¿›ç¨‹è§¦å‘ä¸­æ–­ç­‰é™·å…¥æ—¶ï¼Œæ”¾å¼ƒcpuèµ„æºï¼Œéœ€è¦æ‰§è¡Œè¿›ç¨‹è°ƒåº¦æ—¶ï¼š å¯ä»¥çœ‹åˆ°ï¼Œåœ¨yieldå‡½æ•°ä¸­ï¼Œè¿›ç¨‹pçš„é”çš„ä½¿ç”¨é¡ºåºå¹¶ä¸æ˜¯acquire() è·å–é”-\u0026gt; æ‰§è¡Œshed()å‡½æ•° -\u0026gt; release()é‡Šæ”¾é”è¿™æ ·çº¿æ€§çš„ï¼Œåœ¨å…¶ä¸­ä¼šå‘ç”Ÿè¿›ç¨‹åˆ‡æ¢å› æ­¤é”çš„â€œè·å–ã€é‡Šæ”¾â€é€»è¾‘å¹¶ä¸å‘ç”Ÿåœ¨ä¸€ä¸ªå‡½æ•°ä¸­ã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081xv6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%90/","summary":"\u003cp\u003eåœ¨åšthread labçš„æ—¶å€™ï¼Œé˜…è¯»xv6çš„æºç åå¯¹äºè¿›ç¨‹è°ƒåº¦çš„å®ç°æœ‰äº†å¤§è‡´çš„äº†è§£ï¼Œä½†æ˜¯å…¶ä¸­é”çš„è·å–ä¸é‡Šæ”¾é¡ºåºè®©æˆ‘å›°æƒ‘äº†å¥½ä¹…ï¼šåœ¨yieldå‡½æ•°ä¸­ï¼Œä¸æ˜¯å…ˆè·å–äº†è¿›ç¨‹pçš„é”å—ï¼Œé‚£ä¹ˆä¹‹ååœ¨è°ƒåº¦å™¨ä¸­åˆè·å–pçš„é”ï¼Œé‚£ä¸æ˜¯ä¼šæ­»é”å—ï¼Ÿåœ¨è°ƒåº¦å™¨å†…ä½¿ç”¨swtchå‘ç”Ÿè¿›ç¨‹åˆ‡æ¢åï¼Œåˆä¼šè·³è½¬åˆ°å“ªé‡Œï¼Ÿ\u003c/p\u003e\n\u003cp\u003eè€Œåœ¨æˆ‘è§‚æ‘©å¤§ä½¬çš„ä¸€äº›åšå®¢å’Œè§†é¢‘åï¼Œå‘ç°æˆ‘ä¹‹å‰çš„æƒ³æ³•æœ‰å¾ˆå¤§çš„é—®é¢˜ï¼Œå½’æ ¹ç»“åº•æ˜¯æ²¡æœ‰å¼„æ˜ç™½xv6ä½•æ—¶å‘ç”Ÿäº†åˆ‡æ¢ï¼Œåˆ‡æ¢ååº”è¯¥ä»å“ªé‡Œå¼€å§‹è¿è¡Œã€‚è¿™ç¯‡ç¬”è®°å°±æ˜¯å¯¹äºåˆ†æxv6è¿›ç¨‹è°ƒåº¦çš„æ€»ç»“ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘xv6è¿›ç¨‹è°ƒåº¦åˆ†æ"},{"content":"æœ¬æ¬¡çš„å®éªŒæ€»ä½“éƒ½ä¸æ˜¯å¾ˆéš¾ï¼Œç¬¬ä¸€ä¸ªç»ƒä¹ è®©æˆ‘ä»¬åœ¨ç”¨æˆ·æ€æ¨¡æ‹Ÿäº†çº¿ç¨‹çš„åˆ‡æ¢ï¼Œè¿™é‡Œé‡è¦çš„å°±æ˜¯è¿›ç¨‹/çº¿ç¨‹ä¸Šä¸‹æ–‡çš„ä¿å­˜ä¸æ¢å¤ï¼›ç¬¬äºŒä¸‰ä¸ªç»ƒä¹ åˆ™æ˜¯è®©æˆ‘ä»¬è·³å‡ºäº†xv6ï¼Œå»ç†Ÿæ‚‰pthreadåº“å’Œçº¿ç¨‹çš„åŒæ­¥äº’æ–¥ã€‚\nç®€å•åˆ†æxv6ä¸­çš„è¿›ç¨‹åˆ‡æ¢ initæ˜¯ç”¨æˆ·æ€æœ€å…ˆå¯åŠ¨çš„è¿›ç¨‹ï¼Œå…¶å¯åŠ¨åä¼šåˆ›å»ºshè¿›ç¨‹ï¼Œshè¿›ç¨‹åˆä¼šforkå¹¶execå…¶ä»–å‘½ä»¤ï¼š\nå†…æ ¸ä¼šåœ¨userinit()ä¸­å‡†å¤‡initè¿›ç¨‹ï¼Œè¿™æ˜¯æœ€å…ˆå¯åŠ¨çš„ç”¨æˆ·æ€è¿›ç¨‹ï¼Œå°†å…¶è¿è¡ŒçŠ¶æ€è®¾ç½®ä¸ºRUNNABLE å†…æ ¸å¯åŠ¨schedulerè¿›è¡Œè¿›ç¨‹è°ƒåº¦ï¼ˆè¿™ä¸ªå‡½æ•°ä¼šä¸€ç›´æ‰§è¡Œï¼‰ï¼Œå½“å‰åªæœ‰initè¿›ç¨‹ï¼Œä¸”å…¶çŠ¶æ€ä¸ºRUNNABLEï¼Œæ•…è¿è¡Œ initè¿›ç¨‹ä¼šforkä¸€ä¸ªå­è¿›ç¨‹ï¼Œå¹¶ä½¿ç”¨execæ‰§è¡Œshè¿›ç¨‹ï¼Œå…¶ç”¨äºå¤„ç†ç”¨æˆ·åœ¨æ§åˆ¶å°çš„è¾“å…¥ ç”¨æˆ·è¾“å…¥å‘½ä»¤åï¼Œshè§£æå‘½ä»¤åforkå­è¿›ç¨‹å¹¶ç”¨execæ¥å°†å‘½ä»¤å¯¹åº”çš„è¿›ç¨‹æ›¿æ¢æ‰forkçš„å­è¿›ç¨‹ init - sh - ls - cat - ... xv6å†…éƒ¨é‡‡ç”¨æ—¶é—´ç‰‡è½®è½¬æ¥è¿›è¡Œè¿›ç¨‹è°ƒåº¦ï¼Œå½“è¿›ç¨‹æ—¶é—´ç‰‡åˆ°äº†åï¼Œè§¦å‘æ—¶é’Ÿä¸­æ–­ï¼Œæ‰§è¡Œyieldï¼Œåœ¨yieldä¸­ï¼Œä¼šå°†å½“å‰è¿›ç¨‹çš„çŠ¶æ€ä»è¿è¡Œæ€RUNNINGè®¾ç½®ä¸ºRUNNABLEï¼Œå¹¶åˆ‡æ¢è‡³schedulerè°ƒåº¦å™¨ï¼Œç”±å…¶æ¥å¯»æ‰¾ä¸‹ä¸€ä¸ªå¯è¿è¡Œçš„è¿›ç¨‹è¿›è¡Œåˆ‡æ¢ã€‚\né‚£ä¹ˆxv6æ˜¯æ€ä¹ˆåˆ‡æ¢å½“å‰è¿›ç¨‹å’Œschedulerè°ƒåº¦å™¨çš„å‘¢ï¼Ÿå…¶å®ç°æ˜¯æ ¹æ®swtchå‡½æ•°æ¥å®ç°çš„ï¼š\n// Switch to scheduler. Must hold only p-\u0026gt;lock // and have changed proc-\u0026gt;state. Saves and restores // intena because intena is a property of this // kernel thread, not this CPU. It should // be proc-\u0026gt;intena and proc-\u0026gt;noff, but that would // break in the few places where a lock is held but // there\u0026#39;s no process. void sched(void) { int intena; struct proc *p = myproc(); if(!holding(\u0026amp;p-\u0026gt;lock)) panic(\u0026#34;sched p-\u0026gt;lock\u0026#34;); if(mycpu()-\u0026gt;noff != 1) panic(\u0026#34;sched locks\u0026#34;); if(p-\u0026gt;state == RUNNING) panic(\u0026#34;sched running\u0026#34;); if(intr_get()) panic(\u0026#34;sched interruptible\u0026#34;); intena = mycpu()-\u0026gt;intena; swtch(\u0026amp;p-\u0026gt;context, \u0026amp;mycpu()-\u0026gt;context); mycpu()-\u0026gt;intena = intena; } // Give up the CPU for one scheduling round. void yield(void) { struct proc *p = myproc(); acquire(\u0026amp;p-\u0026gt;lock); p-\u0026gt;state = RUNNABLE; sched(); release(\u0026amp;p-\u0026gt;lock); } swtch(\u0026amp;p-\u0026gt;context, \u0026amp;mycpu()-\u0026gt;context)å‡½æ•°ä¼šå°†å½“å‰å¯„å­˜å™¨ä¸­çš„å€¼ä¿å­˜åˆ°p-\u0026gt;contextä¸­ï¼Œå¹¶å°†å½“å‰cpuä¸­contextçš„å†…å®¹æ¢å¤åˆ°å¯„å­˜å™¨ä¸­ï¼Œå…¶ä¸­æœ€é‡è¦çš„å°±æ˜¯raå¯„å­˜å™¨ï¼Œå½“æ¢å¤äº†è¿™ä¸ªåï¼Œraçš„å€¼å¯¹åº”çš„åœ°å€åœ¨è°ƒåº¦å™¨scheduler()ä¸­ï¼š\nï¼ˆè¿™é‡Œraçš„16è¿›åˆ¶ä¸º0x8000141eï¼‰\nè¿™æ ·ï¼Œxv6å°±ä»ï¼šæ‰§è¡Œå½“å‰è¿›ç¨‹ -\u0026gt; yield -\u0026gt; shed -\u0026gt; schedulerï¼›åœ¨schedulerè°ƒåº¦å™¨ä¸­ï¼Œå†…æ ¸ä¼šæ‰¾åˆ°ä¸‹ä¸€ä¸ªå°±ç»ªæ€çš„è¿›ç¨‹ï¼Œå¹¶ä½¿ç”¨swtchè¿›è¡Œè¿›ç¨‹åˆ‡æ¢ï¼š\n// Per-CPU process scheduler. // Each CPU calls scheduler() after setting itself up. // Scheduler never returns. It loops, doing: // - choose a process to run. // - swtch to start running that process. // - eventually that process transfers control // via swtch back to the scheduler. void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u0026gt;proc = 0; for(;;){ // The most recent process to run may have had interrupts // turned off; enable them to avoid a deadlock if all // processes are waiting. intr_on(); for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == RUNNABLE) { // Switch to chosen process. It is the process\u0026#39;s job // to release its lock and then reacquire it // before jumping back to us. p-\u0026gt;state = RUNNING; c-\u0026gt;proc = p; swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); // Process is done running for now. // It should have changed its p-\u0026gt;state before coming back. c-\u0026gt;proc = 0; } release(\u0026amp;p-\u0026gt;lock); } } } è¿™æ ·ï¼Œxv6åˆä»è°ƒåº¦å™¨åˆ‡æ¢åˆ°äº†ä¸‹ä¸€ä¸ªè¿›ç¨‹å»æ‰§è¡Œäº†ã€‚\nUthread: switching between threads åœ¨uthread.cä¸­ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç”¨æˆ·æ€ä¸‹æ¨¡æ‹Ÿäº†çº¿ç¨‹çš„è¿è¡Œä¸åˆ‡æ¢ã€‚å¯ä»¥ç®€å•ç†è§£ï¼Œè¿è¡Œä¸€ä¸ªçº¿ç¨‹å°±æ˜¯æ‰§è¡Œäº†ä¸€ä¸ªå‡½æ•°ã€‚\næºä»£ç ä¸­å·²ç»ç»™å‡ºè¦è¿è¡Œçš„çº¿ç¨‹ï¼ˆå‡½æ•°ï¼‰ï¼Œå¦‚ä½•å¯åŠ¨å®ƒä»¬å¹¶å¯¹ä»–ä»¬è¿›è¡Œåˆ‡æ¢å‘¢ï¼Ÿ\nå‰ç½®å‡†å¤‡ çº¿ç¨‹çš„åˆ‡æ¢åŒè¿›ç¨‹çš„åˆ‡æ¢ç›¸ä¼¼ï¼Œéœ€è¦ä¿å­˜é€šç”¨å¯„å­˜å™¨çš„å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹å†…æ ¸ç…§çŒ«ç”»è™èˆ¬åœ¨ç”¨æˆ·çº¿ç¨‹struct threadä¸­æ·»åŠ ä¸€ä¸ªstruct contextå˜é‡ï¼š\nstruct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; struct thread { char stack[STACK_SIZE]; /* the thread\u0026#39;s stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct context t_context; }; å¯åŠ¨ risc-vä¸­çš„raå¯„å­˜å™¨çš„ä½œç”¨æ˜¯ä¿å­˜å‡½æ•°è¿”å›åœ°å€ã€‚å…·ä½“æ¥è¯´ï¼Œå½“ä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œè°ƒç”¨æŒ‡ä»¤ä¼šå°†è¿”å›åœ°å€ï¼Œå³è°ƒç”¨è¯¥å‡½æ•°çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œä¿å­˜åœ¨raå¯„å­˜å™¨ä¸­ã€‚\nåœ¨å®éªŒä¸­ï¼Œæˆ‘ä»¬é€šè¿‡thread_createæ¥åˆ›å»ºçº¿ç¨‹ï¼Œé‚£ä¹ˆï¼Œåœ¨æ‰§è¡Œç©thread_createä¹‹åå¹¶è¿›è¡Œäº†è°ƒåº¦åï¼Œæ˜¯ä¸æ˜¯å°±è¯¥è¿è¡Œçº¿ç¨‹å‡½æ•°äº†ï¼Ÿæ²¡é”™ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¿å­˜åˆ›å»ºçš„çº¿ç¨‹å¯¹åº”çš„å‡½æ•°çš„åœ°å€åˆ°raå¯„å­˜å™¨ä¸­ï¼ŒåŒæ—¶ï¼Œè¿˜éœ€è¦è®¾ç½®çº¿ç¨‹çš„æ ˆæŒ‡é’ˆï¼š\nvoid thread_create(void (*func)()) { struct thread *t; for (t = all_thread; t \u0026lt; all_thread + MAX_THREAD; t++) { if (t-\u0026gt;state == FREE) break; } t-\u0026gt;state = RUNNABLE; // YOUR CODE HERE t-\u0026gt;t_context.ra = (uint64)func; t-\u0026gt;t_context.sp = (uint64)t-\u0026gt;stack + STACK_SIZE; } è°ƒåº¦ å³åˆ‡æ¢çº¿ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜å½“å‰çº¿ç¨‹çš„é€šç”¨å¯„å­˜å™¨ï¼Œå¹¶å°†ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„çº¿ç¨‹çš„é€šç”¨å¯„å­˜å™¨å€¼æ¢å¤åˆ°ç¡¬ä»¶ä¸Šï¼Œå¦‚åŒè¿›ç¨‹åˆ‡æ¢é‚£æ ·ï¼š\n# uthread_switch.S thread_switch: /* YOUR CODE HERE */ sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret /* return to ra */ // uthread.c void thread_schedule(void) { ... if (current_thread != next_thread) { /* switch threads? */ next_thread-\u0026gt;state = RUNNING; t = current_thread; current_thread = next_thread; /* YOUR CODE HERE * Invoke thread_switch to switch from t to next_thread: * thread_switch(??, ??); */ thread_switch((uint64)\u0026amp;t-\u0026gt;t_context, (uint64)\u0026amp;next_thread-\u0026gt;t_context); } else next_thread = 0; } Using threads å¦‚æœåªæ˜¯ç®€å•åœ¨getå’Œputæ“ä½œä¸­åŠ ä¸Šé”ï¼Œé‚£ä¹ˆè¿™æ ·è™½ç„¶èƒ½å¤Ÿä¿è¯å¯¹å…±äº«èµ„æºçš„äº’æ–¥è®¿é—®ï¼Œå½“æ—¶æ— æ³•è¾¾åˆ°åŒçº¿ç¨‹æ‰€å¸¦æ¥çš„æ€§èƒ½æå‡ã€‚\nåº”è¯¥å®ç°çš„æ˜¯ä¸¤ä¸ªçº¿ç¨‹ï¼Œä½ æ”¾ä½ çš„ï¼Œæˆ‘æ”¾æˆ‘çš„ï¼Œç°åœ¨æœ‰5ä¸ªentry tableï¼Œæˆ‘ä»¬å¯ä»¥ä¸æ­¢ä½¿ç”¨ä¸€æŠŠé”æ¥é”ä½5ä¸ªtableï¼Œè€Œæ˜¯ä½¿ç”¨5æŠŠé”ï¼Œå“ªä¸€ä¸ªtableéœ€è¦äº’æ–¥æ“ä½œæ—¶åªé”å®ƒä¸€ä¸ªå°±è¡Œï¼Œè¿™æ ·å°±ç»†åŒ–äº†é”çš„ç²’åº¦ã€‚\nè¿™é‡Œéœ€è¦æŠŠtableæ”¹ä¸ºä¸€ä¸ªæ•°ç»„ï¼Œå®ç°ä»£ç æ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œå°±ä¸æ”¾äº†ã€‚\nBarrier å®éªŒçš„è¦æ±‚æ˜¯æ¯æ¥ä¸€ä¸ªçº¿ç¨‹è¿è¡Œåˆ°barrierå°±é˜»å¡ï¼Œç›´åˆ°æ‰€æœ‰çº¿ç¨‹éƒ½è¿è¡Œåˆ°äº†barrieræ‰é‡Šæ”¾ã€‚è¿™é‡Œæ˜¯æƒ³è®©æˆ‘ä»¬ç†Ÿæ‚‰pthreadåº“ä¸­å…³äºé”å’Œæ¡ä»¶å˜é‡çš„ä½¿ç”¨ï¼Œæ›´åŠ äº†è§£çº¿ç¨‹çš„åŒæ­¥å…³ç³»ã€‚\næˆ‘ä»¬å¯ä»¥ç»™å…¨å±€çš„bstateä¸­æ·»åŠ ä¸€ä¸ªå˜é‡countç”¨äºè®°å½•å½“å‰è½®æ¬¡æœ‰å¤šå°‘ä¸ªçº¿ç¨‹å·²ç»åˆ°è¾¾äº†barrierï¼Œåªè¦æœ‰çº¿ç¨‹åˆ°è¾¾ï¼Œæ‰§è¡Œ++bstate.countï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªå…¨å±€å˜é‡ä¼šè¢«å¤šä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œæ•…éœ€è¦ä½¿ç”¨é”æ¥ä¿è¯äº’æ–¥è®¿é—®ã€‚\næ¥ä¸‹æ¥åˆ¤æ–­countçš„å€¼æ˜¯å¦ç­‰äºçº¿ç¨‹çš„æ•°é‡ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œå°±waité˜»å¡å½“å‰çº¿ç¨‹ï¼Œå¹¶é‡Šæ”¾é”ï¼›å¦åˆ™ï¼Œè¯´æ˜ä¸€è½®ç»“æŸï¼Œå°†countç½®0ï¼Œè½®æ¬¡+1ï¼Œå¹¶ä½¿ç”¨broadcasetå”¤é†’è¢«é˜»å¡çš„çº¿ç¨‹ã€‚\nå°è¯•1 æŒ‰åˆšåˆšè¯´çš„æ€è·¯ï¼Œå¦‚æœè¿™ä¹ˆå†™ä»£ç ï¼Œå°†ä¼šé€ æˆç³»ç»Ÿç¨‹åºæ­»é”ã€‚\nstatic void barrier() { pthread_mutex_lock(\u0026amp;bstate.barrier_mutex); ++bstate.count; pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); if (bstate.count == bstate.nthread) { bstate.count = 0; ++bstate.round; pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); return; } pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); } å½“æ¡ä»¶å˜é‡ cond å˜ä¸ºçœŸä¸”è¯¥çº¿ç¨‹è¢«å”¤é†’æ—¶ï¼Œpthread_cond_wait ä¼šè‡ªåŠ¨é‡æ–°è·å–äº’æ–¥é” mutexï¼Œç„¶åè¿”å›ã€‚\nçº¿ç¨‹1ç¬¬0è½®è·å¾—é”ï¼Œ++countåé‡Šæ”¾é”ï¼Œç„¶ååœ¨waitå¤„é˜»å¡ï¼Œå¹¶é‡Šæ”¾é” æ¥ç€çº¿ç¨‹2åœ¨ç¬¬0è½®è·å¾—é”ï¼Œ++countåè¿›å…¥ifåˆ¤æ–­ï¼Œä½¿ç”¨broadcastå”¤é†’çº¿ç¨‹1 çº¿ç¨‹1è¢«å”¤é†’ï¼Œå¹¶è‡ªåŠ¨è·å–é” çº¿ç¨‹2è¿›å…¥ç¬¬1è½®ï¼Œå°è¯•è·å¾—é”ï¼Œä½†æ˜¯æ­¤æ—¶çº¿ç¨‹1æ­£æŒæœ‰é”ï¼Œæ•…çº¿ç¨‹2é˜»å¡ çº¿ç¨‹1è¿›å…¥ç¬¬1è½®ï¼Œä½†ä¹‹å‰è‡ªå·±å·²ç»è·å¾—é”äº†ï¼Œæ­¤æ—¶åˆè¯·æ±‚é”ï¼Œæ•…é˜»å¡ ä¸¤ä¸ªçº¿ç¨‹éƒ½é˜»å¡ï¼Œç¨‹åºå‡ºç°æ­»é” å°è¯•2 æ—¢ç„¶pthread_cond_waitä¼šè‡ªåŠ¨é‡æ–°è·å–äº’æ–¥é”ï¼Œé‚£å°±åœ¨è°ƒç”¨ä¹‹åä½¿ç”¨pthread_mutex_unlocké‡Šæ”¾é”ä¸ä¹…å¥½äº†å—ï¼Ÿ\nstatic void barrier() { pthread_mutex_lock(\u0026amp;bstate.barrier_mutex); if (++bstate.count == bstate.nthread) { bstate.count = 0; ++bstate.round; pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); return; } pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); } è¿™æ ·è¿˜æ˜¯ä¸è¡Œï¼šåŸå› æ˜¯pthread_cond_broadcastä¸ä¼šé‡Šæ”¾é”ã€‚\nåœ¨ç¬¬0è½®çº¿ç¨‹1æ‹¿åˆ°é”å++countåè¿›å…¥waitçŠ¶æ€ï¼Œæ­¤æ—¶çº¿ç¨‹1é˜»å¡å¹¶é‡Šæ”¾é” åœ¨ç¬¬0è½®çº¿ç¨‹2æ‹¿åˆ°é”ï¼Œæ‰§è¡Œ++countæ“ä½œåä½¿ç”¨broadcastå°è¯•å”¤é†’çº¿ç¨‹1ï¼Œä½†æ˜¯çº¿ç¨‹2å¹¶æ²¡æœ‰é‡Šæ”¾é” çº¿ç¨‹1æŠ¢åˆ°CPUï¼Œä½†æ˜¯æ‹¿ä¸åˆ°é”ï¼Œç»§ç»­é˜»å¡ çº¿ç¨‹2æŠ¢åˆ°äº†CPUçš„æ‰§è¡Œæƒè¿›å…¥ç¬¬1è½®ï¼Œä¼å›¾è·å¾—é”ï¼Œä½†æ˜¯ä¹‹å‰è‡ªå·±æ²¡æœ‰é‡Šæ”¾é”ï¼Œä¹Ÿé˜»å¡ ä¸¤ä¸ªçº¿ç¨‹éƒ½é˜»å¡ï¼Œç¨‹åºå‡ºç°æ­»é” æ­£ç¡®åšæ³• æ‰€ä»¥æ­£ç¡®çš„åšæ³•æ˜¯åœ¨broadcaståä¹Ÿä½¿ç”¨unlocké‡Šæ”¾é”ï¼š\nstatic void barrier() { pthread_mutex_lock(\u0026amp;bstate.barrier_mutex); if (++bstate.count == bstate.nthread) { bstate.count = 0; ++bstate.round; pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); return; } pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); } ä»£ç å®ç°è¯¦æƒ… è¯·è§Githubï¼šhttps://github.com/kerolt/xv6-labs-2023/tree/thread\nReference https://www.cnblogs.com/looking-for-zihuatanejo/p/17682582.html https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec11-thread-switching-robert/11.7-xv6-switch-function https://www.bilibili.com/video/BV1bZ421U75W/?spm_id_from=333.999.0.0\u0026amp;vd_source=e7bb0cfb7224c8d6671fa62c0e80c832 https://pdos.csail.mit.edu/6.S081/2023/labs/thread.html ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab6-multithreading/","summary":"\u003cp\u003eæœ¬æ¬¡çš„å®éªŒæ€»ä½“éƒ½ä¸æ˜¯å¾ˆéš¾ï¼Œç¬¬ä¸€ä¸ªç»ƒä¹ è®©æˆ‘ä»¬åœ¨ç”¨æˆ·æ€æ¨¡æ‹Ÿäº†çº¿ç¨‹çš„åˆ‡æ¢ï¼Œè¿™é‡Œé‡è¦çš„å°±æ˜¯è¿›ç¨‹/çº¿ç¨‹ä¸Šä¸‹æ–‡çš„ä¿å­˜ä¸æ¢å¤ï¼›ç¬¬äºŒä¸‰ä¸ªç»ƒä¹ åˆ™æ˜¯è®©æˆ‘ä»¬è·³å‡ºäº†xv6ï¼Œå»ç†Ÿæ‚‰pthreadåº“å’Œçº¿ç¨‹çš„åŒæ­¥äº’æ–¥ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab6 multithreading"},{"content":" è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nå¤ªèœäº†ï¼Œä»æ²¡æ‰“è¿‡è¿™ä¹ˆè‰°éš¾çš„ä»—QAQã€‚ç”±äºè¯¾ç¨‹çš„è¦æ±‚ä¸èƒ½å…¬å¼€æºä»£ç ï¼Œæ‰€ä»¥ç½‘ä¸Šçš„èµ„æºä¼šå°‘å¾ˆå¤šï¼Œå¹³å°ä¸Šçš„æµ‹è¯•æ¡ˆä¾‹æ¯”è¾ƒå…¨é¢ï¼Œæœ‰çš„è¿˜æ¯”è¾ƒåˆé’»ï¼Œéœ€è¦è€ƒè™‘åˆ°å¯æ‹“å±•å“ˆå¸Œçš„å®ç°ç»†èŠ‚ã€‚åœ¨è‡ªè®¤ä¸ºå†™å®Œäº†åï¼Œæäº¤äº†è¿‘40æ¥æ¬¡æ€»æœ‰å‡ ä¸ªæµ‹è¯•é›†è¿‡ä¸äº†ï¼Œè¿˜å¥½æ²¡æœ‰å´©æºƒï¼Œåœ¨çœ‹äº†å‡ ç¯‡åšå®¢çš„æ–¹æ³•åï¼ŒåŠ ä¸Šè‡ªå·±ç”»å›¾ç†è§£ï¼Œæœ€åç»ˆäºè¿‡äº†ğŸ˜­ã€‚ä¸è¿‡å›å¤´å†™åšå®¢çš„æ—¶å€™å†å»çœ‹ä»£ç ï¼Œä¹Ÿæ²¡æœ‰ç‰¹åˆ«çš„å¤æ‚ï¼Œè¿˜æ˜¯å¾—æ˜ç™½å…¶ä¸­çš„ç®—æ³•é€»è¾‘æ˜¯å¦‚ä½•å®ç°çš„ã€‚\nTask1 - Read/Write Page Guards ç®€å•æ¥è¯´ï¼Œå°±æ˜¯ä¸ºPageå®ç°ä¸€ä¸ªRAIIæ¥è‡ªåŠ¨ç®¡ç†èµ„æºã€‚å› ä¸ºåœ¨BufferPoolManager::Unpinä¸­ï¼Œæ¯æ¬¡è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œéƒ½ä¼šè®©å¯¹åº”çš„pageçš„pin_count_ - 1ï¼Œå½“è¿™ä¸ªå€¼ä¸º0æ—¶ï¼Œè¿™ä¸ªpageå°±å¯ä»¥è¢«å›æ”¶ï¼Œæˆ–è€…è¯´è¢«æ›¿æ¢äº†ã€‚ä½†å¦‚æœæˆ‘ä»¬å¿˜è®°å»æ‰‹åŠ¨è°ƒç”¨ï¼Œè¯¥é¡µé¢å°†æ°¸è¿œä¸ä¼šè¢«é€å‡ºç¼“å†²æ± ã€‚ç”±äºç¼“å†²æ± ä»¥æ›´å°‘çš„å¸§æ•°è¿è¡Œï¼Œç£ç›˜å†…å¤–çš„é¡µé¢äº¤æ¢å°†æ›´å¤šã€‚ä¸ä»…æ€§èƒ½å—åˆ°å½±å“ï¼Œè€Œä¸”å¾ˆéš¾æ£€æµ‹åˆ°é”™è¯¯ã€‚\nä¸»è¦éœ€è¦è€ƒè™‘å¦‚ä½•ç¼–å†™ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼çš„é€»è¾‘ã€‚ç§»åŠ¨äº†ä¸€ä¸ªå¯¹è±¡åï¼ŒåŸæ¥çš„å¯¹è±¡çš„èµ„æºåº”è¯¥è½¬ç§»åˆ°äº†æ–°å¯¹è±¡ä¸Šï¼Œé‚£ä¹ˆåŸæ¥çš„å¯¹è±¡æ— æ³•å†è®¿é—®èµ„æºï¼ˆå°†åŸæ¥å¯¹è±¡çš„èµ„æºé‡ç½®nullptræˆ–æ¸…ç©ºï¼‰ã€‚\nè¿˜æœ‰ä¸€ä¸ªDrop()çš„æ¥å£ï¼Œè¿™æ˜¯æä¾›ç»™ä½¿ç”¨è€…çš„é‡Šæ”¾èµ„æºçš„apiï¼Œåœ¨å®ç°è™šæ„å‡½æ•°æ—¶å¯ä»¥ç›´æ¥è°ƒç”¨å®ƒã€‚Dropçš„å®ç°å°±æ˜¯è°ƒç”¨Unpinï¼Œç„¶åç½®ç©ºèµ„æºã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿›è¡Œç§»åŠ¨èµ‹å€¼æ—¶ï¼Œä¸€å¼€å§‹ä¹Ÿè¦Dropä¸€ä¸‹ï¼Œè€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µï¼š\nauto p = std::move(basic_page_guard); p = std::move(basic_page_guard2); è¿™ä¸ªæ—¶å€™åŒä¸€ä¸ªå˜é‡pæ¥ç®¡äº†ä¸¤ä¸ªpageï¼Œé‚£ä¹ˆåº”è¯¥åœ¨ç¬¬äºŒä¸ªç§»åŠ¨èµ‹å€¼æ—¶å…ˆdropæ‰ç¬¬ä¸€ä¸ªï¼Œå› ä¸ºç¬¬ä¸€ä¸ªpageä¸å†ä½¿ç”¨äº†ï¼Œè‡ªç„¶è¦Unpinã€‚\nè¿˜æœ‰å°±æ˜¯åœ¨ä¸‰ä¸ªpage guardç±»é‡è½½ç§»åŠ¨èµ‹å€¼æ—¶ï¼Œå¦‚æœéœ€è¦ç§»åŠ¨çš„å¯¹è±¡å’Œè‡ªèº«æ˜¯åŒä¸€ä¸ªï¼Œé‚£ä¹ˆç›´æ¥è¿”å›è‡ªå·±å°±å¥½ï¼š\nauto BasicPageGuard::operator=(BasicPageGuard \u0026amp;\u0026amp;that) noexcept -\u0026gt; BasicPageGuard \u0026amp; { if (\u0026amp;that == this) { return *this; } // ... å…¶ä»–æ“ä½œ } åœ¨ReadPageGuardå’ŒWritePageGuardçš„Drop()ä¸­ï¼Œè¿˜éœ€è¦è€ƒè™‘é‡Šæ”¾ç®¡ç†çš„pageçš„é”ã€‚å¯¹åº”çš„ï¼Œé”çš„è·å–å‘ç”Ÿåœ¨FetchPageWrite()å’ŒFetchPageWrite()ä¸­ã€‚\nTask2 - Extendible Hash Table Pages ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å¯æ‰©å±•å“ˆå¸Œï¼Ÿ\nä¸‹å›¾æ¥æºï¼šhttps://www.bilibili.com/video/BV1Qt421w7JT\nåœ¨bustubçš„è®¾è®¡ä¸­ï¼ŒHeader Pageï¼ŒDirectory Pageå’ŒBucket Pageéƒ½æ˜¯æ— æ³•ç›´æ¥æ„é€ å‡ºæ¥çš„ï¼Œå³ä¸èƒ½é€šè¿‡æ„é€ å‡½æ•°åˆ›å»ºï¼Œåªèƒ½é€šè¿‡å„è‡ªçš„PageGuardä¸­çš„As()æˆ–è€…AsMut()å‡½æ•°æ¥è½¬æ¢ã€‚\nHeader header pageä¸­æœ‰ä¸€ä¸ªmax_depth_çš„æˆå‘˜å˜é‡ï¼Œ1 \u0026lt;\u0026lt; max_depth_å³ä¸ºheader pageä¸­èƒ½å­˜æ”¾çš„ç›®å½•çš„ç´¢å¼•çš„æ•°é‡ã€‚å½“æˆ‘ä»¬æœ‰å€¼éœ€è¦æ”¾å…¥å“ˆå¸Œè¡¨æ—¶ï¼Œè·å–hash(key)çš„äºŒè¿›åˆ¶æœ€é«˜max_depth_ä½ä½œä¸ºç´¢å¼•ï¼Œå†ä»headerä¸­å¯¹åº”ä½ç½®å»æ‰¾åˆ°directoryã€‚å¯¹åº”çš„ExtendibleHTableHeaderPageä¸­çš„åŠŸèƒ½å®ç°å¹¶ä¸éš¾ã€‚\nDirectory directoryä¸­æœ‰ä¸¤ä¸ªdepthï¼š\nGlobal Depthï¼šè‹¥global depthä¸ºnï¼Œé‚£ä¹ˆè¿™ä¸ªDirectoryå°±æœ‰2^nä¸ªentryï¼ˆç›¸å½“äºæŒ‡å‘2^nä¸ªbucketï¼‰ Local Depthï¼šè‹¥local depthä¸ºnï¼Œåˆ™åœ¨è¿™ä¸ªå¯¹åº”çš„bucketä¸‹ï¼Œæ¯ä¸ªå…ƒç´ çš„keyçš„æœ€ånä½éƒ½ç›¸åŒ ç±»ä¼¼headerä¸­è·å–ä¸‹ä¸€çº§é¡µçš„ç´¢å¼•ï¼Œdirectoryè·å–hash(key)çš„äºŒè¿›åˆ¶æœ€ä½global_depth_ä½ä½œä¸ºç´¢å¼•ã€‚é‚£local depthçš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ\nè¿™å°±è¦è¯´åˆ°å¯æ‹“å±•å“ˆå¸Œä¸­çš„æ’å…¥å’Œåˆ é™¤æ“ä½œäº†ã€‚ç®€å•æ¥è¯´ï¼Œåœ¨å¯æ‹“å±•å“ˆå¸Œè¡¨ä¸­ï¼Œç›®å½•directoryçš„å¤§å°æ˜¯å¯ä»¥å˜åŒ–çš„ï¼ˆåªè¦ä¸è¶…è¿‡æœ€å¤§å®¹é‡é™åˆ¶ï¼‰ã€‚ç›®å½•ä¸­å¯èƒ½æœ‰å¤šä¸ªentryæ˜ å°„åˆ°åŒä¸€ä¸ªbucketã€‚å½“éœ€è¦æ’å…¥æ—¶ï¼Œå¦‚æœè¿™ä¸ªbucketè¿˜æ²¡æœ‰æ»¡æ—¶ï¼Œå¯ä»¥ç›´æ¥æ’å…¥ï¼›å¦åˆ™ï¼Œéœ€è¦å°†è¿™ä¸ªbucketåˆ†è£‚æˆä¸¤ä¸ªbucketï¼ˆæˆ–è€…è¯´ï¼Œå°†è¿™ä¸ªbucketä¸­çš„ä¸€éƒ¨åˆ†ç§»åŠ¨åˆ°å¦ä¸€ä¸ªbucketä¸­ï¼‰ï¼Œå¹¶ä¸”è¿™ä¸ªbucketå¯¹åº”çš„local depth + 1ï¼Œè¿™æ ·ç›¸æ¯”ä¹‹å‰å°±å¤šäº†ä¸€ä½äºŒè¿›åˆ¶ä½å»è¯†åˆ«bucketã€‚å…·ä½“çš„ç”¨æ³•å¯ä»¥çœ‹åé¢çš„Task3éƒ¨åˆ†çš„ç¬”è®°ã€‚\nä¸‹é¢è®²å‡ ä¸ªç¨å¾®éš¾æ‡‚çš„å‡½æ•°ï¼š\nGetGlobalDepthMask è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯è·å–global_depth_ä¸ªäºŒè¿›åˆ¶1ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœglobal depthæ˜¯2ï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸ªç›®å½•å½“å‰çš„å®¹é‡ä¸º2^2=4ï¼Œç´¢å¼•ä¸º0~3ï¼Œç”¨ä¸¤ä½äºŒè¿›åˆ¶å°±èƒ½è¡¨ç¤ºã€‚\nä¸»è¦ç”¨äºå’Œhash(key)è¿›è¡Œ\u0026amp;æ“ä½œï¼Œè·å–åœ¨directoryä¸­å¯¹åº”çš„ç´¢å¼•ä½ç½®ã€‚ä¾‹å¦‚ï¼Œå‡è®¾key=3ï¼Œhash(key)=101ï¼ˆäºŒè¿›åˆ¶ï¼‰ï¼Œglobal depthè¿˜æ˜¯2ï¼Œé‚£ä¹ˆæ£€æŸ¥hash(key)çš„æœ€ä½ä¸¤ä½å³ä¸º01ï¼Œé‚£ä¹ˆåœ¨directoryå°±æ˜¯ç¬¬1ä¸ªentryã€‚\nCanShrink CanShrink() çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯æ£€æµ‹æ˜¯å¦å¯ä»¥å‡å°‘å…¨å±€æ·±åº¦ï¼ˆglobal depthï¼‰ï¼Œä»è€Œç¼©å°å“ˆå¸Œè¡¨çš„å¤§å°ã€‚å®ƒåŸºäºä»¥ä¸‹åŸåˆ™ï¼š\nåœ¨å¯æ‰©å±•å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯ä¸ªæ¡¶ï¼ˆbucketï¼‰éƒ½æœ‰è‡ªå·±çš„å±€éƒ¨æ·±åº¦ï¼ˆlocal depthï¼‰ï¼Œè€Œæ•´ä¸ªå“ˆå¸Œè¡¨æœ‰ä¸€ä¸ªå…¨å±€æ·±åº¦ï¼ˆglobal depthï¼‰ã€‚å¦‚æœæ‰€æœ‰æ¡¶çš„å±€éƒ¨æ·±åº¦éƒ½å°äºå½“å‰çš„å…¨å±€æ·±åº¦ï¼Œè¯´æ˜å“ˆå¸Œè¡¨çš„æŸäº›ä½ï¼ˆè¶…è¿‡å±€éƒ¨æ·±åº¦çš„é‚£äº›ä½ï¼‰å¹¶æ²¡æœ‰è¢«å®é™…ä½¿ç”¨ï¼Œå› è€Œå¯ä»¥å®‰å…¨åœ°å‡å°‘å…¨å±€æ·±åº¦ã€‚\nGetSplitImageIndex GetSplitImageIndex() æ˜¯åœ¨å¯æ‰©å±•å“ˆå¸Œè¡¨ä¸­ç”¨äºæ¡¶ï¼ˆbucketï¼‰æ‹†åˆ†æ—¶ç¡®å®šæ‹†åˆ†åçš„å¦ä¸€ä¸ªæ¡¶çš„ç´¢å¼•ã€‚\nåœ¨å¯æ‰©å±•å“ˆå¸Œè¡¨ä¸­ï¼Œå½“ä¸€ä¸ªæ¡¶è£…æ»¡æ—¶ï¼Œç›®å½•å®¹é‡ä¼šç¿»å€ï¼Œè¿™ä¸ªæ¡¶ä¼šæ‹†åˆ†æˆä¸¤ä¸ªæ¡¶ï¼ˆä½†æ˜¯é™¤äº†éœ€è¦æ‹†åˆ†çš„æ¡¶ï¼Œå…¶ä»–ç›®å½•è¿˜æ˜¯æŒ‡å‘åŸæ¥çš„æ¡¶ï¼‰ã€‚\næ¯ä¸ªæ¡¶éƒ½æœ‰ä¸€ä¸ªå±€éƒ¨æ·±åº¦ï¼ˆlocal depthï¼‰ï¼Œè¡¨ç¤ºè¿™ä¸ªæ¡¶åœ¨å“ˆå¸Œè¡¨ä¸­ä½¿ç”¨äº†å¤šå°‘ä½å“ˆå¸Œå€¼æ¥å®šä½æ•°æ®ã€‚æ¡¶æ‹†åˆ†æ—¶ï¼Œå±€éƒ¨æ·±åº¦ä¼šå¢åŠ ã€‚ æ‹†åˆ†åçš„æ¡¶ä¸å½“å‰æ¡¶å…·æœ‰ç›¸åŒçš„å±€éƒ¨æ·±åº¦å€¼ï¼Œåªæ˜¯åœ¨ç¬¬ä¸€ä½ä¸Šæœ‰æ‰€ä¸åŒã€‚ä¾‹å¦‚ï¼Œå¦‚æœå½“å‰æ¡¶çš„å±€éƒ¨æ·±åº¦ä¸º 2ï¼Œé‚£ä¹ˆæ‹†åˆ†åçš„æ¡¶ä¸å…¶å‰å 2 ä½ç›¸åŒï¼Œåªæœ‰ç¬¬ 1 ä½ä¸åŒã€‚ ä¾‹å¦‚ï¼Œå½“å‰æ¡¶çš„ç´¢å¼•ä¸º 01ï¼Œå±€éƒ¨æ·±åº¦ä¸º 3ã€‚\nè®¡ç®—ç¿»è½¬ä½çš„å€¼ï¼š1 \u0026lt;\u0026lt; (local_depth - 1) = 1 \u0026lt;\u0026lt; (3 - 1) = 1 \u0026lt;\u0026lt; 2 = 100 ï¼ˆå³äºŒè¿›åˆ¶çš„ 0100ï¼‰ã€‚ æŒ‰ä½å¼‚æˆ–ï¼šbucket_index âŠ• 100 = 001 âŠ• 100 = 101ï¼ˆå³äºŒè¿›åˆ¶çš„ 101ï¼Œä¹Ÿå°±æ˜¯åè¿›åˆ¶çš„ 5ï¼‰ã€‚ å› æ­¤ï¼Œæ‹†åˆ†åçš„æ¡¶çš„ç´¢å¼•æ˜¯ 101ï¼ˆ5 in decimalï¼‰ã€‚\nGetLocalDepthMask è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯ç”¨åœ¨bucketçš„åˆ†è£‚å’Œåˆå¹¶ä¸­ï¼Œç”¨äºåˆ¤æ–­éœ€è¦æ“ä½œçš„bucketä¸­çš„é¡¹åœ¨æ›´æ–°ååº”è¯¥å±äºdirectoryä¸‹å“ªä¸ªentryå¯¹åº”çš„bucketï¼ˆæœ‰ç‚¹ç»•ï¼‰ã€‚\nå’ŒGetGlobalDepthMaskä¸€æ ·ï¼Œå½“å‰directoryçš„entryæ˜ å°„çš„bucketçš„local_depth_æ˜¯å¤šå°‘ï¼Œå…¶maskçš„äºŒè¿›åˆ¶å°±æ˜¯å¤šå°‘ä¸ª1ã€‚\nBucket Bucketå­˜å‚¨ç€å¤šä¸ªé”®å€¼å¯¹ï¼Œæ²¡æœ‰ä½¿ç”¨æ ‡å‡†åº“çš„mapï¼Œè€Œæ˜¯ä½¿ç”¨std::pairæ•°ç»„ï¼ˆå¦‚æœéƒ½ç”¨æ ‡å‡†åº“äº†è¦ä½ å®ç°å•¥å“ˆå¸Œè¡¨hhï¼‰ã€‚\n#define MappingType std::pair\u0026lt;KeyType, ValueType\u0026gt; static constexpr uint64_t HTABLE_BUCKET_PAGE_METADATA_SIZE = sizeof(uint32_t) * 2; constexpr auto HTableBucketArraySize(uint64_t mapping_type_size) -\u0026gt; uint64_t { return (BUSTUB_PAGE_SIZE - HTABLE_BUCKET_PAGE_METADATA_SIZE) / mapping_type_size; }; class ExtendibleHTableBucketPage { ... private: uint32_t size_; uint32_t max_size_; MappingType array_[HTableBucketArraySize(sizeof(MappingType))]; }; ä»»åŠ¡å°±æ˜¯åœ¨è¿™ä¸ªbucketä¸­å¢åˆ æŸ¥å¯¹åº”çš„key and valueï¼Œç”±äºå†…éƒ¨ä½¿ç”¨çš„æ˜¯å®šé•¿æ•°ç»„ï¼Œæ‰€ä»¥æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯é¡ºåºæ“ä½œã€‚\nä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨bucket pageçš„Insertæ“ä½œä¸­ï¼Œæ³¨é‡Šä¸Šç»™çš„æç¤ºæ˜¯ï¼šâ€œå½“æ’å…¥æˆåŠŸæ—¶è¿”å›trueï¼Œæ’å…¥å¤±è´¥æˆ–è€…é”®å·²ç»å­˜åœ¨æ—¶è¿”å›falseâ€ã€‚ä½†æ˜¯å¦‚æœä½ æŒ‰ç€â€œå…ˆåˆ¤æ–­bucketæ˜¯å¦æ»¡äº†ï¼Œå†éå†bucketä¸­çš„é”®å€¼å¯¹æ•°ç»„ï¼ŒæŸ¥æ‰¾æœ‰æ²¡æœ‰keyç›¸åŒçš„ï¼Œæœ€åå†æ’å…¥â€è¿™æ ·çš„é€»è¾‘å»å†™ï¼Œé‚£å½“ä½ æäº¤æ—¶æ€ä¹ˆæµ‹è¯•éƒ½æœ‰å‡ ä¸ªæµ‹è¯•é›†è¿‡ä¸äº†ï¼Œå½“æ—¶æˆ‘æƒ³å¾—è„‘å­éƒ½è¦ç‚¸äº†ä¹Ÿæƒ³ä¸æ¸…æ€ä¹ˆå›äº‹ã€‚\nåœ¨çœ‹äº†ä¸€ç¯‡åšå®¢åï¼Œæˆ‘æŒ‰ç…§ä»–çš„é€»è¾‘~~â€œå…ˆéå†æ•°ç»„ï¼Œå¦‚æœæœ‰é”®å€¼ç›¸åŒçš„ï¼Œæ›´æ–°å®ƒè€Œä¸æ˜¯è¿”å›falseï¼Œç„¶åå†åˆ¤æ–­æ˜¯å¦å·²ç»æ»¡äº†ï¼Œæ²¡æ»¡å°±å†æ’å…¥â€~~å»å†™ï¼Œæœ€åå¯¹äº†ã€‚ï¼ˆè¿™é‡Œä¸ºå•¥ç”¨äº†åˆ é™¤çº¿ï¼Œæ˜¯å› ä¸ºæˆ‘çš„ä»£ç æ˜¯æŒ‰ç…§è¿™ä¸ªé€»è¾‘æ¥å†™çš„ï¼Œä½†æ˜¯åœ¨æˆ‘å†™è¿™ç¯‡åšå®¢æ—¶æ„Ÿè§‰ä¸å¯¹åŠ²ï¼Œå‡å¦‚è¿™ä¸ªé”®å·²ç»å­˜åœ¨ï¼Œä¸”æ­¤æ—¶bucketæ²¡æœ‰æ»¡ï¼Œé‚£æ›´æ–°ä¹‹ååˆæ’å…¥äº†ä¸€æ¬¡ï¼Œæ•°æ®æœ‰é‡å¤ï¼‰\nTask3 - Extendible Hashing Implementation ç»†èŠ‚ï¼ç»†èŠ‚ï¼è¿˜æ˜¯TMDç»†èŠ‚ï¼\nå‰ä¸¤ä¸ªtaskæ¯”è¾ƒå®¹æ˜“å†™ï¼Œè¿™ä¸ªtaskå…¶å®æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„çš„è®¾è®¡å®ç°é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯å“ˆå¸Œè¡¨å¦‚ä½•æ’å…¥æ•°æ®å’Œåˆ é™¤æ•°æ®ï¼Œä½†æ˜¯ç»†èŠ‚éœ€è¦æ³¨æ„å¤ªå¤šäº†ï¼å¦‚ä½•è€ƒè™‘æ’å…¥åçš„åˆ†è£‚ï¼Œè¿˜æœ‰åˆ é™¤æ—¶çš„åˆå¹¶ã€‚ä»ç¬¬ä¸€æ¬¡æäº¤åˆ°å…¨éƒ¨é€šè¿‡ä¸€å…±ç”¨äº†7å¤©ï¼ˆå“­ï¼‰ã€‚\nInsert Insertæ“ä½œéœ€è¦æ³¨æ„çš„å°±æ˜¯æ’å…¥å¤±è´¥åçš„åˆ†è£‚é—®é¢˜ï¼Œå°ç»†èŠ‚åœ¨äºä¸‹é¢é€»è¾‘æ­¥éª¤ä¸­çš„3ï¼Œ8.5å’Œ9ï¼ˆåŠ ç²—è¡¨ç¤ºï¼‰:\næ£€æŸ¥éœ€è¦æ’å…¥çš„é”®æ˜¯å¦å·²ç»å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å°±è¿”å›falseï¼Œå¦åˆ™ç»§ç»­ç¬¬äºŒæ­¥ å¯¹keyä½¿ç”¨hashç®—æ³• ä»headeré€šè¿‡hash(key)æ‰¾åˆ°å¯¹åº”çš„directory pageï¼Œå¦‚æœdirectoryä¸å­˜åœ¨ï¼Œé‚£ä¹ˆåˆ›å»ºæ–°çš„directory pageï¼Œå†åˆ›å»ºæ–°çš„bucket pageåæ‰§è¡Œæ’å…¥ï¼›å¦åˆ™ç»§ç»­ç¬¬å››æ­¥ã€‚éœ€è¦æ³¨æ„ï¼Œå¦‚æœåˆ¤æ–­äº†directoryå­˜åœ¨åï¼Œéœ€è¦å¯¹header page guardè¿›è¡ŒDrop()æ“ä½œï¼Œå› ä¸ºå¹³å°çš„æµ‹è¯•é›†ä¸­æœ‰æ¯”è¾ƒåˆé’»çš„æƒ…å†µï¼Œå…¶buffer manager poolçš„å¤§å°åªæœ‰3ï¼Œå¦‚æœä¸æŠŠheader pageé‡Šæ”¾ï¼Œé‚£ä¹ˆåˆ°æ—¶å€™éœ€è¦è¿›è¡Œåˆ†è£‚æ—¶æ— æ³•å†è·å–ä¸€ä¸ªæ–°çš„pageï¼ ä»directoryé€šè¿‡hash(key)æ‰¾åˆ°å¯¹åº”çš„bucket pageï¼Œå¦‚æœpageä¸å­˜åœ¨ï¼Œé‚£ä¹ˆåˆ›å»ºæ–°çš„bucket pageå†æ’å…¥ï¼›å¦åˆ™ç»§ç»­ç¬¬äº”æ­¥ å‘bucket pageä¸­æ’å…¥é”®å€¼å¯¹ï¼Œå¦‚æœæ’å…¥æˆåŠŸï¼Œè¿”å›trueï¼›å¦åˆ™ç»§ç»­ç¬¬å…­æ­¥ ï¼ˆå¾ªç¯å¼€å§‹ï¼‰ æ£€æŸ¥å½“å‰directoryæ˜¯å¦å·²ç»æ»¡äº†ï¼Œæ¯”å¦‚è¯´directoryçš„max_depth_æ˜¯2ï¼Œé‚£ä¹ˆè¯´æ˜æœ€å¤šåªèƒ½æœ‰å››ä¸ªbucket pageï¼Œè‹¥æ­¤æ—¶å·²ç»æœ‰å››ä¸ªbucketäº†ï¼Œé‚£ä¹ˆå·²ç»æ»¡äº†ï¼Œæ— æ³•ç»§ç»­åˆ†è£‚æ¡¶ï¼›æ²¡æ»¡ç»§ç»­ç¬¬å…«æ­¥ åˆ†è£‚æ¡¶ å…ˆåˆ›å»ºæ–°çš„bucket pageä½œä¸ºå½“å‰bucketçš„é•œåƒæ¡¶ å¦‚æœglobal depthç­‰äºå½“å‰bucketçš„local depthï¼Œè¯´æ˜éœ€è¦æ‰©å……directoryçš„å¤§å°ï¼ŒåŒæ—¶è°ƒæ•´æ‰©å……åçš„directoryä¸­çš„entryä¸bucketçš„æ˜ å°„ åœ¨directoryä¸­è®¾ç½®é•œåƒæ¡¶ï¼Œå¢åŠ åŸæ¡¶å’Œé•œåƒæ¡¶çš„local depthï¼Œæ­¤æ—¶è·å–åŸæ¡¶çš„local depthå¯¹åº”çš„mask é€šè¿‡maskå°†åŸæ¡¶æ‹†æˆä¸¤ä¸ªæ¡¶ï¼Œæ¯”å¦‚åŸæ¡¶çš„local depthä¸º2ï¼Œå¯¹åº”çš„maskçš„äºŒè¿›åˆ¶ä¸º$(11)_2$ï¼Œé€šè¿‡\u0026amp;æ“ä½œè·å–æ¡¶ä¸­æ¯ä¸ªé”®å€¼å¯¹çš„hash(key)çš„æœ€ä½ä¸¤ä½ï¼Œå¦‚æœä¸bucket_index \u0026amp; maskç›¸åŒï¼Œé‚£ä¹ˆå°±è¯´æ˜è¿™ä¸ªé”®å€¼å¯¹åº”è¯¥ç•™åœ¨åŸæ¡¶ï¼Œåä¹‹åº”è¯¥ç§»è‡³é•œåƒæ¡¶ åˆ†è£‚æˆä¸¤ä¸ªæ¡¶åï¼Œåœ¨ä½¿ç”¨maskåˆ¤æ–­éœ€è¦æ’å…¥çš„é”®å€¼å¯¹åº”è¯¥æ’å…¥é‚£ä¸ªæ¡¶ï¼Œè®°å½•æ’å…¥æ˜¯å¦æˆåŠŸ è€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µï¼Œéœ€è¦æ’å…¥çš„bucketæ»¡äº†åè¦è¿›è¡Œåˆ†è£‚ï¼Œä½†æ˜¯æœ‰å¯èƒ½åˆ†è£‚ååŸæ¥çš„é”®å€¼å¯¹è¿˜æ˜¯åœ¨ä¸€ä¸ªbucketä¸­ï¼Œé‚£è¿™ä¸ªæ—¶å€™æ’å…¥å°±å¤±è´¥äº†ï¼Œæ‰€ä»¥éœ€è¦ç»§ç»­ä»ç¬¬ä¸ƒæ­¥æ‰§è¡Œï¼Œç›´åˆ°directoryæ»¡äº†æˆ–è€…æ’å…¥æˆåŠŸ ï¼ˆå¾ªç¯ç»“æŸï¼‰ return true Remove ç”±äºè¯¾ç¨‹è¦æ±‚ä¸èƒ½å…¬å¼€ä»£ç ï¼ŒåŠ ä¸Šç½‘ä¸Šå…³äºå¯æ‹“å±•å“ˆå¸Œçš„æ“ä½œå¤šåªæœ‰Insertï¼Œè€ŒRemoveå¾ˆå°‘æœ‰ä»‹ç»è¯´æ˜çš„ï¼Œæ‰€ä»¥ä¸å¾—ä¸å»æ€è€ƒå¾ˆå¤šæƒ…å†µï¼ŒåŠ ä¸Šè‡ªå·±ç”»å›¾å»ç†è§£ï¼Œå½“ç„¶è¿˜æ˜¯å»çœ‹äº†å‡ ç¯‡å¤§ä½¬çš„åšå®¢æˆ‘æ‰æ…¢æ…¢å†™å‡ºäº†è§£å†³æ–¹æ¡ˆã€‚\nå®éªŒæŒ‡å¯¼ä¸­è¯´äº†å¯¹äºRemoveçš„åˆå¹¶éœ€è¦è¿›è¡Œé€’å½’çš„å¤„ç†ï¼Œä½†å…¶å®æˆ‘ä»¬ç”¨å¾ªç¯å»å¤„ç†å°±è¡Œï¼Œè‡³äºä¸ºä»€ä¹ˆè¦é€’å½’å»å¤„ç†ï¼Œä¸‹é¢çš„æ­¥éª¤9å’Œæ­¥éª¤13ä¸­æœ‰åŠ ç²—è§£é‡Šï¼š\nå¯¹keyä½¿ç”¨hashç®—æ³• ä»headeré€šè¿‡hash(key)æ‰¾åˆ°å¯¹åº”çš„directory pageï¼Œå¦‚æœdirectoryä¸å­˜åœ¨ï¼Œreturn falseï¼›å¦åˆ™ç»§ç»­ç¬¬3æ­¥ã€‚ç±»ä¼¼Insertï¼Œè¿™é‡Œä¹Ÿéœ€è¦Drop header page ä»directoryé€šè¿‡hash(key)æ‰¾åˆ°å¯¹åº”çš„bucket pageï¼Œå¦‚æœpageä¸å­˜åœ¨ï¼Œé‚£return falseï¼›å¦åˆ™ç»§ç»­ç¬¬4æ­¥ åˆ é™¤bucketä¸­çš„keyå¯¹åº”çš„é”®å€¼å¯¹ï¼Œå¦‚æœåˆ é™¤å¤±è´¥ï¼Œè¿”å›falseï¼›å¦åˆ™ç»§ç»­ç¬¬5æ­¥ å¦‚æœåˆ é™¤æˆåŠŸåbucketä¸ä¸ºç©ºï¼Œè¯´æ˜ä¸éœ€è¦åˆå¹¶ï¼Œè¿”å›trueï¼›å¦åˆ™ç»§ç»­ç¬¬6æ­¥ ï¼ˆå¾ªç¯å¼€å§‹ï¼‰ è·å–å½“å‰bucketçš„é•œåƒbucketï¼Œå¦‚æœäºŒè€…çš„local depthä¸ç›¸åŒï¼Œé‚£ä¹ˆç»“æŸå¾ªç¯ï¼›å¦åˆ™ç»§ç»­ç¬¬8æ­¥ å½“å‰æ¡¶å’Œé•œåƒæ¡¶å¯ä»¥åˆå¹¶ï¼Œå°†å½“å‰æ¡¶çš„æ˜ å°„æ›´æ–°åˆ°é•œåƒæ¡¶ï¼Œå¹¶ä¸”local depthéƒ½ -1ï¼Œåˆ é™¤å½“å‰æ¡¶çš„bucket page åˆ é™¤äº†bucket_indexå¯¹åº”çš„pageåï¼Œè™½ç„¶è°ƒæ•´äº†å…¶å¯¹åº”çš„local depthå’Œpage idï¼Œä½†æ˜¯è¿˜åº”è¯¥éå†æ‰€æœ‰çš„å¯æˆä¸ºé•œåƒæ¡¶çš„indexï¼Œå¦‚æœå®ƒä»¬çš„local depthç›¸åŒï¼Œä¹Ÿåº”è¯¥åˆå¹¶ï¼Œè®°å½•éœ€è¦åˆå¹¶çš„çš„bucketçš„page id åœ¨éå†æ—¶ä¸éœ€è¦ä¸€ä¸ªä¸€ä¸ªå»éå†directoryçš„entryï¼Œè€Œæ˜¯å¯ä»¥è·³ç€éå†ï¼šåªæœ‰indexçš„ålocal_depth - 1ä½ç›¸åŒçš„æ‰å¯èƒ½éœ€è¦åˆå¹¶ å¦‚æœéœ€è¦åˆå¹¶çš„çš„bucketçš„page idæ•°é‡ä¸º0ï¼Œè¯´æ˜å·²ç»æ²¡æœ‰å¯ä»¥åˆå¹¶çš„bucketäº†ï¼Œä¸åº”è¯¥ç»§ç»­åˆå¹¶ï¼Œå¯ä»¥ç»“æŸå¾ªç¯äº†ï¼›å¦åˆ™ç»§ç»­ç¬¬11æ­¥ å› ä¸ºåˆåˆå¹¶äº†ï¼Œæ‰€ä»¥åŸæ¡¶å’Œå…¶é•œåƒæ¡¶å¯¹åº”çš„ local depth åˆè¦ -1 åˆ é™¤éœ€è¦åˆå¹¶çš„çš„bucketçš„page ä»ç¬¬7æ­¥ç»§ç»­ï¼Œå› ä¸ºåˆå¹¶åçš„bucketåœ¨å…¶local depth - 1åå¯èƒ½ä¼šç¢°åˆ°å’Œå…¶local depthç›¸åŒçš„bucketï¼Œä¸”å…¶ä¸­è¿˜æœ‰ç©ºçš„bucketï¼Œè¿™å°±éœ€è¦ä¸æ–­å»åˆå¹¶ï¼ˆè¿™å°±æ˜¯å®éªŒä¸­è¯´çš„é€’å½’åˆå¹¶ï¼‰ ï¼ˆå¾ªç¯ç»“æŸï¼‰ ç¼©å‡ç›®å½•å¤§å°ï¼Œç›´åˆ°æ— æ³•ç¼©å° return true Reference https://www.cnblogs.com/wevolf/p/18302985 https://zhuanlan.zhihu.com/p/622221722 https://zhuanlan.zhihu.com/p/701875021 ","permalink":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project2-extendible-hash-index-%E5%B0%8F%E7%BB%93/","summary":"è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nå¤ªèœäº†ï¼Œä»æ²¡æ‰“è¿‡è¿™ä¹ˆè‰°éš¾çš„ä»—QAQã€‚ç”±äºè¯¾ç¨‹çš„è¦æ±‚ä¸èƒ½å…¬å¼€æºä»£ç ï¼Œæ‰€ä»¥ç½‘ä¸Šçš„èµ„æºä¼šå°‘å¾ˆå¤šï¼Œå¹³å°ä¸Šçš„æµ‹è¯•æ¡ˆä¾‹æ¯”è¾ƒå…¨é¢ï¼Œæœ‰çš„è¿˜æ¯”è¾ƒåˆé’»ï¼Œéœ€è¦è€ƒè™‘åˆ°å¯æ‹“å±•å“ˆå¸Œçš„å®ç°ç»†èŠ‚ã€‚åœ¨è‡ªè®¤ä¸ºå†™å®Œäº†åï¼Œæäº¤äº†è¿‘40æ¥æ¬¡æ€»æœ‰å‡ ä¸ªæµ‹è¯•é›†è¿‡ä¸äº†ï¼Œè¿˜å¥½æ²¡æœ‰å´©æºƒï¼Œåœ¨çœ‹äº†å‡ ç¯‡åšå®¢çš„æ–¹æ³•åï¼ŒåŠ ä¸Šè‡ªå·±ç”»å›¾ç†è§£ï¼Œæœ€åç»ˆäºè¿‡äº†ğŸ˜­ã€‚ä¸è¿‡å›å¤´å†™åšå®¢çš„æ—¶å€™å†å»çœ‹ä»£ç ï¼Œä¹Ÿæ²¡æœ‰ç‰¹åˆ«çš„å¤æ‚ï¼Œè¿˜æ˜¯å¾—æ˜ç™½å…¶ä¸­çš„ç®—æ³•é€»è¾‘æ˜¯å¦‚ä½•å®ç°çš„ã€‚\nTask1 - Read/Write Page Guards ç®€å•æ¥è¯´ï¼Œå°±æ˜¯ä¸ºPageå®ç°ä¸€ä¸ªRAIIæ¥è‡ªåŠ¨ç®¡ç†èµ„æºã€‚å› ä¸ºåœ¨BufferPoolManager::Unpinä¸­ï¼Œæ¯æ¬¡è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œéƒ½ä¼šè®©å¯¹åº”çš„pageçš„pin_count_ - 1ï¼Œå½“è¿™ä¸ªå€¼ä¸º0æ—¶ï¼Œè¿™ä¸ªpageå°±å¯ä»¥è¢«å›æ”¶ï¼Œæˆ–è€…è¯´è¢«æ›¿æ¢äº†ã€‚ä½†å¦‚æœæˆ‘ä»¬å¿˜è®°å»æ‰‹åŠ¨è°ƒç”¨ï¼Œè¯¥é¡µé¢å°†æ°¸è¿œä¸ä¼šè¢«é€å‡ºç¼“å†²æ± ã€‚ç”±äºç¼“å†²æ± ä»¥æ›´å°‘çš„å¸§æ•°è¿è¡Œï¼Œç£ç›˜å†…å¤–çš„é¡µé¢äº¤æ¢å°†æ›´å¤šã€‚ä¸ä»…æ€§èƒ½å—åˆ°å½±å“ï¼Œè€Œä¸”å¾ˆéš¾æ£€æµ‹åˆ°é”™è¯¯ã€‚\nä¸»è¦éœ€è¦è€ƒè™‘å¦‚ä½•ç¼–å†™ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼çš„é€»è¾‘ã€‚ç§»åŠ¨äº†ä¸€ä¸ªå¯¹è±¡åï¼ŒåŸæ¥çš„å¯¹è±¡çš„èµ„æºåº”è¯¥è½¬ç§»åˆ°äº†æ–°å¯¹è±¡ä¸Šï¼Œé‚£ä¹ˆåŸæ¥çš„å¯¹è±¡æ— æ³•å†è®¿é—®èµ„æºï¼ˆå°†åŸæ¥å¯¹è±¡çš„èµ„æºé‡ç½®nullptræˆ–æ¸…ç©ºï¼‰ã€‚\nè¿˜æœ‰ä¸€ä¸ªDrop()çš„æ¥å£ï¼Œè¿™æ˜¯æä¾›ç»™ä½¿ç”¨è€…çš„é‡Šæ”¾èµ„æºçš„apiï¼Œåœ¨å®ç°è™šæ„å‡½æ•°æ—¶å¯ä»¥ç›´æ¥è°ƒç”¨å®ƒã€‚Dropçš„å®ç°å°±æ˜¯è°ƒç”¨Unpinï¼Œç„¶åç½®ç©ºèµ„æºã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿›è¡Œç§»åŠ¨èµ‹å€¼æ—¶ï¼Œä¸€å¼€å§‹ä¹Ÿè¦Dropä¸€ä¸‹ï¼Œè€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µï¼š\nauto p = std::move(basic_page_guard); p = std::move(basic_page_guard2); è¿™ä¸ªæ—¶å€™åŒä¸€ä¸ªå˜é‡pæ¥ç®¡äº†ä¸¤ä¸ªpageï¼Œé‚£ä¹ˆåº”è¯¥åœ¨ç¬¬äºŒä¸ªç§»åŠ¨èµ‹å€¼æ—¶å…ˆdropæ‰ç¬¬ä¸€ä¸ªï¼Œå› ä¸ºç¬¬ä¸€ä¸ªpageä¸å†ä½¿ç”¨äº†ï¼Œè‡ªç„¶è¦Unpinã€‚\nè¿˜æœ‰å°±æ˜¯åœ¨ä¸‰ä¸ªpage guardç±»é‡è½½ç§»åŠ¨èµ‹å€¼æ—¶ï¼Œå¦‚æœéœ€è¦ç§»åŠ¨çš„å¯¹è±¡å’Œè‡ªèº«æ˜¯åŒä¸€ä¸ªï¼Œé‚£ä¹ˆç›´æ¥è¿”å›è‡ªå·±å°±å¥½ï¼š\nauto BasicPageGuard::operator=(BasicPageGuard \u0026amp;\u0026amp;that) noexcept -\u0026gt; BasicPageGuard \u0026amp; { if (\u0026amp;that == this) { return *this; } // ... å…¶ä»–æ“ä½œ } åœ¨ReadPageGuardå’ŒWritePageGuardçš„Drop()ä¸­ï¼Œè¿˜éœ€è¦è€ƒè™‘é‡Šæ”¾ç®¡ç†çš„pageçš„é”ã€‚å¯¹åº”çš„ï¼Œé”çš„è·å–å‘ç”Ÿåœ¨FetchPageWrite()å’ŒFetchPageWrite()ä¸­ã€‚\nTask2 - Extendible Hash Table Pages ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å¯æ‰©å±•å“ˆå¸Œï¼Ÿ\nä¸‹å›¾æ¥æºï¼šhttps://www.bilibili.com/video/BV1Qt421w7JT\nåœ¨bustubçš„è®¾è®¡ä¸­ï¼ŒHeader Pageï¼ŒDirectory Pageå’ŒBucket Pageéƒ½æ˜¯æ— æ³•ç›´æ¥æ„é€ å‡ºæ¥çš„ï¼Œå³ä¸èƒ½é€šè¿‡æ„é€ å‡½æ•°åˆ›å»ºï¼Œåªèƒ½é€šè¿‡å„è‡ªçš„PageGuardä¸­çš„As()æˆ–è€…AsMut()å‡½æ•°æ¥è½¬æ¢ã€‚\nHeader header pageä¸­æœ‰ä¸€ä¸ªmax_depth_çš„æˆå‘˜å˜é‡ï¼Œ1 \u0026lt;\u0026lt; max_depth_å³ä¸ºheader pageä¸­èƒ½å­˜æ”¾çš„ç›®å½•çš„ç´¢å¼•çš„æ•°é‡ã€‚å½“æˆ‘ä»¬æœ‰å€¼éœ€è¦æ”¾å…¥å“ˆå¸Œè¡¨æ—¶ï¼Œè·å–hash(key)çš„äºŒè¿›åˆ¶æœ€é«˜max_depth_ä½ä½œä¸ºç´¢å¼•ï¼Œå†ä»headerä¸­å¯¹åº”ä½ç½®å»æ‰¾åˆ°directoryã€‚å¯¹åº”çš„ExtendibleHTableHeaderPageä¸­çš„åŠŸèƒ½å®ç°å¹¶ä¸éš¾ã€‚\nDirectory directoryä¸­æœ‰ä¸¤ä¸ªdepthï¼š\nGlobal Depthï¼šè‹¥global depthä¸ºnï¼Œé‚£ä¹ˆè¿™ä¸ªDirectoryå°±æœ‰2^nä¸ªentryï¼ˆç›¸å½“äºæŒ‡å‘2^nä¸ªbucketï¼‰ Local Depthï¼šè‹¥local depthä¸ºnï¼Œåˆ™åœ¨è¿™ä¸ªå¯¹åº”çš„bucketä¸‹ï¼Œæ¯ä¸ªå…ƒç´ çš„keyçš„æœ€ånä½éƒ½ç›¸åŒ ç±»ä¼¼headerä¸­è·å–ä¸‹ä¸€çº§é¡µçš„ç´¢å¼•ï¼Œdirectoryè·å–hash(key)çš„äºŒè¿›åˆ¶æœ€ä½global_depth_ä½ä½œä¸ºç´¢å¼•ã€‚é‚£local depthçš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ","title":"ã€CMU15-445 Fall2023ã€‘Project2 Extendible Hash Index å°ç»“"},{"content":"ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦copy on write é€šè¿‡xv6çš„å®éªŒæŒ‡å¯¼ä¹¦ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š\nxv6ä¸­çš„fork()ç³»ç»Ÿè°ƒç”¨å°†çˆ¶è¿›ç¨‹çš„æ‰€æœ‰ç”¨æˆ·ç©ºé—´å†…å­˜å¤åˆ¶åˆ°å­è¿›ç¨‹ä¸­ã€‚å¦‚æœçˆ¶è¿›ç¨‹æ‰€ä½¿ç”¨çš„é¡µæ•°å¾ˆå¤§ï¼Œå¤åˆ¶å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œè€Œè¿™æ ·çš„å¤åˆ¶æ“ä½œç»å¸¸æ˜¯æ²¡æœ‰ç”¨çš„ï¼šfork()ä¹‹åé€šå¸¸æ˜¯å­è¿›ç¨‹ä¸­çš„exec()ï¼Œè¿™ä¼šä¸¢å¼ƒå¤åˆ¶çš„å†…å­˜è€Œä¸æ˜¯ä½¿ç”¨å®ƒä»¬ã€‚\né‚£ä¹ˆï¼Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥åœ¨å­è¿›ç¨‹åˆšåˆ›å»ºæ—¶å°†å…¶é¡µè¡¨çš„æ˜ å°„åˆ°çˆ¶è¿›ç¨‹çš„ç‰©ç†é¡µï¼Œè€Œåœ¨å…¶éœ€è¦å¯¹å†…å­˜è¿›è¡Œå†™æ“ä½œæ—¶å†é‡æ–°åˆ†é…å†…å­˜å‘¢ï¼Ÿæ²¡é”™ï¼Œè¿™å°±æ˜¯é€šè¿‡copy on writeï¼ˆå†™æ—¶å¤åˆ¶ï¼‰æŠ€æœ¯æ¥è¿›è¡Œä¼˜åŒ–ã€‚\nè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼šä»“åº“commit\nå¤§è‡´æ€è·¯ é¦–å…ˆè¯´ä¸€ä¸‹å¤§è‡´æ€è·¯ï¼š\nåœ¨ä½¿ç”¨forkç³»ç»Ÿè°ƒç”¨åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œæˆ‘ä»¬ä¸ç”¨å»é¢å¤–æ‹·è´çˆ¶è¿›ç¨‹çš„å†…å­˜ï¼Œè€Œæ˜¯å°†å­è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜æ˜ å°„åˆ°å’Œçˆ¶è¿›ç¨‹ç›¸åŒçš„ç‰©ç†å†…å­˜ï¼Œå¹¶ä¸”æ­¤æ—¶åº”è¯¥å°†çˆ¶å­è¿›ç¨‹å¯¹è¿™å—å†…å­˜çš„è®¿é—®æƒé™è®¾ç½®ä¸ºåªè¯»ï¼Œå¹¶ä¸”æ·»åŠ ä¸€ä¸ªç”¨äºè¯†åˆ«COWï¼ˆcopy on writeï¼‰çš„æ ‡å¿—ï¼š\nå½“å­è¿›ç¨‹éœ€è¦å¯¹å†…å­˜è¿›è¡Œå†™æ“ä½œæ—¶ï¼ŒRISC-Vä¼šæ£€æµ‹åˆ°è¿™ä¸€å—ç‰©ç†åœ°å€çš„æƒé™ä¸ºåªå†™ï¼Œè§¦å‘Page Faultï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥ä¸ºå­è¿›ç¨‹é‡æ–°åˆ†é…ä¸€å—å†…å­˜ç©ºé—´ï¼ˆå–æ¶ˆä¹‹å‰çš„æ˜ å°„ï¼Œåˆ†é…å†…å­˜åé‡æ–°æ˜ å°„è‡³æ–°å†…å­˜ï¼‰ï¼Œå¹¶å°†çˆ¶å­è¿›ç¨‹çš„å¯¹åº”ç‰©ç†é¡µçš„è¯†åˆ«æ ‡å¿—ä½è¿›è¡Œä¿®æ”¹ï¼Œå»é™¤cowæ ‡å¿—PTE_COWï¼Œæ·»åŠ å†™æƒé™æ ‡å¿—PTE_Wï¼š\nå…·ä½“å®ç° COWæ ‡å¿—ä½ é¦–å…ˆæˆ‘ä»¬éœ€è¦ä¸ºPTEæ·»åŠ ä¸€ä¸ªç”¨äºè¯†åˆ«COWçš„æ ‡å¿—ä½ï¼Œä¸Šå›¾å±•ç¤ºäº†PTEçš„å10ä½ä¹Ÿå°±æ˜¯å…¶flagsçš„æƒ…å†µï¼Œå¯ä»¥çœ‹åˆ°ç¬¬8ã€9ä½æ˜¯ä¿ç•™æ²¡æœ‰è¢«ä½¿ç”¨çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨ç¬¬8ä½æ¥ä½œä¸ºCOWçš„æ ‡å¿—ä½ï¼š\n// riscv.h #define PTE_COW (1L \u0026lt;\u0026lt; 8) ä¿®æ”¹uvmcopy åœ¨xv6çš„forkç³»ç»Ÿè°ƒç”¨ä¸­ï¼Œå­è¿›ç¨‹æ‹·è´çˆ¶è¿›ç¨‹çš„ç‰©ç†é¡µä½¿ç”¨äº†uvmcopy()å‡½æ•°ï¼š\nint fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } ... } é‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¿®æ”¹uvmcopyä¸­çš„ä»£ç ï¼Œå°†åŸå…ˆçš„æ‹·è´å†…å­˜çš„æ“ä½œå»æ‰ï¼Œå¹¶å°†PTEçš„åªè¯»æ ‡å¿—ä½å»é™¤ã€æ·»åŠ cowæ ‡è®°ä½ï¼š\nint uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i \u0026lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmcopy: page not present\u0026#34;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); // è¿™é‡Œç§»é™¤äº†æ‹·è´çš„ä»£ç ï¼Œå¹¶è®¾ç½®äº†çˆ¶è¿›ç¨‹ç›¸åº”çš„æ ‡å¿—ä½ if (flags \u0026amp; PTE_W) { *pte = (*pte \u0026amp; ~PTE_W) | PTE_COW; flags = (flags \u0026amp; ~PTE_W) | PTE_COW; } // å°†å­è¿›ç¨‹çš„è™šæ‹Ÿé¡µæ˜ å°„è‡³çˆ¶è¿›ç¨‹çš„ç‰©ç†é¡µï¼ŒåŒæ—¶è®¾ç½®äº†å­è¿›ç¨‹ç›¸åº”çš„æ ‡å¿—ä½ if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){ goto err; } // è¿™é‡Œæ˜¯å¯¹ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°è¿›è¡Œ+1ï¼Œåæ–‡ä¼šè¯´æ˜ kref_inc((void*)pa); } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } å¼•ç”¨è®¡æ•° Ensure that each physical page is freed when the last PTE reference to it goes away \u0026ndash; but not before. A good way to do this is to keep, for each physical page, a \u0026ldquo;reference count\u0026rdquo; of the number of user page tables that refer to that page. Set a page\u0026rsquo;s reference count to one whenÂ kalloc()Â allocates it. Increment a page\u0026rsquo;s reference count when fork causes a child to share the page, and decrement a page\u0026rsquo;s count each time any process drops the page from its page table.Â kfree()Â should only place a page back on the free list if its reference count is zero. It\u0026rsquo;s OK to to keep these counts in a fixed-size array of integers.\nå½“æˆ‘ä»¬é‡‡å–äº†cowåï¼Œåªæœ‰å½“æ‰€æœ‰è™šæ‹Ÿé¡µéƒ½æ²¡æœ‰å¼•ç”¨æŸä¸€ç‰©ç†é¡µæ—¶è¿™ä¸ªç‰©ç†é¡µæ‰èƒ½è¢«é‡Šæ”¾ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥å¯¹æ¯ä¸€ä¸ªç‰©ç†é¡µè¿›è¡Œå¼•ç”¨è®¡æ•°ï¼Œå½“forkå¯¼è‡´å­è¿›ç¨‹å…±äº«ç‰©ç†é¡µæ—¶ï¼Œå¯¹åº”çš„ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°+1ï¼Œå½“æœ‰è¿›ç¨‹ä¸å†ä½¿ç”¨ç‰©ç†é¡µæ—¶ï¼Œå¯¹åº”çš„ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°-1ï¼Œå›æ”¶ç‰©ç†é¡µçš„kfree()å‡½æ•°åªæœ‰å½“ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°ä¸º0æ—¶æ‰ä¼šå°†å…¶æ”¾å›ç©ºé—²åˆ—è¡¨ã€‚\n// kalloc.c struct { struct spinlock lock; // ä¿è¯æ“ä½œçš„åŸå­æ€§ int ref_count[(PGROUNDUP(PHYSTOP)) / PGSIZE]; // KERNBASEï½PHYSTOPæ˜¯ç‰©ç†å†…å­˜çš„å¤§å°ï¼Œå› ä¸ºxv6çš„å†…æ ¸åœ°å€é‡‡ç”¨äº†ç›´æ¥æ˜ å°„ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨PHYSTOPã€‚PHYSTOP / PGSIZEåˆ™è¡¨ç¤ºæœ‰å¤šå°‘ä¸ªç‰©ç†é¡µ } kref; å†…æ ¸åœ¨ä½¿ç”¨kinit()è¿›è¡Œåˆå§‹åŒ–æ—¶ï¼Œéœ€è¦åˆå§‹åŒ–krefçš„é”ï¼Œå¹¶è®¾ç½®å¼•ç”¨è®¡æ•°æ•°ç»„çš„å€¼ï¼š\nvoid kinit() { initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); initlock(\u0026amp;kmem.lock, \u0026#34;kref\u0026#34;); // è¿™é‡Œåˆå§‹åŒ–æ—¶ç½®ä¸º1æ˜¯ä¸ºäº†æ¥ä¸‹æ¥çš„freerangeåœ¨è°ƒç”¨kfreeæ—¶ä¸ä¼šè§¦å‘panic for (int i = 0; i \u0026lt; PGROUNDUP(PHYSTOP) / PGSIZE; i++) { kref.ref_count[i] = 1; } freerange(end, (void*)PHYSTOP); } åœ¨kfree()ä¸­å¯¹ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°æ¥åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡Šæ”¾ç‰©ç†å†…å­˜ï¼š\nvoid kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // å¦‚æœåœ¨è¿˜æœªå¯¹ref countæ“ä½œå‰å…¶å€¼å·²ç»å°äºç­‰äº0ï¼Œè¯´æ˜å·²æœ‰é—®é¢˜ if (kref.ref_count[(uint64)pa / PGSIZE] \u0026lt;= 0) { panic(\u0026#34;kref\u0026#34;); } // æ¯æ¬¡freeä¸€ä¸ªpageæ—¶ï¼Œå…ˆå°†è¿™ä¸ªpageçš„å¼•ç”¨è®¡æ•°-1 kref_dec(pa); // ref count - 1ï¼Œå¦‚æœç»“æœè¿˜å¤§äº0ï¼Œè¯´æ˜è¿™ä¸ªç‰©ç†é¡µè¿˜è¢«å…¶ä»–è¿›ç¨‹å¼•ç”¨ï¼Œæš‚æ—¶ä¸éœ€è¦é‡Šæ”¾ if (kref.ref_count[(uint64)pa / PGSIZE] \u0026gt; 0) { return; } // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(\u0026amp;kmem.lock); r-\u0026gt;next = kmem.freelist; kmem.freelist = r; release(\u0026amp;kmem.lock); } æ¯åˆ†é…ä¸€ä¸ªç‰©ç†é¡µæ—¶ï¼Œè¯¥ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°åˆå§‹ä¸º1ï¼š\nvoid * kalloc(void) { struct run *r; acquire(\u0026amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-\u0026gt;next; release(\u0026amp;kmem.lock); if (r) { memset((char*)r, 5, PGSIZE); // fill with junk // è¿™é‡Œèµ‹å€¼ä¸º1ä¸€å®šè¦åœ¨è®¾ç½®åƒåœ¾æ•°å€¼ä¹‹åï¼Œå¦åˆ™ä¼šé€ æˆæ±¡æŸ“ acquire(\u0026amp;kref.lock); kref.ref_count[(uint64)r / PGSIZE] = 1; release(\u0026amp;kref.lock); } return (void*)r; } å°†å¼•ç”¨è®¡æ•°çš„æ“ä½œå°è£…ä¸€ä¸‹ï¼š\n// kalloc.c // ä¸ºpaæ‰€åœ¨çš„pageçš„å¼•ç”¨+1 void kref_inc(void* pa) { acquire(\u0026amp;kref.lock); ++kref.ref_count[(uint64)pa / PGSIZE]; release(\u0026amp;kref.lock); } // ä¸ºpaæ‰€åœ¨çš„pageçš„å¼•ç”¨-1 void kref_dec(void* pa) { acquire(\u0026amp;kref.lock); --kref.ref_count[(uint64)pa / PGSIZE]; release(\u0026amp;kref.lock); } page faultæ—¶åˆ†é…æ–°å†…å­˜ å½“éœ€è¦åˆ†é…æ–°å†…å­˜æ—¶ï¼Œè¦æ£€æµ‹è™šæ‹Ÿé¡µçš„cowæ ‡å¿—ä½æ˜¯å¦æœ‰æ•ˆã€‚åœ¨åˆ†é…äº†å†…å­˜åï¼Œæ‹·è´åŸæ¥çš„ç‰©ç†é¡µä¸­çš„æ•°æ®åˆ°æ–°çš„ç‰©ç†é¡µï¼Œå¹¶å°†è™šæ‹Ÿé¡µçš„æ ‡å¿—ä½ä¸­çš„cowå»é™¤ã€æ·»åŠ å†™æ ‡å¿—ï¼Œæœ€åå–æ¶ˆè™šæ‹Ÿé¡µä¸åŸæ¥ç‰©ç†é¡µçš„æ˜ å°„å…³ç³»ï¼ŒåŒæ—¶åœ¨è§£é™¤æ—¶å¯¹å¼•ç”¨è®¡æ•°-1ï¼Œç„¶åå°†è™šæ‹Ÿé¡µæ˜ å°„è‡³æ–°çš„ç‰©ç†é¡µï¼š\n// å½“å‡ºç°page faultæ—¶ï¼Œè¿›è¡Œcowæ“ä½œ int cow_alloc(pagetable_t pagetable, uint64 va) { if (va \u0026gt;= MAXVA) { return -1; } if ((va % PGSIZE) != 0) { return -1; } pte_t *pte = walk(pagetable, va, 0); if (pte == 0) return -1; uint64 pa = PTE2PA(*pte); if (pa == 0) return -1; // å½“pageçš„cowæ ‡å¿—ä½æœ‰æ•ˆæ—¶æ‰ä¼šé‡æ–°åˆ†é…å†…å­˜ if ((*pte \u0026amp; PTE_COW) \u0026amp;\u0026amp; (*pte \u0026amp; PTE_V)) { char* mem = kalloc(); if (mem == 0) { return -1; } uint64 flags = PTE_FLAGS(*pte); flags = (flags \u0026amp; ~PTE_COW) | PTE_W; // å»é™¤COWæ ‡è®°ï¼ŒåŠ ä¸Šå†™æƒé™æ ‡è®° memmove(mem, (char *)pa, PGSIZE); uvmunmap(pagetable, PGROUNDDOWN(va), 1, 1); // è§£é™¤ä¹‹å‰çš„æ˜ å°„ï¼Œå¹¶è®¾ç½®do_freeä¸º1ï¼Œè¿™æ ·åœ¨kfreeä¸­å¯æ¥å°†å¼•ç”¨è®¡æ•°-1 if (mappages(pagetable, va, PGSIZE, (uint64)mem, flags) \u0026lt; 0) { panic(\u0026#34;cow_alloc\u0026#34;); } } return 0; } å®éªŒæŒ‡å¯¼ä¹¦æé†’æˆ‘ä»¬åœ¨copyout()ä¸­ä¹Ÿè¦æ‰§è¡Œcowæ“ä½œï¼Œä½†è¿™é‡Œä¸ºä½•è¦è¿™ä¹ˆåšå‘¢ï¼Ÿ\nè¿™æ˜¯å› ä¸ºéœ€è¦å†…æ ¸å°†æ•°æ®é€šè¿‡copyoutæ‹·è´åˆ°ç”¨æˆ·æ€æ—¶ï¼Œå¦‚æœéœ€è¦æ‹·è´çš„ç›®æ ‡ä½ç½®æ˜¯ç”¨æˆ·è¿›ç¨‹ä¸å…¶çˆ¶è¿›ç¨‹å…±äº«çš„ï¼Œé‚£ä¹ˆè¿™æ—¶åº”è¯¥ä¼šæœ‰page faultäº§ç”Ÿï¼Œä½†æ˜¯copyoutä¸­æ˜¯é€šè¿‡walkéå†é¡µè¡¨æ¥è·å–åœ°å€çš„ï¼Œä¸ä¼šè§¦å‘page faultï¼Œå› æ­¤éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ‰§è¡Œcowã€‚\nint copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { uint64 n, va0, pa0; pte_t *pte; while(len \u0026gt; 0){ va0 = PGROUNDDOWN(dstva); if(va0 \u0026gt;= MAXVA) return -1; if (cow_alloc(pagetable, va0) \u0026lt; 0) { return -1; } ... } } usertrapä¸­è§¦å‘page fault åœ¨ä¹‹å‰forkæ“ä½œæ—¶æˆ‘ä»¬å»é™¤äº†ç‰©ç†é¡µçš„writeæ“ä½œï¼Œé‚£ä¹ˆåœ¨ä¹‹åéœ€è¦å¯¹è¯¥ç‰©ç†é¡µè¿›è¡Œå†™æ“ä½œæ—¶ï¼Œrisc-vå°±ä¼šè§¦å‘page faultäº†ã€‚\næŸ¥çœ‹risc-vçš„æ‰‹å†Œå¯ä»¥å‘ç°ï¼š\næˆ‘ä»¬éœ€è¦ä½¿ç”¨excepton code 13å’Œ15ï¼ˆè¯»å†™ï¼‰ï¼Œå½“å‘ç”Ÿpage faultæ—¶ï¼Œè¿™ä¸ªcodeä¼šä¿å­˜åœ¨scauseå¯„å­˜å™¨ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åœ¨usertrapä¸­å¯¹scauseè¿›è¡Œç›¸åº”çš„å¤„ç†å³å¯ï¼š\nvoid usertrap(void) { ... } else if (r_scause() == 13 || r_scause() == 15) { // è¿™é‡Œçš„stvalå¯„å­˜å™¨ï¼Œæˆ‘çš„ç†è§£æ˜¯ä¿å­˜äº†è§¦å‘page faultæ—¶çš„è™šæ‹Ÿåœ°å€ uint64 fault_va = r_stval(); // åˆ¤æ–­åœ°å€æ˜¯å¦ä¸åˆæ³• if (fault_va \u0026gt;= MAXVA || (fault_va \u0026lt; p-\u0026gt;trapframe-\u0026gt;sp \u0026amp;\u0026amp; fault_va \u0026gt;= (p-\u0026gt;trapframe-\u0026gt;sp - PGSIZE)) || fault_va \u0026lt;= 0) { p-\u0026gt;killed = 1; } // å°è¯•è¿›è¡Œcowæ“ä½œ if (cow_alloc(p-\u0026gt;pagetable, PGROUNDDOWN(fault_va)) \u0026lt; 0) { p-\u0026gt;killed = 1; } } else { printf(\u0026#34;usertrap(): unexpected scause %p pid=%d\\n\u0026#34;, r_scause(), p-\u0026gt;pid); printf(\u0026#34; sepc=%p stval=%p\\n\u0026#34;, r_sepc(), r_stval()); setkilled(p); } } å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿›è¡Œcowæ“ä½œä¹‹å‰ï¼Œä¸€å®šè¦å¯¹åœ°å€çš„èŒƒå›´è¿›è¡Œåˆæ³•æ€§åˆ¤æ–­ï¼Œå› ä¸ºusertestsä¸­ä¼šæœ‰éå¸¸å¤šçš„æµ‹è¯•å‡½æ•°ï¼Œå…¶ä¸­æœ‰ä¸€éƒ¨åˆ†ä¼šæ£€æµ‹åœ°å€åˆæ³•æ€§ï¼Œä¸åˆæ³•çš„åœ°å€åº”è¯¥ç›´æ¥è®©è¿›ç¨‹æ­»äº¡ã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab5-copy-on-write-fork/","summary":"\u003ch2 id=\"ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦copy-on-write\"\u003eä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦copy on write\u003c/h2\u003e\n\u003cp\u003eé€šè¿‡xv6çš„å®éªŒæŒ‡å¯¼ä¹¦ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š\u003c/p\u003e\n\u003cp\u003exv6ä¸­çš„\u003ccode\u003efork()\u003c/code\u003eç³»ç»Ÿè°ƒç”¨å°†çˆ¶è¿›ç¨‹çš„æ‰€æœ‰ç”¨æˆ·ç©ºé—´å†…å­˜å¤åˆ¶åˆ°å­è¿›ç¨‹ä¸­ã€‚å¦‚æœçˆ¶è¿›ç¨‹æ‰€ä½¿ç”¨çš„é¡µæ•°å¾ˆå¤§ï¼Œå¤åˆ¶å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œè€Œè¿™æ ·çš„å¤åˆ¶æ“ä½œç»å¸¸æ˜¯æ²¡æœ‰ç”¨çš„ï¼š\u003ccode\u003efork()\u003c/code\u003eä¹‹åé€šå¸¸æ˜¯å­è¿›ç¨‹ä¸­çš„\u003ccode\u003eexec()\u003c/code\u003eï¼Œè¿™ä¼šä¸¢å¼ƒå¤åˆ¶çš„å†…å­˜è€Œä¸æ˜¯ä½¿ç”¨å®ƒä»¬ã€‚\u003c/p\u003e\n\u003cp\u003eé‚£ä¹ˆï¼Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥åœ¨å­è¿›ç¨‹åˆšåˆ›å»ºæ—¶å°†å…¶é¡µè¡¨çš„æ˜ å°„åˆ°çˆ¶è¿›ç¨‹çš„ç‰©ç†é¡µï¼Œè€Œåœ¨å…¶éœ€è¦å¯¹å†…å­˜è¿›è¡Œå†™æ“ä½œæ—¶å†é‡æ–°åˆ†é…å†…å­˜å‘¢ï¼Ÿæ²¡é”™ï¼Œè¿™å°±æ˜¯é€šè¿‡copy on writeï¼ˆå†™æ—¶å¤åˆ¶ï¼‰æŠ€æœ¯æ¥è¿›è¡Œä¼˜åŒ–ã€‚\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼š\u003ca href=\"https://github.com/kerolt/xv6-labs-2023/commit/68fd833dc03a681c04a647ed6aae2108a1e43fbb\"\u003eä»“åº“commit\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ã€MIT6.S081ã€‘Lab5 copy-on-write fork"},{"content":"backtraceè¿™ä¸ªlabéå¸¸æœ‰æ„æ€ï¼Œè™½ç„¶å®ç°çš„ä»£ç é‡ä¸å¤šï¼Œä½†æ˜¯èƒ½è®©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£æ ˆã€æ ˆå¸§ã€æŒ‡é’ˆã€gdbçš„ä¸€äº›çŸ¥è¯†ã€‚\nè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼šä»“åº“commit\né¦–å…ˆå…ˆè§£ç­”ä¸€ä¸‹ã€RISC-V assemblyã€‘ä¸­çš„ä¸€äº›é—®é¢˜ï¼š\nQ: Which registers contain arguments to functions? For example, which register holds 13 in main\u0026#39;s call to printf? A: a0-a7, a2ä¿å­˜äº†13 Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.) A: å‡½æ•°få’Œgè¢«å†…è”ä¼˜åŒ–äº† Q: At what address is the function printf located? A: 0x000000000000064a Q: What value is in the register ra just after the jalr to printf in main? A: jalræŒ‡ä»¤çš„åä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œä¹Ÿæ˜¯å½“å‰pcå¯„å­˜å™¨ä¸­çš„åœ°å€ Q: Run the following code. unsigned int i = 0x00646c72; printf(\u0026#34;H%x Wo%s\u0026#34;, 57616, \u0026amp;i); What is the output? Here\u0026#39;s an ASCII table that maps bytes to characters. The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value? Here\u0026#39;s a description of little- and big-endian and a more whimsical description. --- A: output: He110 World è‹¥risc-vä¸ºå¤§ç«¯åºï¼Œåˆ™iåº”è¯¥è®¾ç½®æˆ0x726c6400ï¼›57616ä¸éœ€è¦å˜ï¼Œå› ä¸ºæ— è®ºæ˜¯å¤§ç«¯åºè¿˜æ˜¯å°ç«¯åºï¼Œå…¶åå…­è¿›åˆ¶éƒ½ä¸ºE110 Q: In the following code, what is going to be printed after \u0026#39;y=\u0026#39;? (note: the answer is not a specific value.) Why does this happen? printf(\u0026#34;x=%d y=%d\u0026#34;, 3); --- A: x=3 y=1403684968 yçš„å€¼æ˜¯ä¸€ä¸ªéšæœºå€¼ï¼Œå› ä¸ºæœ¬è¯¥ä¼ å…¥printfçš„ç¬¬ä¸‰ä¸ªå‚æ•°å¹¶æ²¡æœ‰ä¼ å…¥ï¼Œè€Œå…¶å¯¹åº”çš„å¯„å­˜å™¨ä¸ºa2ï¼Œæ•…yä¼šä½¿ç”¨a2ä¸­æ®‹å­˜çš„å€¼ è¿™é‡Œçš„å‡ ä¸ªé—®é¢˜ä¸æ˜¯å¾ˆéš¾ï¼Œæ¶‰åŠåˆ°äº†ä¸€äº›æ±‡ç¼–ã€å¯„å­˜å™¨çš„çŸ¥è¯†ï¼Œåœ¨æ¥ä¸‹æ¥å­¦ä¹ backtraceçš„æ—¶å€™å°†ä¼šæœ‰è¯¦ç»†è®¨è®ºã€‚\nbacktraceéœ€è¦æˆ‘ä»¬åšçš„äº‹æƒ…å¯ä»¥æ¦‚æ‹¬ä¸ºï¼šåœ¨å‘ç”Ÿé”™è¯¯çš„ç‚¹ä¹‹ä¸Šçš„å †æ ˆä¸Šçš„å‡½æ•°è°ƒç”¨åˆ—è¡¨ï¼Œå¹¶åœ¨æ¯ä¸ªå †æ ˆå¸§ä¸­æ‰“å°ä¿å­˜çš„è¿”å›åœ°å€ã€‚\nä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå°±æ˜¯ä¾‹å¦‚åœ¨gdbè°ƒè¯•ä¸­ä½¿ç”¨btæŸ¥çœ‹å‡½æ•°è°ƒç”¨æ ˆæ—¶ï¼Œéœ€è¦æˆ‘ä»¬æ‰“å°é€”ä¸­çº¢è‰²æ¡†ä¸­çš„åœ°å€ã€‚\nè¯¥labè®©æˆ‘ä»¬åœ¨kernel/printf.cä¸­å®ç°ä¸€ä¸ªbacktraceå‡½æ•°ã€‚åœ¨sys_sleepä¸­æ’å…¥å¯¹æ­¤å‡½æ•°çš„è°ƒç”¨ï¼Œç„¶åè¿è¡Œbttestè¿™ä¸ªæµ‹è¯•ç¨‹åºå°†è°ƒç”¨sleepï¼ˆä¹Ÿå°±æ˜¯ä¼šæ‰§è¡Œsys_sleepï¼‰ã€‚\né¦–å…ˆï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹xv6ä¸­æ ˆçš„ç»“æ„ï¼š\n. . +-\u0026gt; . | +-----------------+ | | | return address | | | | previous fp ------+ | | saved registers | | | local variables | | | ... | \u0026lt;-+ | +-----------------+ | | | return address | | +------ previous fp | | | saved registers | | | local variables | | +-\u0026gt; | ... | | | +-----------------+ | | | return address | | | | previous fp ------+ | | saved registers | | | local variables | | | ... | \u0026lt;-+ | +-----------------+ | | | return address | | +------ previous fp | | | saved registers | | | local variables | | $fp --\u0026gt; | ... | | +-----------------+ | | return address | | | previous fp ------+ | saved registers | $sp --\u0026gt; | local variables | +-----------------+ æ ˆæ˜¯ç”±é«˜åœ°å€å‘ä½åœ°å€å¢é•¿çš„ï¼Œrisc-vä¸­spå¯„å­˜å™¨ä»£è¡¨â€œstack pointerâ€ï¼Œå³æ ˆé¡¶æŒ‡é’ˆï¼Œfpå¯„å­˜å™¨ä»£è¡¨â€œframe pointerâ€ï¼Œä¸ºå½“å‰æ ˆå¸§çš„æŒ‡é’ˆã€‚\nå‡è®¾æœ‰ä¸€ä¸ªè¿™æ ·çš„ç¨‹åºï¼š\n#include \u0026lt;stdio.h\u0026gt; void g() { printf(\u0026#34;g()\\n\u0026#34;); } void f() { g(); printf(\u0026#34;f()\\n\u0026#34;); } int main() { f(); } å‡è®¾ç¨‹åºä¸­çš„mainå‡½æ•°é‡Œï¼Œå‡½æ•°fè°ƒç”¨äº†å‡½æ•°gï¼Œé‚£ä¹ˆåœ¨å‡½æ•°è°ƒç”¨æ ˆä¸­ä»é«˜åœ°å€åˆ°ä½åœ°å€ä¸‰ä¸ªå‡½æ•°çš„é¡ºåºä¸ºï¼šmainã€fã€gï¼›å½“gå‡½æ•°æ‰§è¡Œå®Œæˆåï¼Œå…¶æ ˆå¸§å°†ä¼šä»æ ˆä¸­å¼¹å‡ºï¼Œå¹¶ä¸”é€šè¿‡æ ˆå¸§ä¸­çš„æ•°æ®å›åˆ°è°ƒç”¨è‡ªèº«çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œå³fä¸­gçš„è°ƒç”¨å‘ç”Ÿåœ¨ç¬¬8è¡Œï¼Œå½“gæ‰§è¡Œå®Œæ¯•åï¼Œåº”è¯¥ç»§ç»­æ‰§è¡Œç¬¬9è¡Œçš„æŒ‡ä»¤ï¼Œè¿™ä¹Ÿå°±æ˜¯â€œreturn addressâ€ã€‚\næˆ‘ä»¬å¯ä»¥é€šè¿‡å†…è”æ±‡ç¼–è·å–å½“å‰æ ˆå¸§çš„çš„æŒ‡é’ˆï¼š\n// kernel/riscv.h static inline uint64 r_fp() { uint64 x; asm volatile(\u0026#34;mv %0, s0\u0026#34; : \u0026#34;=r\u0026#34; (x) ); return x; } ç„¶åä¸æ–­éå†æ ˆä¸­çš„æ ˆå¸§ï¼Œæ‰“å°å…¶return addressï¼Œç›´åˆ°éå†åˆ°æœ€åä¸€ä¸ªæ ˆå¸§ã€‚xv6åœ¨ç»™æ ˆåˆ†é…å†…å­˜æ—¶ç¡®ä¿äº†æ¯ä¸€ä¸ªæ ˆå¸§éƒ½åœ¨åŒä¸€é¡µä¸­ï¼Œè¿™æ ·çš„è¯å¯ä»¥é€šè¿‡PGROUNDDOWN(fp)å®æ¥åˆ¤æ–­fpæ˜¯å¦è¶…å‡ºæ ˆç©ºé—´ï¼š\n#define PGROUNDDOWN(a) (((a)) \u0026amp; ~(PGSIZE - 1)) xv6ä¸­é¡µçš„å¤§å°ä¸º4096Bï¼Œæ•…PGROUNDDOWN(a)å¯ä»¥è·å–aåœ°å€æ‰€åœ¨çš„é¡µå·ï¼Œæˆ–è€…è¯´è¿™ä¸€é¡µçš„æœ€é«˜åœ°å€ï¼Œåªè¦æˆ‘ä»¬çš„fpä¸ç­‰äºå®ƒï¼Œå°±è¯´æ˜æˆ‘ä»¬è¿˜æ²¡æœ‰éå†åˆ°æ ˆåº•ã€‚\nfp - 8è·å–åˆ°return addressçš„åœ°å€ï¼Œfp - 16è·å–åˆ°å½“å‰æ ˆå¸§çš„å‰ä¸€ä¸ªæ ˆå¸§çš„åœ°å€ã€‚ç”±äºxv6ä¸­è·å–çš„åœ°å€æ˜¯ç”¨uint64æ¥è¡¨ç¤ºçš„ï¼Œé‚£ä¹ˆå¯å°†å…¶å¼ºè½¬ä¸ºuint64*æ¥å°†ä¸€ä¸ªå€¼è§£é‡Šä¸ºå†…å­˜åœ°å€ï¼Œä¹‹åä¾¿å¯ä»¥è§£å¼•ç”¨è¿™ä¸ªåœ°å€è·å–å…¶ä¸­çš„å€¼äº†ã€‚\nvoid backtrace() { uint64 fp = r_fp(); printf(\u0026#34;backtrace:\\n\u0026#34;); while (fp != PGROUNDDOWN(fp)) { uint64 *return_addr = (uint64 *)(fp - 8); fp = *(uint64 *)(fp - 16); printf(\u0026#34;%p\\n\u0026#34;, *return_addr); } } å½“ç„¶ï¼Œä¹Ÿä¸è¦å¿˜è®°åœ¨kernel/def.hä¸­å£°æ˜backtraceï¼Œè¿˜æœ‰åœ¨sys_sleepä¸­è°ƒç”¨backtraceã€‚\n","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab4-trap-backtrace/","summary":"\u003cp\u003ebacktraceè¿™ä¸ªlabéå¸¸æœ‰æ„æ€ï¼Œè™½ç„¶å®ç°çš„ä»£ç é‡ä¸å¤šï¼Œä½†æ˜¯èƒ½è®©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£æ ˆã€æ ˆå¸§ã€æŒ‡é’ˆã€gdbçš„ä¸€äº›çŸ¥è¯†ã€‚\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼š\u003ca href=\"https://github.com/kerolt/xv6-labs-2023/commit/d1dba8ae4a1a71604e8bb6df5238f8cac1771683\"\u003eä»“åº“commit\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ã€MIT6.S081ã€‘Lab4 trap backtrace"},{"content":"Alarmç»¼åˆäº†è¯¥labä¸­å‰å‡ ä¸ªç»ƒä¹ çš„çŸ¥è¯†ç‚¹ï¼šç³»ç»Ÿè°ƒç”¨ã€ä¸­æ–­ã€å¯„å­˜å™¨ç­‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹trapæœºåˆ¶æœ‰æ¯”è¾ƒå¥½çš„è®¤è¯†æ‰èƒ½ç†è§£ã€‚Alarmçš„ä»»åŠ¡æ˜¯éœ€è¦æˆ‘ä»¬å®Œæˆä¸€ä¸ªå®šæ—¶å™¨çš„å®ç°ï¼šsigalarm(interval, handler)ï¼Œå½“è°ƒç”¨sigalarm(n, fn)æ—¶ï¼Œå†…æ ¸ä¼šæ¯nä¸ªæ—¶é—´é—´éš”ï¼ˆtickï¼‰æ‰§è¡Œfnå‡½æ•°ã€‚\nè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼šä»“åº“commit\nå¦‚ä½•ç†è§£Alarm â€œå†…æ ¸ä¼šæ¯nä¸ªæ—¶é—´é—´éš”æ‰§è¡Œfnå‡½æ•°â€ï¼Œå¦‚ä½•ç†è§£è¿™â€œæ¯nä¸ªæ—¶é—´é—´éš”â€å‘¢ï¼Ÿåœ¨è®¡ç®—æœºä¸­æœ‰ä¸€ä¸ªâ€œæ—¶é’Ÿå‘¨æœŸâ€çš„æ¦‚å¿µï¼Œè€Œæˆ‘ä»¬è¿™é‡Œæ‰€è¯´çš„æ—¶é—´é—´éš”å°±æ˜¯xv6ä¸­è®¾ç½®çš„æ¯æ¬¡å‘ç”Ÿæ—¶é’Ÿä¸­æ–­æ‰€é—´éš”çš„å§‹ç»ˆå‘¨æœŸã€‚åœ¨xv6å†…æ ¸åˆå§‹åŒ–æ—¶ä¼šæ‰§è¡Œtimerinit()å‡½æ•°ï¼Œå…¶ä¸­æœ‰ï¼š\n// ask the CLINT for a timer interrupt. int interval = 1000000; // cycles; about 1/10th second in qemu. *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval; è¿™é‡Œå°±æ˜¯è®¾ç½®äº†xv6ä¼šæ¯ç»è¿‡intervalä¸ªæ—¶é’Ÿå‘¨æœŸï¼ˆåœ¨qemuä¸­å¤§æ¦‚ä¸º0.1ç§’ï¼‰è¿›è¡Œä¸€æ¬¡æ—¶é’Ÿä¸­æ–­ï¼Œè¿™ä¸ªä¸­æ–­æ˜¯ç¡¬ä»¶è‡ªåŠ¨æ‰§è¡Œçš„ï¼ˆåœ¨æ²¡çœ‹æºç ä¹‹å‰ï¼Œä¸€ç›´æ²¡ææ‡‚xv6æ˜¯ä»€ä¹ˆæ—¶å€™ã€æ€ä¹ˆè¿›è¡Œçš„æ—¶é’Ÿä¸­æ–­ï¼‰ã€‚ä¸‹æ–‡å°†ä»¥æ—¶é’Ÿä¸­æ–­çš„é—´éš”tickä½œä¸ºåŸºæœ¬å•ä½ã€‚\næ‰€ä»¥ç®€å•æ¥è¯´ï¼ŒAlarméœ€è¦æˆ‘ä»¬åœ¨å†…æ ¸ä¸­è¿›è¡Œè®¡æ•°ï¼Œæ¯å½“ç»è¿‡nä¸ªtickçš„æ—¶å€™ï¼Œéœ€è¦å»æ‰§è¡Œfnå‡½æ•°ã€‚\ntest0~3æ‰€åšçš„äº‹ test0ï¼šç”¨äºæµ‹è¯•æˆ‘ä»¬çš„sigalarmæ˜¯å¦èµ·ä½œç”¨äº†ï¼› test1ï¼šç”¨äºæµ‹è¯•å†…æ ¸æ˜¯å¦å¤šæ¬¡è°ƒç”¨å¤„ç†å‡½æ•°ï¼Œéœ€è¦ç¡®ä¿ä¸­æ–­å‘ç”Ÿæ—¶è·³è½¬çš„åœ°å€ä¸ºå¤„ç†å‡½æ•°æ‰€åœ¨çš„åœ°å€ï¼Œè¿˜æœ‰ä¸­æ–­æ—¶éœ€è¦ä¿å­˜å¥½ä¹‹å‰å¯„å­˜å™¨ä¸­çš„å€¼ï¼› test2ï¼šç”¨äºæµ‹è¯•å†…æ ¸ä¸å…è®¸é‡å…¥sysalarmç³»ç»Ÿè°ƒç”¨ï¼Œå³è‹¥æŸä¸ªè¿›ç¨‹æ­£åœ¨æ‰§è¡Œå¤„ç†å‡½æ•°ï¼Œé‚£ä¹ˆå†…æ ¸å°±ä¸åº”è¯¥å†æ¬¡è°ƒç”¨å®ƒï¼› test3ï¼šç”¨äºæµ‹è¯•sys_sigreturnç³»ç»Ÿè°ƒç”¨èƒ½å¦æ­£ç¡®è¿”å›å¯„å­˜å™¨a0çš„å€¼ã€‚ å®ç° æ³¨å†Œç³»ç»Ÿè°ƒç”¨ é¦–å…ˆçš„æ³¨å†Œç³»ç»Ÿè°ƒç”¨çš„æ­¥éª¤è¿™é‡Œå°±ä¸å±•å¼€äº†ï¼Œå…·ä½“å¯å‚è€ƒä¹‹å‰çš„labã€‚\nstruc procç»“æ„ä½“ ä¸ºäº†å®Œæˆå®šæ—¶æ‰§è¡ŒæŸä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦åœ¨struct procç»“æ„ä½“ä¸­åŠ å…¥ä¸€äº›æˆå‘˜ï¼š\nstruct proc { ... int is_handling; // ç”¨äºåˆ¤æ–­å½“å‰è¿›ç¨‹æ˜¯å¦æ­£åœ¨æ‰§è¡Œå¤„ç†å‡½æ•° int tick_interval; // å®šæ—¶å™¨é—´éš”ï¼Œç”±ç³»ç»Ÿsigalarmçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ å…¥ int tick_counter; // å®šæ—¶å™¨è®¡æ•°å™¨ï¼Œæ¯æ¬¡tickè¿›è¡Œ+1 uint64 tick_handler; // é—´éš”åˆ°äº†åæ‰§è¡Œçš„å¤„ç†å‡½æ•° struct trapframe *saved_trapframe; // ä¿å­˜å¯„å­˜å™¨ } å€¼çš„æ³¨æ„çš„æ˜¯å¤„ç†å‡½æ•°çš„ç±»å‹æˆ‘ä»¬è®¾ç½®ä¸ºäº†uint64ï¼Œä¸ºä»€ä¹ˆä¸æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆå‘¢ï¼Ÿå…¶å®éƒ½å·®ä¸å¤šï¼Œåœ¨ä¹‹åè®¾ç½®è·³è½¬å¤„ç†å‡½æ•°çš„æ—¶å€™ï¼Œå°±æ˜¯é€šè¿‡åœ°å€æ¥è·³è½¬ï¼Œè€Œåœ°å€åœ¨xv6ä¸­å°±æ˜¯ç”¨çš„uint64æ¥è¡¨ç¤ºã€‚æ•…è¿™é‡Œçš„è®¾ç½®å³æ˜¯å¤„ç†å‡½æ•°æ‰€åœ¨çš„èµ·å§‹åœ°å€ã€‚\nå®ç°sys_sigalarm åœ¨sysproc.cä¸­å®ç°sys_sigalarm()å‡½æ•°ï¼š\nuint64 sys_sigalarm(void) { struct proc *p = myproc(); argint(0, \u0026amp;(p-\u0026gt;tick_interval)); argaddr(1, \u0026amp;(p-\u0026gt;tick_handler)); return 0; } è¯¥å‡½æ•°è¦åšçš„äº‹æƒ…å¾ˆç®€å•ï¼Œåªéœ€è¦æ¥æ”¶ä»ç”¨æˆ·æ€ä¼ æ¥çš„ä¸¤ä¸ªå‚æ•°ï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™å½“å‰è¿›ç¨‹çš„tick_intervalå’Œtick_handlerã€‚\nè¿›ç¨‹åˆå§‹åŒ–ä¸ç»“æŸé”€æ¯ æ¥ç€éœ€è¦åœ¨è¿›ç¨‹åˆ›å»ºå’Œé”€æ¯æ—¶å¯¹è¿™äº›å˜é‡è¿›è¡Œç›¸åº”çš„åˆå§‹åŒ–å’Œæ¸…é›¶ï¼š\nstatic struct proc* allocproc(void) { ... p-\u0026gt;tick_interval = 0; p-\u0026gt;tick_counter = 0; p-\u0026gt;tick_handler = 0; p-\u0026gt;is_handling = 0; ... // Allocate a saved_trapframe page. if((p-\u0026gt;saved_trapframe = (struct trapframe *)kalloc()) == 0){ freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } ... } static void freeproc(struct proc *p) { ... if(p-\u0026gt;saved_trapframe) kfree((void*)p-\u0026gt;saved_trapframe); p-\u0026gt;saved_trapframe = 0; ... p-\u0026gt;tick_counter = 0; p-\u0026gt;tick_interval = 0; p-\u0026gt;tick_handler = 0; p-\u0026gt;is_handling = 0; } è¡¥å…¨usertrap æ¥ä¸‹æ¥å°±æ˜¯éœ€è¦å®ç°åœ¨usertrapä¸­å¤„ç†æ—¶é’Ÿä¸­æ–­ï¼Œåœ¨å®éªŒæŒ‡å¯¼ä¹¦ä¸­æç¤ºæˆ‘ä»¬åœ¨if(which_dev == 2) ...ä¸­å¤„ç†æ—¶é’Ÿä¸­æ–­ã€‚è¿™é‡Œæˆ‘çš„å¤„ç†é€»è¾‘ä¸ºï¼Œå½“æ—¶é’Ÿä¸­æ–­å‘ç”Ÿæ—¶ï¼š\nå½“å‰è¿›ç¨‹çš„tickè®¡æ•°å™¨++ åˆ¤æ–­è¿›ç¨‹è®¾ç½®çš„å®šæ—¶å™¨é—´éš”æ˜¯å¦ä¸ä¸º0ã€å½“å‰è®¡æ•°å™¨æ˜¯å¦å·²ç»ç»è¿‡äº†intervalä¸ªé—´éš”ã€ä¸”å½“å‰è¿›ç¨‹æœªæ‰§è¡Œå¤„ç†å‡½æ•°ï¼Œå¦‚æœå…¶ä¸­ä¸€é¡¹ä¸æ»¡è¶³ï¼Œåˆ™ä¸è¿›è¡Œç¬¬ä¸‰æ­¥ å°†å½“å‰è¿›ç¨‹çš„trapframeçš„å†…å®¹ï¼ˆå³å¯„å­˜å™¨çš„å€¼ï¼‰ä¿å­˜åˆ°saved_trapframeï¼ˆç”¨äºæ¢å¤ç°åœºï¼‰ï¼Œå°†SEPCå¯„å­˜å™¨çš„å€¼è®¾ç½®ä¸ºå¤„ç†å‡½æ•°çš„åœ°å€ï¼Œè¿™æ ·ä¸­æ–­ç»“æŸè¿”å›æ—¶å°±ä¼šå»æ‰§è¡Œå¤„ç†å‡½æ•°äº†ï¼Œæœ€åè®¾ç½®å½“å‰è¿›ç¨‹â€œæ­£åœ¨æ‰§è¡Œå¤„ç†å‡½æ•°â€ ä»£ç å¦‚ä¸‹ï¼š\nvoid usertrap(void) { ... // give up the CPU if this is a timer interrupt. if (which_dev == 2) { p-\u0026gt;tick_counter++; if (p-\u0026gt;tick_interval \u0026amp;\u0026amp; p-\u0026gt;tick_counter % p-\u0026gt;tick_interval == 0 \u0026amp;\u0026amp; p-\u0026gt;is_handling == 0) { memmove(p-\u0026gt;saved_trapframe, p-\u0026gt;trapframe, PGSIZE); p-\u0026gt;trapframe-\u0026gt;epc = p-\u0026gt;tick_handler; p-\u0026gt;is_handling = 1; } yield(); } ... åœ¨ç¬¬äºŒæ­¥ä¸­ä¸çŸ¥é“æ˜¯xv6çš„bugè¿˜æ˜¯æˆ‘æœ‰åœ°æ–¹æ²¡ç†è§£å¥½ï¼Œå¦‚æœä¸å…ˆæ£€æŸ¥tick_interval != 0ï¼Œåˆ™å¯èƒ½åœ¨æ‰§è¡Œp-\u0026gt;tick_counter % p-\u0026gt;tick_intervalä¼šæœ‰é—®é¢˜ï¼Œå› ä¸ºå–æ¨¡è¿ç®—ç¬¦%åœ¨åˆ†æ¯ä¸º0æ—¶æ˜¯æœªå®šä¹‰çš„ï¼Œä½†è¿™ä¹ˆè¿è¡Œæ—¶xv6å¹¶æ²¡æœ‰ä»»ä½•é”™è¯¯ã€‚\nè¿”å›ï¼Œæ¢å¤ç°åœº åœ¨å¤„ç†å‡½æ•°æ‰§è¡Œçš„æœ€åï¼Œå°†ä¼šæ‰§è¡Œsigreturnç³»ç»Ÿè°ƒç”¨è¿›è¡Œè¿”å›å¹¶æ¢å¤ç°åœºï¼Œè¿™æ—¶æˆ‘ä»¬å°±å¯ä»¥å°†ä¹‹å‰å­˜æ”¾åœ¨saved_trapframeä¸­çš„å€¼æ‹·è´å›trapframeä¸­ï¼Œå¹¶è®¾ç½®å½“å‰è¿›ç¨‹â€œæœªæ‰§è¡Œå¤„ç†å‡½æ•°â€ã€‚å®éªŒæŒ‡å¯¼ä¹¦ä¸­è¿˜æç¤ºæˆ‘ä»¬æœ€ç»ˆè¿”å›çš„ç»“æœä¸ºa0å¯„å­˜å™¨ä¸­çš„å€¼ã€‚\nuint64 sys_sigreturn(void) { struct proc *p = myproc(); memmove(p-\u0026gt;trapframe, p-\u0026gt;saved_trapframe, PGSIZE); p-\u0026gt;is_handling = 0; return p-\u0026gt;trapframe-\u0026gt;a0; // return this for alarm test3 } ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab4-trap-alarm/","summary":"\u003cp\u003eAlarmç»¼åˆäº†è¯¥labä¸­å‰å‡ ä¸ªç»ƒä¹ çš„çŸ¥è¯†ç‚¹ï¼šç³»ç»Ÿè°ƒç”¨ã€ä¸­æ–­ã€å¯„å­˜å™¨ç­‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹trapæœºåˆ¶æœ‰æ¯”è¾ƒå¥½çš„è®¤è¯†æ‰èƒ½ç†è§£ã€‚Alarmçš„ä»»åŠ¡æ˜¯éœ€è¦æˆ‘ä»¬å®Œæˆä¸€ä¸ªå®šæ—¶å™¨çš„å®ç°ï¼š\u003ccode\u003esigalarm(interval, handler)\u003c/code\u003eï¼Œå½“è°ƒç”¨\u003ccode\u003esigalarm(n, fn)\u003c/code\u003eæ—¶ï¼Œå†…æ ¸ä¼šæ¯nä¸ªæ—¶é—´é—´éš”ï¼ˆtickï¼‰æ‰§è¡Œfnå‡½æ•°ã€‚\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eè¯¥å®éªŒçš„ä»£ç å®ç°è§ï¼š\u003ca href=\"https://github.com/kerolt/xv6-labs-2023/commit/0f70ef7d68ab1273262b8d43a2deaf7345a87698\"\u003eä»“åº“commit\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ã€MIT6.S081ã€‘Lab4 trap alarm"},{"content":"å‰è¨€ é¡µè¡¨æ˜¯æœ€å¸¸ç”¨çš„æœºåˆ¶ï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡å®ƒä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›è‡ªå·±çš„ç§æœ‰åœ°å€ç©ºé—´å’Œå†…å­˜ã€‚é¡µè¡¨å†³å®šäº†å†…å­˜åœ°å€çš„å«ä¹‰ï¼Œä»¥åŠå¯ä»¥è®¿é—®ç‰©ç†å†…å­˜çš„å“ªäº›éƒ¨åˆ†ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œè®°å½•äº†Lab: page tablesçš„å‰ä¸¤ä¸ªå®éªŒï¼šåŠ é€Ÿç³»ç»Ÿè°ƒç”¨å’Œæ‰“å°é¡µè¡¨ã€‚\nSpeed up system callsÂ (easy) é€šå¸¸æˆ‘ä»¬åœ¨éœ€è¦æ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œåœ¨æ“ä½œç³»ç»Ÿä¸­ä¼šå‘ç”Ÿä»ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ï¼Œè¿™æ˜¯å› ä¸ºè¿™äº›æ ¸å¿ƒçš„æ“ä½œåªèƒ½äº¤ç»™å†…æ ¸å»å®Œæˆã€‚åœ¨è¿™ä¸ªå®éªŒä¸­ï¼Œxv6è¦æ±‚æˆ‘ä»¬é€šè¿‡åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ä¹‹é—´å…±äº«åªè¯»åŒºåŸŸä¸­çš„æ•°æ®æ¥åŠ å¿«æŸäº›ç³»ç»Ÿè°ƒç”¨ã€‚\nç”±äºç°åœ¨åªæ˜¯å…¥é—¨å¦‚ä½•å°†æ˜ å°„æ·»åŠ è‡³é¡µè¡¨ä¸­ï¼Œè¿™ä¸ªå®éªŒåªéœ€è¦ä¸ºxv6ä¸­çš„getpid()ç³»ç»Ÿè°ƒç”¨è¿›è¡Œä¼˜åŒ–ã€‚\nåœ¨xv6çš„å®éªŒæŒ‡å¯¼ä¹¦ä¸­ï¼š\nåˆ›å»ºæ¯ä¸ªè¿›ç¨‹æ—¶ï¼Œåœ¨USYSCALLï¼ˆmemlayout.hä¸­å®šä¹‰çš„è™šæ‹Ÿåœ°å€ï¼‰æ˜ å°„ä¸€ä¸ªåªè¯»é¡µã€‚åœ¨è¯¥é¡µé¢çš„å¼€å¤´ï¼Œå­˜å‚¨ä¸€ä¸ªusyscallç»“æ„ä½“ï¼ˆä¹Ÿåœ¨memlayout.hä¸­å®šä¹‰ï¼‰ï¼Œå¹¶å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ä»¥å­˜å‚¨å½“å‰è¿›ç¨‹çš„PIDã€‚\næ—¢ç„¶å¦‚æ­¤ï¼Œè¿›ç¨‹ç»“æ„ä½“ä¸­ä¹Ÿåº”å½“æœ‰ä¸€ä¸ªusyscallç»“æ„ä½“ï¼š\n// kernel/proc.h struct proc { ... pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct usyscall *usyscall; // data page for USYSCALL struct context context; // swtch() here to run process ... }; è¿™æ ·å°±å¯ä»¥é€šè¿‡p-\u0026gt;usyscallæ¥è·å–äº†ã€‚\nåœ¨memlayout.hä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç”¨æˆ·æ€ç©ºé—´å†…å­˜å¸ƒå±€ï¼š\nAddress zero first: text original data and bss fixed-size stack expandable heap ... USYSCALL (shared with kernel) TRAPFRAME (p-\u0026gt;trapframe, used by the trampoline) TRAMPOLINE (the same page as in the kernel) MAXVA-\u0026gt; ------------------------------------- | TRAMPOLINE (ä¸å†…æ ¸ç›¸åŒçš„é¡µé¢) | ------------------------------------- | TRAPFRAME (p-\u0026gt;trapframe, ç”±è·³æ¿ä½¿ç”¨)| ------------------------------------- | USYSCALL (ä¸å†…æ ¸å…±äº«) | ------------------------------------- | ... | ------------------------------------- | å¯æ‰©å±•å † | ------------------------------------- | å›ºå®šå¤§å°çš„æ ˆ | ------------------------------------- | åŸå§‹æ•°æ®å’ŒBSS | ------------------------------------- | text | 0 -\u0026gt; ------------------------------------- æˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯ä»¿ç…§TRAPFRAMEå°†USYSCALLä¹Ÿåšä¸€å±‚æ˜ å°„ã€‚\nåœ¨allocproc()ä¸ºè¿›ç¨‹åˆ†é…ç‰©ç†é¡µæ—¶ï¼Œä½¿ç”¨kalloc()å¯¹usyscallçš„åˆ†é…ï¼ˆkallocæ¯æ¬¡ä»ç©ºé—²é¡µè¡¨ä¸­å–å‡ºä¸€ä¸ªé¡¹ï¼Œå…¶å¤§å°ä¸º4KBï¼‰ï¼š\n// Allocate a usyscall page. if((p-\u0026gt;usyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } åœ¨proc_pagetable()å‡½æ•°ä¸­ï¼Œå…¶ä¸ºæŒ‡å®šè¿›ç¨‹åˆ›å»ºç”¨æˆ·é¡µè¡¨ï¼Œä¸å«ç”¨æˆ·å†…å­˜ï¼Œä½†æœ‰trampoline å’Œ trapframeé¡µã€‚ä»¥ä¸‹ä»£ç æ˜¯å¯¹trampoline å’Œ trapframeè¿›è¡Œæ˜ å°„ã€‚\n// map the trampoline code (for system call return) // at the highest user virtual address. // only the supervisor uses it, on the way // to/from user space, so not PTE_U. if(mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) \u0026lt; 0){ uvmfree(pagetable, 0); return 0; } // map the trapframe page just below the trampoline page, for // trampoline.S. if(mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-\u0026gt;trapframe), PTE_R | PTE_W) \u0026lt; 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } å¦‚æ­¤ï¼Œæˆ‘ä»¬ç…§çŒ«ç”»è™ï¼Œä¹Ÿå¯ä»¥å†™å‡ºusyscallçš„æ˜ å°„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¯¥é¡µæ˜¯read-onlyçš„ï¼Œå¹¶ä¸”å…è®¸ç”¨æˆ·æ€è®¿é—®ï¼Œå› æ­¤å…¶æƒé™åº”è¯¥ä¸ºPTE_Rå’ŒPTE_Uã€‚\n// map the usyscall page if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-\u0026gt;usyscall), PTE_R | PTE_U) \u0026lt; 0){ uvmunmap(pagetable, USYSCALL, 1, 0); uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } åœ¨ç»“æŸè¿›ç¨‹æ—¶ï¼Œå³freeprocå‡½æ•°ä¸­ï¼Œä¹Ÿéœ€è¦å¯¹usyscallçš„ç©ºé—´è¿›è¡Œé‡Šæ”¾ï¼š\nif(p-\u0026gt;usyscall) kfree((void*)p-\u0026gt;usyscall); p-\u0026gt;usyscall = 0; åŒæ—¶è¿˜åº”å½“åœ¨proc_freepagetableå‡½æ•°ä¸­è§£é™¤ä¹‹å‰å¯¹usyscallçš„æ˜ å°„ï¼š\nuvmunmap(pagetable, USYSCALL, 1, 0); Print a page tableÂ (easy) è¿™ä¸ªå®éªŒè¦æ±‚æˆ‘ä»¬å°†é¡µè¡¨æ‰“å°å‡ºæ¥ã€‚åœ¨å®éªŒå¼€å§‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆçœ‹çœ‹xv6ä¸­çš„é¡µè¡¨ã€‚\nxv6ä¸­çš„é¡µè¡¨ä¸ºä¸‰çº§é¡µè¡¨ï¼Œåœ¨VAè½¬æ¢ä¸ºPAçš„è¿‡ç¨‹ä¸­ï¼Œå¤„ç†å•å…ƒä¼šé€šè¿‡satpå¯„å­˜å™¨æ‰¾åˆ°å½“å‰è¿›ç¨‹çš„é¡µè¡¨åŸºåœ°å€ï¼Œç„¶åå–å‡ºVAä¸­çš„L2éƒ¨åˆ†æ‰¾åˆ°ä¸€çº§é¡µè¡¨çš„é¡¹ï¼Œä¸€çº§é¡µè¡¨ä¸­çš„é¡¹ï¼ˆPTEï¼‰ä¿å­˜äºŒçº§é¡µè¡¨çš„åœ°å€ï¼Œå†é€šè¿‡L1å¯è·å–äºŒçº§é¡µè¡¨ä¸­çš„é¡¹ï¼Œä¾æ¬¡ç±»æ¨å³å¯å°†VAè½¬æ¢ä¸ºPAã€‚\nè¿™æ ·çœ‹æ¥ï¼Œæƒ³è¦æ‰“å°é¡µè¡¨ï¼Œæœ‰ç‚¹ç±»ä¼¼äºDFSç®—æ³•ï¼Œéœ€è¦ä½¿ç”¨é€’å½’ã€‚æŒ‰ç…§å®éªŒæŒ‡å¯¼ä¹¦æ‰€è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä»freewalkå‡½æ•°ä¸­è·å–çµæ„Ÿï¼ŒæŸ¥çœ‹å…¶æºç å¯ä»¥çŸ¥é“å¦‚ä½•å»éå†é¡µè¡¨é¡¹ã€‚é‚£ä¹ˆæŒ‰ç…§è¦æ±‚æ‰€å®ç°æ‰“å°é¡µè¡¨å°±æ¯”è¾ƒå®¹æ˜“äº†ï¼š\nstatic void print_pgtbl(pagetable_t pagetable, int depth) { if (depth \u0026gt; 2) { return; } for(int i = 0; i \u0026lt; 512; i++){ pte_t pte = pagetable[i]; if (pte \u0026amp; PTE_V) { if (depth == 0) { printf(\u0026#34;..\u0026#34;); } else if (depth == 1) { printf(\u0026#34;.. ..\u0026#34;); } else if (depth == 2) { printf(\u0026#34;.. .. ..\u0026#34;); } uint64 child = PTE2PA(pte); printf(\u0026#34;%d: pte %p pa %p\\n\u0026#34;, i, pte, PTE2PA(pte)); print_pgtbl((pagetable_t)child, depth + 1); } } } void vmprint(pagetable_t pagetable) { printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); print_pgtbl(pagetable, 0); } ç”±äºæ‰“å°é¡µè¡¨è¿™ä¸ªæ“ä½œæ˜¯è¿›ç¨‹å·ä¸º1çš„initè¿›ç¨‹åšçš„ï¼Œæ‰€ä»¥ä¸è¦å¿˜è®°åœ¨kernel/exec.cçš„execå‡½æ•°ä¸­æ·»åŠ ï¼š\nif (p-\u0026gt;pid == 1) { vmprint(p-\u0026gt;pagetable); } å¹¶ä¸”åœ¨kernel/defs.hä¸­æ·»åŠ vmprintçš„å‡½æ•°å£°æ˜ï¼š\nvoid vmprint(pagetable_t); ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab3-page-tables%E4%B8%8A/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eé¡µè¡¨æ˜¯æœ€å¸¸ç”¨çš„æœºåˆ¶ï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡å®ƒä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›è‡ªå·±çš„ç§æœ‰åœ°å€ç©ºé—´å’Œå†…å­˜ã€‚é¡µè¡¨å†³å®šäº†å†…å­˜åœ°å€çš„å«ä¹‰ï¼Œä»¥åŠå¯ä»¥è®¿é—®ç‰©ç†å†…å­˜çš„å“ªäº›éƒ¨åˆ†ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œè®°å½•äº†\u003ccode\u003eLab: page tables\u003c/code\u003eçš„å‰ä¸¤ä¸ªå®éªŒï¼šåŠ é€Ÿç³»ç»Ÿè°ƒç”¨å’Œæ‰“å°é¡µè¡¨ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab3 page tablesï¼ˆä¸Šï¼‰"},{"content":"æœ¬å…³çš„ä»»åŠ¡ä¸ºâ€œDetect which pages have been accessedâ€ï¼Œéœ€è¦å®ç°ä¸€ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨pgaccessï¼Œå®ƒæŒ‡å‡ºè®¿é—®äº†å“ªäº›é¡µé¢è¢«è®¿é—®äº†ï¼ˆè¯»ã€å†™ç­‰ï¼‰ã€‚ç³»ç»Ÿè°ƒç”¨éœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š\nç¬¬ä¸€ä¸ªç”¨æˆ·é¡µé¢çš„èµ·å§‹è™šæ‹Ÿåœ°å€ éœ€è¦æ£€æŸ¥é¡µæ•° ä¸€ä¸ªå­˜å‚¨æ¯ä¸€é¡µæ˜¯å¦è¢«è®¿é—®çš„æ©ç  è¯¥labçš„æ‰€æœ‰ä»£ç ï¼šGithub\næµ‹è¯•è¯¥ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°ä½äºuser/pgtbltest.c:pgaccess_test()ä¸­ï¼š\nvoid pgaccess_test() { char *buf; unsigned int abits; printf(\u0026#34;pgaccess_test starting\\n\u0026#34;); testname = \u0026#34;pgaccess_test\u0026#34;; buf = malloc(32 * PGSIZE); if (pgaccess(buf, 32, \u0026amp;abits) \u0026lt; 0) err(\u0026#34;pgaccess failed\u0026#34;); buf[PGSIZE * 1] += 1; buf[PGSIZE * 2] += 1; buf[PGSIZE * 30] += 1; if (pgaccess(buf, 32, \u0026amp;abits) \u0026lt; 0) err(\u0026#34;pgaccess failed\u0026#34;); if (abits != ((1 \u0026lt;\u0026lt; 1) | (1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 30))) err(\u0026#34;incorrect access bits set\u0026#34;); free(buf); printf(\u0026#34;pgaccess_test: OK\\n\u0026#34;); } åˆ†æä¸‹æºç å¯ä»¥çŸ¥é“ï¼Œæµ‹è¯•ç¨‹åºåˆ†é…äº†32ä¸ªé¡µï¼Œå¹¶ä¸”ä½¿ç”¨ï¼ˆor è®¿é—®ï¼‰äº†è¿™åˆ†é…çš„32ä¸ªé¡µçš„ç¬¬1ã€2ã€30é¡µï¼Œä¹‹åç¨‹åºè°ƒç”¨pgaccessæ¥æ£€æµ‹abitsçš„ç¬¬1ã€2ã€30ä½æ˜¯å¦ä¸º1ï¼Œå³åˆ¤æ–­è¯¥ç³»ç»Ÿè°ƒç”¨æ˜¯å¦å®ç°äº†â€œæ£€æµ‹å·²ç»è®¿é—®çš„é¡µâ€è¿™ä¸ªåŠŸèƒ½ã€‚\nå‘å†…æ ¸æ·»åŠ ç³»ç»Ÿè°ƒç”¨çš„æ–¹æ³•åœ¨lab2ä¸­å·²ç»äº†è§£è¿‡äº†ï¼Œä¸è¿‡è¿™é‡Œxv6å·²ç»å¸®æˆ‘ä»¬æ·»åŠ å¥½äº†ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°ç³»ç»Ÿè°ƒç”¨kernel/sysproc.c:sys_pgaccess()å³å¯ã€‚\nåœ¨xv6 bookä¸­å¯ä»¥çŸ¥é“ä¸€ä¸ªPTEçš„æ¯ä½æ„æˆå¦‚ä¸Šå›¾ï¼Œå…¶ä¸­0 - 9ä½æ˜¯ä¸€äº›æ ‡å¿—ä½ï¼Œç¬¬6ä½ä¸ºAccessedï¼Œä¹Ÿå°±æ˜¯è®¿é—®ä½ï¼Œéœ€è¦åœ¨å†…æ ¸ä¸­æ·»åŠ è¿™ä¸ªæ ‡å¿—ï¼š\n// kernel/riscv.h #define PTE_A (1L \u0026lt;\u0026lt; 6) è€Œrisc-vå¤„ç†å™¨ä¼šåˆ©ç”¨ç¡¬ä»¶å°†å·²è®¿é—®çš„é¡µçš„PTE_Aæ­£ç¡®è®¾ç½®ã€‚\nå®ç°sys_pgaccessçš„æ­¥éª¤å¤§è‡´å¯åˆ†ä¸ºï¼š\næ¥å—ç”¨æˆ·æ€ä¼ é€’çš„ä¸‰ä¸ªå‚æ•°ï¼š ç¬¬ä¸€ä¸ªç”¨æˆ·é¡µé¢çš„èµ·å§‹è™šæ‹Ÿåœ°å€ï¼ˆæŒ‡é’ˆï¼‰ éœ€è¦æ£€æŸ¥é¡µæ•°ï¼ˆintï¼‰ ä¸€ä¸ªå­˜å‚¨æ¯ä¸€é¡µæ˜¯å¦è¢«è®¿é—®çš„æ©ç ï¼ˆæŒ‡é’ˆï¼‰ éå†â€œéœ€è¦æ£€æŸ¥é¡µæ•°â€ï¼Œå¹¶æ¯æ¬¡æ£€æŸ¥éå†çš„é¡µæ˜¯å¦å·²è®¿é—®ã€‚è·å–æ¯ä¸ªé¡µå¯¹åº”çš„PTEå°†ä½¿ç”¨walkå‡½æ•°æ¥è·å–ï¼Œè€Œæ£€æŸ¥å°†ä½¿ç”¨PTE_Aæ¥åˆ¤æ–­ï¼›å¦‚æœå½“å‰é¡µçš„PTE_Aä¸º1ï¼Œåˆ™è¯´æ˜è¯¥é¡µè¢«è®¿é—®è¿‡ï¼Œåˆ©ç”¨ä½è¿ç®—ï¼ˆæ˜¯çš„ï¼Œä½è¿ç®—åœ¨è¯¥labé‡Œç«‹å¤§åŠŸï¼‰æ¥å­˜å‚¨ä¿¡æ¯ï¼Œå³ç¬¬å‡ é¡µè¢«è®¿é—®äº†ï¼Œå¹¶ä¸”ä¸è¦å¿˜è®°äº†å®éªŒæŒ‡å¯¼ä¸­çš„æç¤ºï¼Œâ€œBe sure to clearÂ PTE_AÂ after checking if it is set. Otherwise, it won\u0026rsquo;t be possible to determine if the page was accessed since the last timeÂ pgaccess()Â was calledâ€ï¼Œæ£€æµ‹å®Œååº”è¯¥å°†PTE_Aæ ‡è®°ä½æ¸…é™¤ã€‚ å°†å­˜å‚¨çš„ä¿¡æ¯åˆ©ç”¨copyoutå‡½æ•°ä»å†…æ ¸æ€ä¼ é€’ç»™ç”¨æˆ·æ€ï¼Œå±Šæ—¶ç”¨æˆ·æ€å¯é€šè¿‡ç¬¬ä¸‰ä¸ªå‚æ•°è·å–ã€‚ å…·ä½“å®ç°å¦‚ä¸‹ï¼š\nint sys_pgaccess(void) { // lab pgtbl: your code here. uint64 uvm_pgaddr; int page_counts; uint64 abits; argaddr(0, \u0026amp;uvm_pgaddr); argint(1, \u0026amp;page_counts); argaddr(2, \u0026amp;abits); int result = 0; pagetable_t page_table = myproc()-\u0026gt;pagetable; for (int i = 0; i \u0026lt; page_counts; i++) { pte_t *pte = walk(page_table, uvm_pgaddr, 0); if (((*pte) \u0026amp; (PTE_A)) != 0) { result |= (1 \u0026lt;\u0026lt; i); *pte \u0026amp;= (~PTE_A); } uvm_pgaddr += PGSIZE; } copyout(page_table, abits, (char*)\u0026amp;result, sizeof(result)); return 0; } ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab3-page-tables%E4%B8%8B/","summary":"\u003cp\u003eæœ¬å…³çš„ä»»åŠ¡ä¸ºâ€œDetect which pages have been accessedâ€ï¼Œéœ€è¦å®ç°ä¸€ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨\u003ccode\u003epgaccess\u003c/code\u003eï¼Œå®ƒæŒ‡å‡ºè®¿é—®äº†å“ªäº›é¡µé¢è¢«è®¿é—®äº†ï¼ˆè¯»ã€å†™ç­‰ï¼‰ã€‚ç³»ç»Ÿè°ƒç”¨éœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eç¬¬ä¸€ä¸ªç”¨æˆ·é¡µé¢çš„èµ·å§‹è™šæ‹Ÿåœ°å€\u003c/li\u003e\n\u003cli\u003eéœ€è¦æ£€æŸ¥é¡µæ•°\u003c/li\u003e\n\u003cli\u003eä¸€ä¸ªå­˜å‚¨æ¯ä¸€é¡µæ˜¯å¦è¢«è®¿é—®çš„æ©ç \u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eè¯¥labçš„æ‰€æœ‰ä»£ç ï¼š\u003ca href=\"https://github.com/kerolt/xv6-labs-2023/commit/87373230877d27d7f60c39696688863210c41133\"\u003eGithub\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"ã€MIT6.S081ã€‘Lab3 page tablesï¼ˆä¸‹ï¼‰"},{"content":"å‰è¨€ è¿™ä¸ªlabå¼€å§‹æˆ‘ä»¬å°±æ­£å¼è¿›å…¥äº†xv6çš„ä¸–ç•Œäº†ï¼Œè¿™ä¸€æ¬¡æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°å†…æ ¸ä¸­ç³»ç»Ÿè°ƒç”¨çš„æ³¨å†Œå’Œè¿è¡ŒåŸç†ï¼Œè¿™å¯ä»¥è¯´æ˜¯ä¹‹ålabçš„ä¸€ä¸ªåŸºçŸ³ã€‚\ntrace é¦–å…ˆï¼Œæˆ‘ä»¬è¦æ¸…æ¥šè¿™ä¸ªå®éªŒçš„ç›®çš„æ˜¯ä»€ä¹ˆï¼š\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You\u0026rsquo;ll create a newÂ traceÂ system call that will control tracing. It should take one argument, an integer \u0026ldquo;mask\u0026rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program callsÂ trace(1 \u0026laquo; SYS_fork), whereÂ SYS_forkÂ is a syscall number fromÂ kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call\u0026rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don\u0026rsquo;t need to print the system call arguments. TheÂ traceÂ system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\nè¯‘ï¼šåœ¨Xv6çš„traceå‘½ä»¤ä¸­ï¼Œå®ƒåº”è¯¥æœ‰ä¸€ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ•´æ•°â€œæ©ç â€ï¼Œå…¶ä½æŒ‡å®šè¦è·Ÿè¸ªçš„ç³»ç»Ÿè°ƒç”¨ã€‚ä¾‹å¦‚ï¼Œè¦è·Ÿè¸ªforkç³»ç»Ÿè°ƒç”¨ï¼Œç¨‹åºè°ƒç”¨trace(1\u0026lt;\u0026lt;SYS_fork)ï¼Œå…¶ä¸­SYS_forkæ˜¯kernel/syscall.hä¸­çš„ç³»ç»Ÿè°ƒç”¨ç¼–å·ã€‚å¦‚æœç³»ç»Ÿè°ƒç”¨çš„ç¼–å·åœ¨æ©ç ä¸­è®¾ç½®ï¼Œåˆ™å¿…é¡»ä¿®æ”¹xv6å†…æ ¸ï¼Œä»¥ä¾¿åœ¨æ¯ä¸ªç³»ç»Ÿè°ƒç”¨å³å°†è¿”å›æ—¶æ‰“å°å‡ºä¸€è¡Œã€‚è¯¥è¡Œåº”åŒ…å«è¿›ç¨‹idã€ç³»ç»Ÿè°ƒç”¨çš„åç§°å’Œè¿”å›å€¼ï¼›æ‚¨ä¸éœ€è¦æ‰“å°ç³»ç»Ÿè°ƒç”¨å‚æ•°ã€‚è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨åº”å¯ç”¨å¯¹è°ƒç”¨å®ƒçš„è¿›ç¨‹åŠå…¶éšååˆ†å‰çš„ä»»ä½•å­è¿›ç¨‹çš„è·Ÿè¸ªï¼Œä½†ä¸åº”å½±å“å…¶ä»–è¿›ç¨‹ã€‚\næ³¨æ„ï¼Œåœ¨è¯¥å®éªŒçš„åˆå§‹é˜¶æ®µï¼Œxv6å·²ç»ä¸ºæˆ‘ä»¬æä¾›äº†traceå‘½ä»¤çš„ç”¨æˆ·æ€å®ç°ï¼Œä½†æ˜¯å…¶åº•å±‚çš„ç³»ç»Ÿè°ƒç”¨éœ€è¦æˆ‘ä»¬è‡ªå·±å®ç°ã€‚\nmaskæ˜¯ä»€ä¹ˆï¼Ÿ åœ¨ä½¿ç”¨traceå‘½ä»¤æ—¶ç”¨åˆ°çš„æ©ç ï¼Œæ˜¯ç”¨æ¥è·Ÿè¸ªä¹‹åä½¿ç”¨çš„å‘½ä»¤ç”¨åˆ°äº†å“ªäº›ç³»ç»Ÿè°ƒç”¨ã€‚ä¾‹å¦‚å®éªŒä¸­ç»™å‡ºçš„ä¾‹å­ï¼š\n$ trace 32 grep hello README 3: syscall read -\u0026gt; 1023 3: syscall read -\u0026gt; 966 3: syscall read -\u0026gt; 70 3: syscall read -\u0026gt; 0 è¿™ä¸ª32å°±æ˜¯æ©ç ï¼Œå…¶è·Ÿè¸ªåˆ°äº†grepå‘½ä»¤ä¸­ä½¿ç”¨åˆ°äº†readç³»ç»Ÿè°ƒç”¨ï¼ˆä¸ºä»€ä¹ˆæ˜¯readï¼Ÿé©¬ä¸Šå°±è¯´åˆ°äº†ï¼‰ã€‚åœ¨xv6çš„kernel/syscall.hä¸­æœ‰æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨çš„ç¼–å·ï¼š\n// System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 // æ·»åŠ  #define SYS_trace 22 å°†è¿™ä¸ªmaskä»¥äºŒè¿›åˆ¶çš„å½¢å¼æ¥çœ‹å¾…æ›´åŠ å®¹æ˜“ç†è§£ï¼Œå¦‚æœä¼ å…¥çš„maskæ˜¯32ï¼Œé‚£ä¹ˆå…¶äºŒè¿›åˆ¶ä¸º100000ï¼Œè¿™ä¸ª1å‡ºç°çš„ä½ç½®æ˜¯ç¬¬5ä½ï¼ˆæœ€ä½ä½æŒ‰0è®¡æ•°ï¼‰ï¼Œä¹Ÿå°±æ˜¯å»æ‰¾ç¼–å·ä¸º5çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯SYS_readã€‚\nxv6å†…æ ¸æä¾›ç»™ç”¨æˆ·æ€çš„æ¥å£ä¸ºtraceï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦è‡ªå·±åœ¨xv6çš„ç”¨æˆ·å¤´æ–‡ä»¶ä¸­æ·»åŠ å‡½æ•°çš„å£°æ˜ï¼š\n// user/user.h // ... int trace(int); // ... è¿™ä¸ªtraceåº•å±‚å…¶å®è°ƒç”¨çš„åº”è¯¥æ˜¯sys_traceï¼ˆè¿™ä¸ªå‡½æ•°åä¸æ˜¯å›ºå®šçš„ï¼Œä½†æ˜¯æºç ä¸­å…¶ä»–çš„ç³»ç»Ÿè°ƒç”¨çš„å‘½åéƒ½ä¸ºsys_*ï¼Œæ•…traceå¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å†™æˆsys_traceæ›´åŠ åˆç†ï¼‰ã€‚sys_traceéœ€è¦åšçš„æ˜¯å°†ç”¨æˆ·ä¼ å…¥çš„maskå†ä¼ ç»™å½“å‰è¿›ç¨‹åŠå…¶å­è¿›ç¨‹ã€‚\næˆ‘ä»¬è¿™é‡Œå°†ç³»ç»Ÿè°ƒç”¨sys_traceçš„ç¼–å·è®¾ç½®ä¸º22ã€‚\nè¿›ç¨‹åŠå…¶å­è¿›ç¨‹å¦‚ä½•è·å–maskï¼Ÿ åœ¨xv6 bookçš„4.3èŠ‚ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š\nsyscall (kernel/syscall.c:132) retrieves the system call number from the saved a7 in the trapframe and uses it to index into syscalls. For the first system call, a7 contains SYS_exec (ker\u0002nel/syscall.h:8), resulting in a call to the system call implementation function sys_exec. When sys_exec returns, syscall records its return value in p-\u0026gt;trapframe-\u0026gt;a0. This will cause the original user-space call to exec() to return that value, since the C calling convention on RISC-V places return values in a0. System calls conventionally return negative numbers to indicate errors, and zero or positive numbers for success. If the system call number is invalid, syscall prints an error and returns âˆ’1. å³ç³»ç»Ÿè°ƒç”¨çš„ç¼–å·ä¼šä¿å­˜åœ¨è¿›ç¨‹çš„trapframeä¸­ï¼Œæ ¹æ®a7å¯„å­˜å™¨å³å¯è·å¾—ï¼Œç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼å¯é€šè¿‡a0å¯„å­˜å™¨è·å¾—ã€‚æ¬¸ï¼è¿™ä¸¤ä¸ªå€¼å¯ä¸å°±æ˜¯å®éªŒå®ç°ä¸­éœ€è¦çš„å—ï¼é‚£ä¹ˆç†æ‰€å½“ç„¶ï¼Œå®éªŒä¸­éœ€è¦æ‰“å°çš„è¯­å¥åº”è¯¥å°±åœ¨è¿™ä¸ªå‡½æ•°ä¸­æ·»åŠ ã€‚\nè®©æˆ‘ä»¬æ¥çœ‹çœ‹xv6ä¸­è¿›ç¨‹çš„æ•°æ®ç»“æ„ï¼š\n// kernel/proc.h struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // wait_lock must be held when using this: struct proc *parent; // Parent process // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) // æ·»åŠ  int trace_mask; } å¯ä»¥çœ‹åˆ°è¯¸å¦‚è¿›ç¨‹åã€pidã€ä¸Šä¸‹æ–‡ç­‰ä¿¡æ¯éƒ½æ˜¯ä¿å­˜åœ¨è¿™ä¸ªæ•°æ®ç»“æ„ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­åŠ ä¸Šä¸€ä¸ªæˆå‘˜å˜é‡ trace_mask ç”¨äºä¿å­˜å½“å‰è¿›ç¨‹æ‰€å¯¹åº”traceå‘½ä»¤ä¸­çš„æ©ç maskã€‚\nxv6å·²ç»å®ç°äº†ç”¨æˆ·æ€çš„traceå‘½ä»¤ï¼Œå…¶ä½äº user/trace.c ä¸­ï¼š\n#include \u0026#34;kernel/param.h\u0026#34; #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int i; char *nargv[MAXARG]; if(argc \u0026lt; 3 || (argv[1][0] \u0026lt; \u0026#39;0\u0026#39; || argv[1][0] \u0026gt; \u0026#39;9\u0026#39;)){ fprintf(2, \u0026#34;Usage: %s mask command\\n\u0026#34;, argv[0]); exit(1); } if (trace(atoi(argv[1])) \u0026lt; 0) { fprintf(2, \u0026#34;%s: trace failed\\n\u0026#34;, argv[0]); exit(1); } for(i = 2; i \u0026lt; argc \u0026amp;\u0026amp; i \u0026lt; MAXARG; i++){ nargv[i-2] = argv[i]; } exec(nargv[0], nargv); exit(0); } å¯¹äºè¿™æ ·çš„ä¸€æ¡å‘½ä»¤ trace 32 grep hello README ï¼Œå‡è®¾å¼€å¯çš„è¿›ç¨‹åä¸ºpï¼Œé‚£ä¹ˆ32å°†ä¼šä¼ ç»™p.trace_maskï¼Œä¹‹åçš„grepæ“ä½œå°†ä½¿ç”¨execåˆ›å»ºå­è¿›ç¨‹ï¼ˆå‡è®¾è¿›ç¨‹åä¸ºsonï¼‰æ‰§è¡Œï¼Œé‚£ä¹ˆåœ¨åˆ›å»ºå­è¿›ç¨‹ååº”è¯¥æœ‰son.trace_mask = p.trace_maskï¼Œåªæœ‰è¿™æ ·ï¼Œgrepæ“ä½œæ‰€ç”¨åˆ°çš„ç³»ç»Ÿè°ƒç”¨æ‰èƒ½è¢«è·Ÿè¸ªåˆ°ã€‚\nåœ¨ä½¿ç”¨traceå‘½ä»¤æ—¶ï¼Œå…¶åçš„maskå‚æ•°ä¼šå­˜åˆ°a0å¯„å­˜å™¨ä¸­ï¼Œä¸ºäº†ä»å…¶ä¸­æ‹¿åˆ°maskï¼Œå¯ä»¥ä½¿ç”¨argint()å‡½æ•°ï¼Œå…¶æºç ä¸ºï¼š\n// kernel/syscall.h // Fetch the nth 32-bit system call argument. void argint(int n, int *ip) { *ip = argraw(n); } static uint64 argraw(int n) { struct proc *p = myproc(); switch (n) { case 0: return p-\u0026gt;trapframe-\u0026gt;a0; case 1: return p-\u0026gt;trapframe-\u0026gt;a1; case 2: return p-\u0026gt;trapframe-\u0026gt;a2; case 3: return p-\u0026gt;trapframe-\u0026gt;a3; case 4: return p-\u0026gt;trapframe-\u0026gt;a4; case 5: return p-\u0026gt;trapframe-\u0026gt;a5; } panic(\u0026#34;argraw\u0026#34;); return -1; } argint()å†…è°ƒç”¨äº†argraw()ï¼Œåœ¨æŸ¥çœ‹ä»¥ä¸Šæºç åï¼Œç”±äºåªä¼ å…¥äº†ä¸€ä¸ªå‚æ•°ï¼Œæ•…åº”è¯¥å°†0ä¼ å…¥argrawä¸­ã€‚åœ¨kernel/sysproc.cä¸­å®ç°sys_trace()ï¼š\n// kernel/sysproc.c // ... uint64 sys_trace(void) { int mask; argint(0, \u0026amp;mask); if (mask \u0026lt; 0) return -1; struct proc *p = myproc(); p-\u0026gt;trace_mask = mask; return 0; } è¿™æ ·å½“traceä½¿ç”¨äº†åº•å±‚çš„sys_traceæ—¶ï¼Œå°±å¯ä»¥æŠŠmaskå‚æ•°ä¼ é€’ç»™å½“å‰è¿›ç¨‹ã€‚ä½†æ˜¯åªä¼ é€’ç»™å½“å‰è¿›ç¨‹è¿˜ä¸å¤Ÿï¼Œè¿˜è¦ä¼ ç»™å½“å‰è¿›ç¨‹çš„å­è¿›ç¨‹ã€‚åœ¨Linuxï¼Œæˆ‘ä»¬åˆ›å»ºå­è¿›ç¨‹çš„å‡½æ•°ä¸ºfork()ï¼Œåœ¨xv6ä¸­ä¹ŸåŒæ ·å¦‚æ­¤ï¼Œforkå†…éƒ¨å…ˆè·å–å½“å‰è¿›ç¨‹çš„procç»“æ„ä½“ï¼Œç„¶åæ–°åˆ›å»ºä¸€ä¸ªprocç»“æ„ä½“ä»£è¡¨å­è¿›ç¨‹ï¼Œå¹¶å°†çˆ¶è¿›ç¨‹ä¸­çš„å€¼æ‹·è´è¿‡å»ï¼Œæ•…ä¼ é€’ç»™å­è¿›ç¨‹çš„maskä¹Ÿåœ¨å…¶ä¸­æ‹·è´ï¼š\n// kernel/proc.c int fork(void) { // ... // copy mask from father process to son process // npä¸ºå­è¿›ç¨‹ï¼Œpä¸ºçˆ¶è¿›ç¨‹ np-\u0026gt;trace_mask = p-\u0026gt;trace_mask; ... } è¦æ³¨æ„ä¸€ä¸ªå°ç»†èŠ‚ï¼Œå½“è¿›ç¨‹ç»“æ„ä½“è¢«é‡Šæ”¾æ—¶ï¼ˆè¿›ç¨‹ç»“æŸæˆ–è€…ä¸ºè¿›ç¨‹åˆ†é…procç»“æ„ä½“ï¼‰ï¼Œå…¶maskä¹Ÿè¯¥é‡ç½®ï¼š\n// kernel/proc.c static void freeproc(struct proc *p) { // ... ... p-\u0026gt;trace_mask = 0; } å®Œæˆå¥½ä»¥ä¸Šå†…å®¹åï¼Œå°±å¯ä»¥å®ç°sys_traceäº†ï¼š\n// kernel/sysproc.c uint64 sys_trace(void) { int mask; argint(0, \u0026amp;mask); if (mask \u0026lt; 0) return -1; struct proc *p = myproc(); p-\u0026gt;trace_mask = mask; return 0; } è¿™æ ·ï¼Œå½“å‰è¿›ç¨‹å°±å¯ä»¥è·å–äº†åˆ°maskï¼Œå½“å…¶åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œå­è¿›ç¨‹ä¹Ÿå¯è·å–åˆ°mask~\nå¦‚ä½•è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ï¼Ÿ åˆšåˆšæˆ‘ä»¬è¯´äº†maskçš„ä½œç”¨ï¼Œè¿˜æœ‰è¿›ç¨‹åŠå…¶å­è¿›ç¨‹å¦‚ä½•è·å–maskï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆåº”è¯¥å¦‚ä½•è·Ÿè¸ªç³»ç»Ÿè°ƒç”¨å‘¢ï¼Ÿ\nxv6ä¸­æ‰€ç”¨çš„ç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯åœ¨ kernel/syscall.c ä¸­çš„ syscall å‡½æ•°ä¸­è°ƒç”¨çš„ï¼Œä¸ºäº†èƒ½åœ¨syscall.cä¸­è°ƒç”¨sys_traceï¼Œéœ€è¦åœ¨å…¶ä¸­æ·»åŠ externå£°æ˜ï¼ˆå…¶å®šä¹‰åœ¨åˆšåˆšå·²ç»å®ç°ï¼Œä½äºkernel/sysproc.cï¼‰ï¼š\nextern uint64 sys_trace(void); åŒæ—¶éœ€è¦åœ¨syscallsæ•°ç»„ä¸­æ·»åŠ sys_traceçš„ç¼–å·ï¼š\nstatic uint64 (*syscalls[])(void) = { // ... ... [SYS_trace] sys_trace, }; // è¿™é‡Œå®é™…ä¸Šå°±æ˜¯ [22] = sys_trace // ä½¿ç”¨äº†gccçš„ä¸€ä¸ªæ‹“å±• å¹¶æŒ‰ç…§é¡ºåºæ·»åŠ å„ä¸ªç³»ç»Ÿè°ƒç”¨çš„åå­—ï¼š\nchar *syscall_names[] = { \u0026#34;fork\u0026#34;, \u0026#34;exit\u0026#34;, \u0026#34;wait\u0026#34;, \u0026#34;pipe\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;kill\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;fstat\u0026#34;, \u0026#34;chdir\u0026#34;, \u0026#34;dup\u0026#34;, \u0026#34;getpid\u0026#34;, \u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;, \u0026#34;uptime\u0026#34;, \u0026#34;open\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;mknod\u0026#34;, \u0026#34;unlink\u0026#34;, \u0026#34;link\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;close\u0026#34;, \u0026#34;trace\u0026#34;, }; åœ¨ kernel/syscall.c ä¸­ï¼Œxv6æ ¹æ®a7å¯„å­˜å™¨è·å–ç³»ç»Ÿè°ƒç”¨çš„ç¼–å·ï¼Œç„¶åé€šè¿‡syscallså‡½æ•°æ•°ç»„æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„å®ç°ä¸ºï¼šå½“ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨åˆæ³•æ—¶ï¼Œè·å–å½“å‰è¿›ç¨‹çš„maskï¼Œå¹¶é€šè¿‡åˆ¤æ–­(mask \u0026gt;\u0026gt; syscall_num) \u0026amp; 1æ˜¯å¦ä¸º1æ¥è¾“å‡ºè·Ÿè¸ªä¿¡æ¯ã€‚\nä¾‹å¦‚sys_readç³»ç»Ÿè°ƒç”¨çš„ç¼–å·ä¸º5ï¼Œmaskä¸º32ï¼Œåˆ™(32 \u0026gt;\u0026gt; 5) \u0026amp; 1 = 1ã€‚\nvoid syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { // Use num to lookup the system call function for num, call it, // and store its return value in p-\u0026gt;trapframe-\u0026gt;a0 p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); // =============================== int mask = p-\u0026gt;trace_mask; if ((mask \u0026gt;\u0026gt; num) \u0026amp; 1) { printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;, p-\u0026gt;pid, syscall_names[num - 1], p-\u0026gt;trapframe-\u0026gt;a0); } // =============================== } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } é‚£ä¹ˆï¼Œå†…æ ¸æ˜¯å¦‚ä½•é€šè¿‡traceæ‰¾åˆ°sys_traceçš„å‘¢ï¼Ÿæ ¹æ®å®éªŒæŒ‡å¯¼ä¸Šçš„æç¤ºï¼Œå¯ä»¥çŸ¥é“ user/usys.pl èµ·åˆ°äº†ä¸€ä¸ªä¸­é—´äººçš„ä½œç”¨ï¼š\n# user/usys.pl ... sub entry { my $name = shift; print \u0026#34;.global $name\\n\u0026#34;; print \u0026#34;${name}:\\n\u0026#34;; print \u0026#34; li a7, SYS_${name}\\n\u0026#34;; print \u0026#34; ecall\\n\u0026#34;; print \u0026#34; ret\\n\u0026#34;; } ... entry(\u0026#34;uptime\u0026#34;); ++entry(\u0026#34;trace\u0026#34;); # è¿™æ˜¯å®éªŒä¸­éœ€è¦ç”±æˆ‘ä»¬è‡ªå·±æ·»åŠ çš„ é€šè¿‡å…¶ä¸­çš„entryå‡½æ•°ï¼Œå¯ä»¥ç”Ÿæˆå¯¹åº”çš„è°ƒç”¨ï¼ˆxv6ä¸­ä¸ºecallï¼‰ç³»ç»Ÿè°ƒç”¨çš„æ±‡ç¼–è¯­å¥ï¼Œå³å¤§è‡´çš„æµç¨‹ä¸ºxv6åœ¨æ„å»ºå†…æ ¸æ—¶ï¼Œä¼šå°†ç”¨æˆ·æ€traceå‘½ä»¤å¯¹åº”åˆ°ï¼š\n.global trace trace: li a7, SYS_trace ecall ret è¿™æ ·ï¼Œå½“å‰è¿›ç¨‹å°±å¯ä»¥é€šè¿‡a7å¯„å­˜å™¨æ‹¿åˆ°sys_traceçš„ç³»ç»Ÿè°ƒç”¨ç¼–å·äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œsyscall å‡½æ•°å¯ä»¥è°ƒç”¨ sys_trace äº†ã€‚\nOKï¼Œé‚£ä¹ˆä¸€ä¸ªå¤§è‡´çš„æ¡†æ¶å°±å‡ºæ¥äº†ï¼š\nå®Œæˆä¸Šé¢çš„æ­¥éª¤åï¼Œæœ€ååªè¦åœ¨Makefileä¸­çš„UPROGSåŠ ä¸Š$U/_traceå³å¯ã€‚\nUPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ ++\t$U/_trace åœ¨è¿™ä¸ªlabä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨sysinfoï¼Œç”¨äºæ”¶é›†æœ‰å…³æ­£åœ¨è¿è¡Œçš„ç³»ç»Ÿçš„ä¿¡æ¯ã€‚\nç³»ç»Ÿè°ƒç”¨çš„å£°æ˜ä¸ºï¼š\nint sysinfo(struct sysinfo*); è¿™ä¸ªç³»ç»Ÿè°ƒç”¨æ¥å—ä¸€ä¸ªæŒ‡å‘ç»“æ„ä½“sysinfoçš„æŒ‡é’ˆï¼Œå…¶å®šä¹‰ä¸ºï¼š\n// kernel/sysinfo.h struct sysinfo { uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process }; å†…æ ¸åº”å¡«å†™æ­¤ç»“æ„çš„å­—æ®µï¼šfreememå­—æ®µåº”è®¾ç½®ä¸ºå¯ç”¨å†…å­˜çš„å­—èŠ‚æ•°ï¼Œnprocå­—æ®µåº”è®¾ä¸ºçŠ¶æ€æœªä½¿ç”¨çš„è¿›ç¨‹æ•°ã€‚\nsysinfo åœ¨è¿™ä¸ªpartä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨sysinfoï¼Œç”¨äºæ”¶é›†æœ‰å…³æ­£åœ¨è¿è¡Œçš„ç³»ç»Ÿçš„ä¿¡æ¯ã€‚\nè®¡ç®—å¯ç”¨å†…å­˜å­—èŠ‚æ•° æˆ‘ä»¬å¯ä»¥é€šè¿‡å†…æ ¸ä¸­çš„kmemæ¥è·å–å¯ç”¨çš„å†…å­˜å—çš„æ•°é‡ï¼š\nstruct { struct spinlock lock; struct run *freelist; } kmem; kmem.freelistæ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œä¿å­˜äº†æ‰€æœ‰å¯ç”¨çš„å†…å­˜å—çš„åœ°å€ï¼Œæˆ‘ä»¬éå†è¿™ä¸ªé“¾è¡¨å³å¯è·å–å¯ç”¨å†…å­˜å—æ•°é‡ï¼Œåˆä¸€ä¸ªå†…å­˜å—çš„å¤§å°ä¸º4KBï¼Œé‚£ä¹ˆç³»ç»Ÿå¯ç”¨çš„å†…å­˜å­—èŠ‚æ•° = å¯ç”¨å†…å­˜å—æ•°é‡ * 4KBï¼š\n// kernel/kalloc.c uint64 freemem() { struct run* r; uint64 free_page = 0; acquire(\u0026amp;kmem.lock); r = kmem.freelist; while (r) { free_page++; r = r-\u0026gt;next; } release(\u0026amp;kmem.lock); // 4K = 2^12ï¼Œå·¦ç§»æ“ä½œç›¸å½“äºå¯¹2çš„ä¹˜æ³• return (free_page \u0026lt;\u0026lt; 12); } è®¡ç®—çŠ¶æ€ä¸ºæœªä¸ºä½¿ç”¨è¿›ç¨‹æ•° å†…æ ¸ä¸­æœ‰ä¸€ä¸ªå…¨å±€æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸€é¡¹ä¸ºç³»ç»Ÿä¸­çš„è¿›ç¨‹ï¼Œxv6ä¸­è®¾ç½®æœ€å¤šè¿›ç¨‹æ•°ä¸º64ä¸ªï¼š\nstruct proc proc[NPROC]; åœ¨è¡¨ç¤ºè¿›ç¨‹çš„ç»“æ„ä½“ä¸­ï¼Œæœ‰ä¸€ä¸ªæˆå‘˜è¡¨ç¤ºè¿™ä¸ªè¿›ç¨‹çš„çŠ¶æ€ï¼š\nenum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // Per-process state struct proc { ... // p-\u0026gt;lock must be held when using these: enum procstate state; ... } æˆ‘ä»¬å¯ä»¥éå†procæ•°ç»„ï¼Œæ‰¾åˆ°æ‰€æœ‰state != UNUSEDçš„è¿›ç¨‹çš„æ•°é‡ï¼ˆè¿™é‡Œä¸€å®šè¦çœ‹æ¸…æ¥šï¼Œæ˜¯çŠ¶æ€ä¸ºæœªä½¿ç”¨çš„è¿›ç¨‹æ•°ï¼Œè€Œä¸æ˜¯æœªä½¿ç”¨çš„è¿›ç¨‹æ•°ï¼‰ï¼š\n// kernel/proc.c uint64 nproc() { struct proc* p; uint64 not_unused = 0; for (p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { if (p-\u0026gt;state != UNUSED) { not_unused++; } } return not_unused; } å®Œæˆç³»ç»Ÿè°ƒç”¨ å¦‚ä½•è·å–ç”¨æˆ·æ€ä¼ é€’è¿‡æ¥çš„å‚æ•°å’Œæ³¨å†Œç³»ç»Ÿè°ƒç”¨å¯ä»¥å‚è€ƒè¿™ç¯‡åšå®¢ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†\næˆ‘ä»¬åˆ›å»ºäº†struct sysinfoç»“æ„ä½“å˜é‡infoåï¼Œä½¿ç”¨åˆšåˆšçš„freememå’Œnprocå‡½æ•°æ¥ä¸ºç»“æ„ä½“å˜é‡èµ‹å€¼ï¼Œä¹‹åé€šè¿‡copyoutå‡½æ•°å°†å†…æ ¸æ€ä¸­çš„infoæ‹·è´ç»™ç”¨æˆ·æ€çš„struct sysinfoç»“æ„ä½“å˜é‡ã€‚\nè¿™é‡Œçš„å®ç°åŸç†æ˜¯ï¼šç”¨æˆ·æ€ä¸‹æˆ‘ä»¬ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ä¼ é€’äº†ä¸€ä¸ªstruct sysinfoæŒ‡é’ˆï¼Œå…¶å®å°±æ˜¯ä¼ é€’äº†ä¸€ä¸ªå†…å­˜åœ°å€addrï¼›å†…æ ¸æ€ä¸‹æˆ‘ä»¬å°†infoä¸­çš„æ•°æ®åŸå°ä¸åŠ¨åœ°æ¬ä¸€ä»½åˆ°addrå¤„ã€‚è¿™æ ·å½“ç”¨æˆ·æ€è®¿é—®addrå¤„çš„å†…å­˜æ—¶å°±å¯ä»¥è·å–åˆ°æƒ³è¦çš„æ•°æ®äº†ã€‚\nuint64 sys_sysinfo() { uint64 addr; argaddr(0, \u0026amp;addr); if (addr \u0026lt; 0) { return -1; } struct proc* p = myproc(); struct sysinfo info; info.freemem = freemem(); info.nproc = nproc(); if (copyout(p-\u0026gt;pagetable, addr, (char*)\u0026amp;info, sizeof(info))) { return -1; } return 0; } ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eè¿™ä¸ªlabå¼€å§‹æˆ‘ä»¬å°±æ­£å¼è¿›å…¥äº†xv6çš„ä¸–ç•Œäº†ï¼Œè¿™ä¸€æ¬¡æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°å†…æ ¸ä¸­ç³»ç»Ÿè°ƒç”¨çš„æ³¨å†Œå’Œè¿è¡ŒåŸç†ï¼Œè¿™å¯ä»¥è¯´æ˜¯ä¹‹ålabçš„ä¸€ä¸ªåŸºçŸ³ã€‚\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab2 system calls"},{"content":"å‰è¨€ è¯¥Labé€šè¿‡å®ç°å‡ ä¸ªå‘½ä»¤æ¥ç†Ÿæ‚‰ xv6 åŠå…¶ç³»ç»Ÿè°ƒç”¨\nsleep pingpong primes find xargs å®˜æ–¹å®éªŒæŒ‡å¯¼ï¼šhttps://pdos.csail.mit.edu/6.S081/2021/labs/util.html\nä¸ªäººä»£ç å®ç°ä»“åº“ï¼šhttps://github.com/kerolt/xv6-labs-2023\nç¯å¢ƒæ­å»º ä½¿ç”¨dockeråˆ›å»ºubuntu20.04å®¹å™¨ï¼Œåæ‰§è¡Œï¼š\napt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu ä¹‹åæµ‹è¯•ä¸€ä¸‹ï¼š\né¦–å…ˆä¸‹è½½xv6æºç ï¼šgit clone https://github.com/mit-pdos/xv6-riscv.git è¿è¡Œï¼šmake qemuï¼Œå¦‚æœç»“æœå¦‚ä¸‹ï¼Œè¯´æ˜æˆåŠŸï¼ŒæŒ‰ä¸‹ctrl + aå’Œxé€€å‡ºqemu # ... lots of output ... init: starting sh $ æµ‹è¯• å¯¹äºå®Œæˆçš„ç¨‹åºï¼Œå¦‚æœæƒ³è¦æµ‹è¯•ï¼Œåˆ™åœ¨Makefileä¸­çš„UPROGSä¸­æ·»åŠ ï¼š\n$U/_\u0026lt;xxx\u0026gt;\\ å…¶ä¸­çš„xxxå³ä¸ºç¨‹åºçš„åç§°ï¼Œå¦‚sleep,åˆ™ä¸º$U/_sleep\\ã€‚\nä¹‹åï¼Œå¯ä½¿ç”¨å¦‚ä¸‹æ–¹æ³•è¿›è¡Œæµ‹è¯•ï¼š\n./grade-lab-util xxx # or make GRADEFLAGS=xxx grade sleep (easy) ç»ƒå‰å¼€èƒƒèœï¼Œä½¿ç”¨sleepç³»ç»Ÿè°ƒç”¨ã€‚\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char* argv[]) { if (argc != 2) { printf(\u0026#34;Usage: sleep \u0026lt;seconds\u0026gt;\\n\u0026#34;); exit(1); } int time = atoi(argv[1]); sleep(time); return exit(0); } pingpong (easy) ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œä½¿ç”¨ UNIX ç³»ç»Ÿè°ƒç”¨åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´é€šè¿‡ä¸€å¯¹ç®¡é“ \u0026ldquo;ä¹’ä¹“ \u0026ldquo;ä¼ é€ä¸€ä¸ªå­—èŠ‚ï¼Œæ¯ä¸ªç®¡é“ä¸€ä¸ªæ–¹å‘ã€‚\nè¯¥ç¨‹åºéœ€è¦æ³¨æ„çš„å°±æ˜¯å¯¹äºä¸¤ä¸ªç®¡é“çš„æ“ä½œï¼Œä½•æ—¶å…³ï¼Œå…³å“ªä¸ªï¼Ÿè¯»å†™é¡ºåºåˆå¦‚ä½•ï¼Ÿ\nå¯¹äºçˆ¶è¿›ç¨‹ï¼Œåº”è¯¥å…ˆå†™å†è¯» å¯¹äºå­è¿›ç¨‹ï¼Œåº”è¯¥å…ˆè¯»å†å†™ #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #define R 0 #define W 1 int main() { int p2c[2], c2p[2]; pipe(p2c); pipe(c2p); int pid = fork(); if (pid == 0) { // chile: read from the parent char buf[32] = {0}; close(c2p[R]); // ä¸ç”¨ä»å­è¿›ç¨‹è¯» close(p2c[W]); // ä¸ç”¨ä»çˆ¶è¿›ç¨‹å†™ read(p2c[R], buf, sizeof(buf)); close(p2c[R]); printf(\u0026#34;%d: received ping\\n\u0026#34;, getpid()); write(c2p[W], \u0026#34;pong\u0026#34;, 4); close(c2p[W]); exit(0); } else { // parent: read from the child char buf[32] = {0}; close(p2c[R]); // ä¸ç”¨ä»çˆ¶è¿›ç¨‹è¯» close(c2p[W]); // ä¸ç”¨ä»å­è¿›ç¨‹å†™ write(p2c[W], \u0026#34;ping\u0026#34;, 4); close(p2c[W]); read(c2p[R], buf, sizeof(buf)); printf(\u0026#34;%d: received pong\\n\u0026#34;, getpid()); close(c2p[R]); exit(0); } } primes ï¼ˆmoderate/hardï¼‰ ä½¿ç”¨ç®¡é“ç¼–å†™å¹¶å‘ç‰ˆè´¨æ•°ç­›ã€‚\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; void Filter(int pipe_fd[2]) { close(pipe_fd[1]); int prime; read(pipe_fd[0], \u0026amp;prime, 4); printf(\u0026#34;prime %d\\n\u0026#34;, prime); int num; if (read(pipe_fd[0], \u0026amp;num, 4) == 0) { exit(0); } int new_pipe_fd[2]; pipe(new_pipe_fd); int pid = fork(); if (pid == -1) { printf(\u0026#34;Fork error!\\n\u0026#34;); exit(1); } else if (pid == 0) { Filter(new_pipe_fd); } else { close(new_pipe_fd[0]); if (num % prime != 0) { write(new_pipe_fd[1], \u0026amp;num, 4); } while (read(pipe_fd[0], \u0026amp;num, 4) \u0026gt; 0) { if (num % prime != 0) { write(new_pipe_fd[1], \u0026amp;num, 4); } } close(new_pipe_fd[1]); close(pipe_fd[0]); wait(0); } } int main() { int pipe_fd[2]; pipe(pipe_fd); int pid = fork(); if (pid == -1) { printf(\u0026#34;Fork error!\\n\u0026#34;); exit(1); } else if (pid == 0) { Filter(pipe_fd); } else { close(pipe_fd[0]); for (int i = 2; i \u0026lt;= 35; i++) { write(pipe_fd[1], \u0026amp;i, 4); // ä¸€ä¸ªintä¸º4 byte } close(pipe_fd[1]); wait(0); } exit(0); } find (moderate) å®ç°Unixä¸‹çš„findå‘½ä»¤ï¼Œåˆ©ç”¨é€’å½’å¤„ç†ï¼Œè¦æ³¨æ„å…³é—­æ–‡ä»¶æè¿°ç¬¦çš„æ—¶æœºã€‚\næœ€å…³é”®çš„æ˜¯è¦ç†è§£ç›®å½•ï¼ˆæ–‡ä»¶å¤¹ï¼‰ä¹Ÿæ˜¯ä¸€ç§æ–‡ä»¶ï¼Œå…¶ç›®å½•é¡¹å°±æ˜¯è¿™ä¸ªæ–‡ä»¶çš„å†…å®¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡readç³»ç»Ÿè°ƒç”¨æ¥è¯»å–ç›®å½•é¡¹ï¼Œè¿›è€Œå½“è¯»å–çš„å†…å®¹çš„ç±»å‹æ˜¯ä¸€ä¸ªç›®å½•æ—¶ï¼Œå³å¯é€’å½’è°ƒç”¨Findã€‚\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; char* GetName(char* path) { char* p; for (p = path + strlen(path); p \u0026gt;= path \u0026amp;\u0026amp; *p != \u0026#39;/\u0026#39;; p--) {} p++; return p; } void Find(char* dir, char* name) { char buf[512]; char* p; int fd = open(dir, 0); struct dirent de; struct stat st; if (fd \u0026lt; 0) { printf(\u0026#34;Error: open\\n\u0026#34;); return; } if (fstat(fd, \u0026amp;st) \u0026lt; 0) { printf(\u0026#34;Error: stat\\n\u0026#34;); close(fd); return; } if (st.type != T_DIR) { printf(\u0026#34;the current the file is not dictionary\\n\u0026#34;, dir); close(fd); return; } strcpy(buf, dir); p = buf + strlen(buf); *p++ = \u0026#39;/\u0026#39;; while (read(fd, \u0026amp;de, sizeof(de)) == sizeof(de)) { if (de.inum == 0) continue; if (strcmp(de.name, \u0026#34;.\u0026#34;) == 0) continue; if (strcmp(de.name, \u0026#34;..\u0026#34;) == 0) continue; char* cur = p; memmove(cur, de.name, DIRSIZ); cur[DIRSIZ] = 0; if (stat(buf, \u0026amp;st) \u0026lt; 0) { printf(\u0026#34;Error: stat\\n\u0026#34;); continue; } switch (st.type) { case T_FILE: if (strcmp(GetName(buf), name) == 0) { printf(\u0026#34;%s\\n\u0026#34;, buf); } break; case T_DIR: if (strlen(dir) + 1 + DIRSIZ + 1 \u0026gt; sizeof(buf)) { printf(\u0026#34;Error: path too long\\n\u0026#34;); break; } Find(buf, name); break; } } close(fd); } int main(int argc, char* argv[]) { if (argc != 3) { printf(\u0026#34;Usage: find \u0026lt;dir\u0026gt; \u0026lt;file_name\u0026gt;\\n\u0026#34;); exit(1); } Find(argv[1], argv[2]); exit(0); } xargs (moderate) ç®€å•å®ç°Unixä¸Šçš„xargså‘½ä»¤ã€‚ç®€å•ä»‹ç»xargsçš„ç”¨æ³•ï¼Œå°±æ˜¯å°†æ ‡å‡†è¾“å…¥ä½œä¸ºxargsçš„å‚æ•°ã€‚æ›´å¤šçš„ä»‹ç»ï¼Œå¯ä»¥çœ‹é˜®ä¸€å³°è€å¸ˆçš„åšå®¢ï¼šhttps://ruanyifeng.com/blog/2019/08/xargs-tutorial.html\nè¯¥å‘½ä»¤çš„å¯ä½¿ç”¨forkå’Œexecæ¥å®ç°ã€‚\n#include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char* argv[]) { if (argc \u0026lt; 2) { printf(\u0026#34;Usage: xargs \u0026lt;params\u0026gt;\\n\u0026#34;); exit(1); } char* child_argv[MAXARG]; char buf[512] = {\u0026#39;\\0\u0026#39;}; int index = 0; for (int i = 1; i \u0026lt; argc; i++) { child_argv[index++] = argv[i]; } sleep(10); // ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–å‘½ä»¤åˆ°bufä¸­ // è‹¥æ‰§è¡Œ echo 1 2 3ï¼Œåˆ™æ ‡å‡†è¾“å…¥ä¸º 1 2 3 int n; while ((n = read(0, buf, sizeof(buf))) \u0026gt; 0) { char* p = buf; for (int i = 0; i \u0026lt; n; i++) { if (buf[i] != \u0026#39;\\n\u0026#39;) continue; if (fork() == 0) { buf[i] = \u0026#39;\\0\u0026#39;; // ä¾‹å¦‚ï¼šecho 1 | xargs echo 2 // åœ¨xargsä¸­ï¼Œæ ‡å‡†è¾“å…¥ä¸º1ï¼Œbufä¸­å†…å®¹ä¸º\u0026#34;1\\n\u0026#34;ï¼Œchild_argvä¸º[\u0026#34;echo\u0026#34;, \u0026#34;2\u0026#34;]ï¼Œindexä¸º2 // ç¨‹åºæ‰§è¡Œåˆ°æ­¤å¤„æ—¶ï¼Œbufä¸­å†…å®¹å˜ä¸ºäº†\u0026#34;1\\0\u0026#34;ï¼Œchild_argvå˜ä¸ºäº†[\u0026#34;echo\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;1\u0026#34;] child_argv[index] = p; // execçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦æ‰§è¡Œçš„å¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ // ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä½œä¸ºæ–°å‘½ä»¤çš„å‚æ•°æ•°ç»„ï¼Œæ•°ç»„çš„ç¬¬ä¸€é¡¹ä¸ºæ–°å‘½ä»¤çš„åç§° exec(child_argv[0], child_argv); exit(0); } else { // åœ¨çˆ¶è¿›ç¨‹ä¸­ï¼Œè·³è¿‡bufä¸­çš„\\nåï¼Œæ˜¯ä¸€æ¡æ–°å‘½ä»¤çš„å¼€å§‹ p = \u0026amp;buf[i + 1]; wait(0); } } } exit(0); } ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab1-utilities/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eè¯¥Labé€šè¿‡å®ç°å‡ ä¸ªå‘½ä»¤æ¥ç†Ÿæ‚‰ xv6 åŠå…¶ç³»ç»Ÿè°ƒç”¨\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esleep\u003c/li\u003e\n\u003cli\u003epingpong\u003c/li\u003e\n\u003cli\u003eprimes\u003c/li\u003e\n\u003cli\u003efind\u003c/li\u003e\n\u003cli\u003exargs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eå®˜æ–¹å®éªŒæŒ‡å¯¼ï¼š\u003ca href=\"https://pdos.csail.mit.edu/6.S081/2021/labs/util.html\"\u003ehttps://pdos.csail.mit.edu/6.S081/2021/labs/util.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eä¸ªäººä»£ç å®ç°ä»“åº“ï¼š\u003ca href=\"https://github.com/kerolt/xv6-labs-2023/\"\u003ehttps://github.com/kerolt/xv6-labs-2023\u003c/a\u003e\u003c/p\u003e","title":"ã€MIT6.S081ã€‘Lab1 utilities"},{"content":" è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nè¿™ä¸ªProjectéœ€è¦æˆ‘ä»¬å®ç°ä¸€ä¸ªç¼“å­˜æ± ï¼Œå‡å°‘å¯¹äºç£ç›˜çš„é¢‘ç¹IOã€‚å¼€å§‹æ…¢æ…¢ä¸Šå¼ºåº¦äº†ï¼Œç»†èŠ‚æ‹‰æ»¡ï¼\nTask1 - LRU-K Replacement Policy ä»€ä¹ˆæ˜¯LRUç®—æ³•ï¼ŸLRUæ˜¯Least Recently Usedçš„ç¼©å†™ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼Œæ˜¯ä¸€ç§å¸¸ç”¨çš„é¡µé¢ç½®æ¢ç®—æ³•ï¼Œé€‰æ‹©æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢äºˆä»¥æ·˜æ±°ã€‚è¯¥ç®—æ³•èµ‹äºˆæ¯ä¸ªé¡µé¢ä¸€ä¸ªè®¿é—®å­—æ®µï¼Œç”¨æ¥è®°å½•ä¸€ä¸ªé¡µé¢è‡ªä¸Šæ¬¡è¢«è®¿é—®ä»¥æ¥æ‰€ç»å†çš„æ—¶é—´ tï¼Œå½“é¡»æ·˜æ±°ä¸€ä¸ªé¡µé¢æ—¶ï¼Œé€‰æ‹©ç°æœ‰é¡µé¢ä¸­å…¶ t å€¼æœ€å¤§çš„ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é¡µé¢äºˆä»¥æ·˜æ±°ã€‚\nLRU-Kæ˜¯ä¸€ç§å¢å¼ºå‹çš„LRUï¼Œå…¶ä¸»è¦æ€æƒ³æ˜¯åˆ©ç”¨å†å²è®¿é—®æ¨¡å¼æ¥è¿›è¡Œé¡µé¢ç½®æ¢å†³ç­–ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š\nè®¿é—®è®°å½•ï¼šæ¯ä¸ªé¡µé¢ç»´æŠ¤ä¸€ä¸ªè®¿é—®æ—¶é—´æˆ³åˆ—è¡¨ï¼Œè®°å½•å…¶æœ€è¿‘çš„kæ¬¡è®¿é—®æ—¶é—´ã€‚è¿™ä¸ªåˆ—è¡¨ç”¨äºè®¡ç®—å‘åkè·ç¦»ã€‚ å‘åkè·ç¦»ï¼šå½“ä¸€ä¸ªé¡µé¢è¢«è®¿é—®æ—¶ï¼Œç®—æ³•ä¼šæ›´æ–°å…¶æ—¶é—´æˆ³åˆ—è¡¨ï¼Œå¹¶è®¡ç®—å‘åkè·ç¦»ã€‚å‘åkè·ç¦»æ˜¯å½“å‰æ—¶é—´æˆ³ä¸åˆ—è¡¨ä¸­ç¬¬kä¸ªæ—¶é—´æˆ³ä¹‹é—´çš„å·®å€¼ã€‚å¦‚æœåˆ—è¡¨ä¸­æ²¡æœ‰kä¸ªæ—¶é—´æˆ³ï¼Œè¯¥é¡µé¢çš„å‘åkè·ç¦»è¢«èµ‹å€¼ä¸ºæ­£æ— ç©·ã€‚ é¡µé¢æ›¿æ¢ï¼š åœ¨éœ€è¦æ›¿æ¢é¡µé¢æ—¶ï¼Œç®—æ³•ä¼šéå†æ‰€æœ‰é¡µé¢ï¼Œæ‰¾åˆ°å…·æœ‰æœ€å¤§å‘åkè·ç¦»çš„é¡µé¢è¿›è¡Œæ›¿æ¢ã€‚ å¦‚æœå­˜åœ¨å¤šä¸ªé¡µé¢çš„å‘åkè·ç¦»ä¸ºæ­£æ— ç©·ï¼Œç®—æ³•å°†é€‰æ‹©è¿™äº›é¡µé¢ä¸­æœ€æ—©çš„è®¿é—®æ—¶é—´æˆ³è¿›è¡Œæ›¿æ¢ã€‚ ä¼˜ç‚¹ï¼šLRU-Kç›¸è¾ƒäºä¼ ç»Ÿçš„LRUç®—æ³•æ›´ä¸ºæ™ºèƒ½ï¼Œå®ƒèƒ½æ›´å¥½åœ°é€‚åº”ä¸åŒçš„è®¿é—®æ¨¡å¼ï¼Œå‡å°‘ä¸å¿…è¦çš„é¡µé¢ç½®æ¢ã€‚é€šè¿‡è€ƒè™‘å†å²è®¿é—®ï¼Œå®ƒèƒ½å¤Ÿè¯†åˆ«å‡ºå“ªäº›é¡µé¢å¯èƒ½ä¼šè¢«é¢‘ç¹ä½¿ç”¨ï¼Œä»è€Œæé«˜ç¼“å­˜çš„å‘½ä¸­ç‡ã€‚ åœ¨BusTubçš„å®ç°ä¸­ï¼ŒLRU-Kæœ‰ç€æ¯ä¸ªframe idä¸LRUKNodeçš„æ˜ å°„ã€‚\nclass LRUKNode { private: [[maybe_unused]] std::list\u0026lt;size_t\u0026gt; history_; [[maybe_unused]] size_t k_; [[maybe_unused]] frame_id_t fid_; [[maybe_unused]] bool is_evictable_{false}; }; ä¸€ä¸ªnodeè®°å½•äº†ä¸€ä¸ªframeçš„idï¼Œè¿˜æœ‰è¿™ä¸ªframeåœ¨æœ€è¿‘ä½¿ç”¨kæ¬¡çš„æ—¶é—´æˆ³ã€‚\nEvict(frame_id_t* frame_id)Â : ä¸æ‰€æœ‰å…¶ä»–å¯åˆ é™¤çš„frameç›¸æ¯”ï¼Œåˆ é™¤å…·æœ‰æœ€å¤§å‘åkè·ç¦»çš„frameã€‚å°†frame idå­˜å‚¨åœ¨è¾“å‡ºå‚æ•°ä¸­å¹¶è¿”å›Trueã€‚å¦‚æœæ²¡æœ‰å¯æ›¿æ¢çš„frameï¼Œåˆ™è¿”å›Falseã€‚å…·æœ‰å°‘äºkä¸ªè®¿é—®è®°å½•çš„frameè¢«ç»™å®šâ€œæ— ç©·â€ä½œä¸ºå…¶å‘åkè·ç¦»ã€‚å¦‚æœå¤šä¸ªå¸§å…·æœ‰infå‘åkè·ç¦»ï¼Œåˆ™æ ¹æ®LRUé©±é€å…·æœ‰æœ€æ—©æ—¶é—´æˆ³çš„å¸§ã€‚æˆåŠŸåˆ é™¤å¸§åº”å‡å°æ›¿æ¢å™¨çš„å¤§å°å¹¶åˆ é™¤å¸§çš„è®¿é—®å†å²è®°å½•ã€‚ RecordAccess(frame_id_t frame_id)Â : æ¯æ¬¡è°ƒç”¨RecordAccessï¼Œå†…ç½®çš„æ—¶é—´æˆ³å°±è¦+1ï¼Œå¹¶ä¸”æ ¹æ®frame_idæ˜¯å¦åœ¨LRUç¼“å­˜ä¸­æ¥å†³å®šæ˜¯æ›´æ–°å¯¹åº”çš„nodeè¿˜æ˜¯æ·»åŠ ä¸€ä¸ªæ–°nodeã€‚ Addï¼šæ–°å»ºä¸€ä¸ªnodeï¼Œå¹¶ä¸”åˆå§‹åŒ–ï¼Œå†æŠŠnodeæ’å…¥ç¼“å­˜ Updateï¼šé€šè¿‡frame idæ‰¾åˆ°å¯¹åº”çš„nodeï¼Œå¹¶ä¿®æ”¹nodeçš„å†å²è®¿é—®æ—¶é—´æˆ³ï¼Œæ›´æ–°å®ƒåœ¨ç¼“å­˜ä¸­çš„è®¿é—®ä½ç½® Remove(frame_id_t frame_id)Â : ä»LRUç¼“å­˜ä¸­åˆ é™¤frame idä»¥åŠå¯¹åº”çš„nodeã€‚è¦æ³¨æ„åˆ é™¤åå¯¹å½“å‰â€œå¯æ›¿æ¢çš„frameæ•°é‡â€-1ã€‚ SetEvictable(frame_id_t frame_id, bool set_evictable)Â : æ§åˆ¶frameæ˜¯å¦å¯é€å‡ºã€‚å®ƒè¿˜æ§åˆ¶ç€LRUKReplacerçš„sizeã€‚ Size()Â : è¿”å›LRUKReplacerä¸­å½“å‰å¯æ›¿æ¢çš„frameæ•°é‡ã€‚ æ€»çš„æ¥è¯´ï¼ŒæŠŠè¿™ä¸ªtaskå½“æˆåŠ›æ‰£ä¸Šçš„ä¸€é“æ•°æ®ç»“æ„è®¾è®¡é¢˜æ¥å®Œæˆå°±å¥½äº†ã€‚\nTask2 - Disk Scheduler æ¯”è¾ƒç®€å•ï¼Œå®ç°ä¸¤ä¸ªå‡½æ•°çš„åŠŸèƒ½ï¼š\nSchedule(DiskRequest r)ï¼šè°ƒåº¦DiskManageræ‰§è¡Œçš„è¯·æ±‚ã€‚DiskRequestç»“æ„ä½“æŒ‡å®šè¯·æ±‚æ˜¯å¦ä¸ºè¯»/å†™ï¼Œæ•°æ®åº”å†™å…¥/ä»ä½•å¤„å†™å…¥ï¼Œä»¥åŠæ“ä½œçš„é¡µé¢IDã€‚DiskRequestè¿˜åŒ…æ‹¬ä¸€ä¸ªstd::promiseï¼Œä¸€æ—¦è¯·æ±‚è¢«å¤„ç†ï¼Œå…¶å€¼åº”è®¾ç½®ä¸ºtrueã€‚ StartWorkerThread()ï¼šå¯åŠ¨å¤„ç†è¯·æ±‚çš„åå°å·¥ä½œçº¿ç¨‹ã€‚åœ¨DiskScheduleræ„é€ å‡½æ•°ä¸­åˆ›å»ºå·¥ä½œçº¿ç¨‹å¹¶è°ƒç”¨æ­¤æ–¹æ³•ã€‚æ­¤æ–¹æ³•è´Ÿè´£è·å–æ’é˜Ÿçš„è¯·æ±‚å¹¶å°†å…¶åˆ†æ´¾ç»™DiskManagerã€‚è®°ä½è®¾ç½®DiskRequestå›è°ƒçš„å€¼ï¼Œä»¥å‘è¯·æ±‚å‘å‡ºè€…å‘å‡ºè¯·æ±‚å·²å®Œæˆçš„ä¿¡å·ã€‚åœ¨è°ƒç”¨DiskSchedulerçš„ææ„å‡½æ•°ä¹‹å‰ï¼Œè¿™ä¸åº”è¯¥è¿”å›ã€‚ Task3 - Buffer Pool Manager BufferPoolManagerå†…éƒ¨é‡‡ç”¨ä¸€ä¸ªåŸå§‹æ•°ç»„æ¥å­˜æ”¾Pageçš„æŒ‡é’ˆã€‚åˆå§‹æ—¶ï¼Œæ¯ä¸ªpageéƒ½åœ¨free listä¸­ã€‚\nåŒä¸€ä¸ªå—ï¼Œåœ¨å†…å­˜ä¸­ç§°ä½œâ€œå¸§ï¼ˆframeï¼‰â€ï¼Œåœ¨ç¡¬ç›˜ä¸­ç§°ä½œâ€œé¡µï¼ˆpageï¼‰â€ã€‚ç¼“å†²æ± ä¸­ä¼šå­˜å‚¨pool_sizeä¸ªPageï¼Œè¿™äº›ä¸ªPageåŒ…å«ç¡¬ç›˜ä¸Šçš„æ•°æ®å’Œä¸€äº›å…ƒä¿¡æ¯ã€‚\nBufferPoolManagerä¸­çš„page_table_é‡‡ç”¨page_idä½œä¸ºé”®ï¼Œframe_idä½œä¸ºå€¼ã€‚å¦‚æœæœ‰æŸä¸ªframeè¢«ä½¿ç”¨äº†ï¼Œé‚£ä¹ˆpage_table_ä¸­å°±ä¼šæ’å…¥ç›¸åº”çš„é”®å€¼å¯¹ã€‚BufferPoolManagerä¸­çš„pages_çš„ä¸‹æ ‡å³ä»£è¡¨äº†frame idï¼Œæˆ‘ä»¬é€šè¿‡page idå¯ä»¥æ‰¾åˆ°å¯¹åº”çš„frame idï¼Œå†é€šè¿‡frame idå°±å¯ä»¥æ‰¾åˆ°åœ¨pages_ä¸­çš„Pageäº†ã€‚\nä¸‹å›¾æ¥æºï¼šhttps://www.qtmuniao.com/2021/02/10/cmu15445-project1-buffer-pool/\næˆ‘ä»¬å¯ä»¥ä»freelistæˆ–è€…replacerä¸­æ‰¾åˆ°frameï¼ˆä¼˜å…ˆä»freelistä¸­æ‰¾ï¼‰ã€‚å¦‚æœfree listä¸­æœ‰ç©ºé—²çš„frameï¼Œåˆ™ä½¿ç”¨å®ƒï¼›å¦åˆ™ä»replacerä¸­é€‰å‡ºéœ€è¦æ¢å‡ºçš„frameï¼ˆreplacerçš„sizeä¸buffer poolçš„sizeç›¸åŒï¼‰ã€‚\nè¦å®ç°çš„æ¯ä¸ªå‡½æ•°åœ¨ä»£ç å¤´æ–‡ä»¶ä¸­éƒ½æœ‰è¾ƒä¸ºè¯¦ç»†çš„å®ç°è¿‡ç¨‹ï¼Œéœ€è¦æ³¨æ„å¾ˆå¤šç»†èŠ‚ã€‚\néœ€è¦æ³¨æ„:\næ¯æ¬¡æ‰§è¡ŒFetchPageæ—¶ç›¸å½“äºè¦ä½¿ç”¨åˆ°æŸä¸€ä¸ªé¡µé¢ï¼Œæ—¢ç„¶å¦‚æ­¤ï¼Œä¹Ÿè¦åœ¨LRU-Kç¼“å­˜ä¸­æ›´æ–°å†å²è®¿é—®åºåˆ—ï¼ˆé€šè¿‡è°ƒç”¨RecordAccessï¼‰ï¼› éœ€è¦æ–°çš„frameæ—¶ï¼Œä¼˜å…ˆä»free listä¸­æ‰¾ï¼Œå…¶æ¬¡é€šè¿‡replacerçš„Evictæ¥è·å–ï¼› å¯¹äºé¡µé¢çš„pin_count_ï¼Œåªæœ‰å½“æŸä¸ªå‡½æ•°è¿”å›çš„æ˜¯Page*æ—¶ï¼Œè¯´æ˜è¿™ä¸ªé¡µæ˜¯éœ€è¦ä½¿ç”¨çš„ï¼Œæ­¤æ—¶å…¶pin_count_ + 1ï¼›è€Œåªæœ‰åœ¨Unpinä¸­ï¼Œæ‰ä¼šå¯¹pin_count_ - 1ï¼› å¦‚æœéœ€è¦æ›¿æ¢æˆ–æ–°å»ºæˆ–åˆ é™¤æŸä¸ªé¡µé¢æ—¶ï¼Œå…¶è„ä½ä½trueï¼Œåˆ™è¦åŠæ—¶å†™å›ç£ç›˜ï¼› é”™è¯¯è®°å½• é”™è¯¯ç‚¹1ï¼šæ²¡æœ‰ä¿è¯LRU-Kä¸­çš„åŸå­æ€§ å¯¹äºå½“å‰å¯æ›¿æ¢çš„frameæ•°é‡çš„æ“ä½œåº”è¯¥æ˜¯åŸå­æ€§çš„ï¼Œå¯ä»¥ç”¨atomic_size_tæ¥å–ä»£size_tï¼Œæˆ–è€…ä½¿ç”¨é”ã€‚\né”™è¯¯ç‚¹2ï¼šæœ€å¤§å‘å‰Kè·ç¦»çš„è®¡ç®—é”™è¯¯ The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance.Â When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).\nä¸»è¦æ˜¯å¯¹è¿™æ®µè¯çš„ç†è§£ä¸åˆ°ä½ï¼Œä¹‹å‰æ˜¯è¿™æ ·ï¼š\n// è®¡ç®—æœ€å¤§å‘åKè·ç¦» int k_dist = node.history_.size() \u0026lt; k_ ? std::numeric_limits\u0026lt;int\u0026gt;::max() : (current_timestamp_ - node.history_[k_ - 1]); if (k_dist \u0026gt; max_k_dist) { evict_frame_id = fid; max_k_dist = k_dist; } else if (k_dist == max_k_dist \u0026amp;\u0026amp; node.history_.back() \u0026lt; node_store_[evict_frame_id].history_.back()) { evict_frame_id = fid; } ä½†å®é™…åº”è¯¥ä¸ºï¼š\n// è®¡ç®—æœ€å¤§å‘åKè·ç¦» int k_dist = node.history_.size() \u0026lt; k_ ? std::numeric_limits\u0026lt;int\u0026gt;::max() : (current_timestamp_ - node.history_[k_ - 1]); if (k_dist \u0026gt; max_k_dist) { evict_frame_id = fid; max_k_dist = k_dist; } else if (k_dist == max_k_dist \u0026amp;\u0026amp; node.history_.back() \u0026lt; node_store_[evict_frame_id].history_.back()) { evict_frame_id = fid; } å½“æœ‰å¤šä¸ªè·ç¦»ä¸ºæ— ç©·å¤§çš„frameæ—¶ï¼Œåº”è¯¥é€‰æ‹©å…¶å†å²è®°å½•ä¸­å…·æœ‰æœ€å°æ—¶é—´æˆ³çš„é‚£ä¸ªframeï¼\né”™è¯¯3ï¼šFetchPageæ‰¾åˆ°ç›´æ¥è¿”å›æ—¶æ²¡æœ‰pinä¸€ä¸‹ è¿™é‡Œå¡äº†å‡ ä¸ªæµ‹è¯•æ˜¯å› ä¸ºFetchPageåœ¨page_idåœ¨ç¼“å†²æ± ä¸­æ—¶ä¼šç›´æ¥è¿”å›ï¼Œä½†æ˜¯æˆ‘æ²¡æœ‰åœ¨è¿™ç§æƒ…å†µä¸­å¯¹è¿™ä¸ªpageçš„pin_count_è¿›è¡Œ+1æ“ä½œã€‚\né”™è¯¯4ï¼šUnpinä¸­çš„is_dirtyå‚æ•°çš„è®¾ç½® åœ¨Unpinä¸­ï¼Œä¸èƒ½ç›´æ¥å°†page.is_dirty_è®¾ç½®æˆå‚æ•°is_dirtyï¼Œè€Œæ˜¯åº”è¯¥ç”¨æˆ–æ“ä½œï¼špage.is_dirty_ |= is_dirty;ã€‚å¦‚æœä¸è¿™æ ·åšï¼Œé‚£ä¹ˆå½“åŸå…ˆpage.is_dirty_ä¸ºtrueæ—¶ï¼Œå¦‚æœæˆ‘ä»¬é€šè¿‡Unpinè®¾ç½®äº†falseï¼Œå…¶is_dirty_å°±å˜ä¸ºäº†falseï¼Œä½†æ˜¯è¿™ä¸ªé¡µé¢ä»ç„¶æ˜¯è„é¡µé¢ã€‚\né”™è¯¯5ï¼šFetchPageæ²¡æœ‰RecordAccess åœ¨FetchPageä¸­ï¼Œå¦‚æœç¼“å†²æ± ä¸­æœ‰ page id ç›´æ¥è¿”å›æ—¶ï¼Œreplacer_ä¹Ÿåº”è¯¥æ‰§è¡ŒRecordAccessã€‚å› ä¸ºè¿™æ—¶ç›¸å½“äºä½¿ç”¨äº†Pageï¼Œå½“ç„¶è¦è®°å½•æ›´æ–°ã€‚\næœ€ç»ˆæäº¤ ç„¶åLeaderboardçš„æ’åæœ‰ç‚¹ä½äº†ï¼Œå› ä¸ºä¹‹å‰éƒ½æ˜¯ä½¿ç”¨çš„å¤§é”ï¼Œå¸Œæœ›ä¹‹åèƒ½ä¼˜åŒ–ä¸€ä¸‹ã€‚\nå°ç»“ è¿™ä¸ªProjectå·®ä¸å¤šæäº†å››äº”å¤©ï¼Œä¸»ä½“ä»£ç ç”¨äº†ä¸¤å¤©å·¦å³ï¼Œç„¶åå°±æ˜¯æ¼«é•¿çš„ä¿®Bugã€‚ç”±äºä»è¿™ä¸ªProjectå¼€å§‹ï¼Œå°±ä¸ä¼šåœ¨æœ¬åœ°ç»™å‡ºå®Œæ•´çš„æµ‹è¯•é›†äº†ï¼Œæ‰€ä»¥åœ¨è¯„æµ‹å¹³å°ä¸Šä¹Ÿæ˜¯æäº¤äº†å¾ˆå¤šæ¬¡æ¥æ£€æµ‹ã€‚é€šè¿‡Discordä¸­çš„é¢‘é“ï¼Œä¹Ÿæ˜¯æ‰¾åˆ°äº†ä¸€äº›è§£å†³Bugçš„åŠæ³•ï¼Œå¾ˆå¤šæ—¶å€™æ˜¯ä¸€äº›ç»†èŠ‚å¤„è‡ªå·±æ²¡æœ‰è€ƒè™‘åˆ°ï¼ˆé”™è¯¯è®°å½•ï¼‰ã€‚å¥½åœ¨æœ€åä¹ŸåŸºæœ¬ä¸Šæ˜¯è‡ªå·±ç‹¬ç«‹å®Œæˆçš„ï¼Œæœ‰ç‚¹å°å°çš„æˆå°±æ„Ÿï¼\n","permalink":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project1-buffer-pool-%E5%B0%8F%E7%BB%93/","summary":"\u003cblockquote\u003e\n\u003cp\u003eè¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eè¿™ä¸ªProjectéœ€è¦æˆ‘ä»¬å®ç°ä¸€ä¸ªç¼“å­˜æ± ï¼Œå‡å°‘å¯¹äºç£ç›˜çš„é¢‘ç¹IOã€‚å¼€å§‹æ…¢æ…¢ä¸Šå¼ºåº¦äº†ï¼Œç»†èŠ‚æ‹‰æ»¡ï¼\u003c/p\u003e","title":"ã€CMU15-445 Fall2023ã€‘Project1 Buffer Pool å°ç»“"},{"content":" è¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\nproject0åªåœ¨task4ä¸­æµ…æµ…æ¶‰åŠäº†ä¸€ç‚¹BusTubçš„å†…å®¹ï¼Œå…¶ä»–éƒ½æ˜¯æ£€æµ‹æˆ‘ä»¬å¯¹äºC++çš„ä¸€ä¸ªæŒæ¡ï¼Œä¸»è¦æ¶‰åŠæ™ºèƒ½æŒ‡é’ˆå’ŒC++çš„å¸¸ç”¨ç‰¹æ€§ï¼ˆdynamic_castã€std::moveã€å¹¶å‘ä¸é”ç­‰ï¼‰ã€‚\nTask1 - Copy-On-Write Trie å¦‚æœåšè¿‡åŠ›æ‰£ä¸Šçš„208. å®ç° Trie (å‰ç¼€æ ‘)ï¼Œå®ç°Getå’ŒPutè¿™ä¸¤ä¸ªæ“ä½œä¼šæ›´å®¹æ˜“ã€‚è™½ç„¶è¿™ä¸ªtaskè¦æ±‚æˆ‘ä»¬è¦ä½¿ç”¨COWï¼Œä½†æ˜¯æ€»ä½“çš„æ€è·¯æ˜¯å·®ä¸å¤šçš„ã€‚\nGet è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼Œé¡ºåºéå†keyå»æ‰¾èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å°±è¡Œã€‚å€¼å¾—æ³¨æ„çš„æ˜¯æœ‰å€¼èŠ‚ç‚¹çš„ç±»å‹ä¸ºTrieNodeWithValueï¼Œå…¶ç»§æ‰¿è‡ªTrieNodeã€‚å½“éå†ç©keyå¹¶æ‰¾åˆ°èŠ‚ç‚¹åï¼Œä½¿ç”¨dynamic_castå°†å…¶è½¬æ¢ä¸ºTrieNodeWithValue*ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹ä¸æ˜¯ä¸€ä¸ªæœ‰å€¼çš„èŠ‚ç‚¹ï¼Œåˆ™dynamic_castä¼šè½¬æ¢å¤±è´¥è¿”å›nullptrï¼Œå¦åˆ™ä¼šè¿”å›è½¬æ¢åçš„æŒ‡é’ˆï¼Œé€šè¿‡è¿™ä¸ªæŒ‡é’ˆè·å–æœ€ç»ˆçš„å€¼å³å¯ã€‚\nPut Putçš„åŸºæœ¬æ€è·¯å°±æ˜¯éå†keyçš„åŒæ—¶åˆ›å»ºç›¸åº”çš„èŠ‚ç‚¹ï¼Œéš¾ç‚¹åœ¨äºå¦‚ä½•å®ç°â€œcopy on writeâ€ã€‚\nçœ‹å®˜ç½‘çš„æè¿°ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯åœ¨éœ€è¦ä¿®æ”¹Trieæ ‘ï¼ˆä¾‹å¦‚è¿›è¡ŒPutæ“ä½œæˆ–è€…Removeæ“ä½œï¼‰æ—¶ï¼Œéœ€è¦è¿”å›ä¸€é¢—æ–°çš„Trieæ ‘ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å½“å‰çš„æ“ä½œä¸èƒ½å½±å“ä¹‹å‰çš„Trieæ ‘çš„ç»“æ„ï¼Œè¿™å°±éœ€è¦ä½¿ç”¨åˆ°TrieNode::Clone()å‡½æ•°æ¥æ‹·è´ä¸€ä»½éœ€è¦ä¿®æ”¹çš„èŠ‚ç‚¹ï¼Œè¿™æ ·æ‰ä¸ä¼šå½±å“ä¹‹å‰Trieæ ‘ä¸­çš„èŠ‚ç‚¹ã€‚åŒæ—¶ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å°½å¯èƒ½åœ°ä½¿ç”¨å·²æœ‰èŠ‚ç‚¹ï¼Œä¸¾ä¸ªğŸŒ°ï¼š\nåªéœ€è®°ä½ï¼š\næœ¬æ¬¡çš„æ’å…¥æˆ–åˆ é™¤æ“ä½œä¸ä¼šå½±å“ä¸Šæ¬¡çš„Trieæ ‘çš„ç»“æ„ï¼Œä¾‹å¦‚ä¸Šå›¾å¦‚æœæˆ‘ä½¿ç”¨rootæ¥è®¿é—®è¿˜æ˜¯åŸæ¥çš„ç»“æ„ï¼Œè€Œç”¨new rootæ¥è®¿é—®å°±å¯ä»¥è®¿é—®keyå€¼ä¸ºâ€œadâ€çš„èŠ‚ç‚¹çš„å€¼ï¼› å°½å¯èƒ½åˆ©ç”¨å·²æœ‰çš„èŠ‚ç‚¹ï¼Œä¸Šå›¾æˆ‘ä»¬ä¸ºäº†ä¸å½±å“ä¹‹å‰çš„Trieæ ‘ï¼Œæˆ‘ä»¬å¿…é¡»æ‹·è´æ ¹èŠ‚ç‚¹ä¸‹â€œaâ€è·¯å¾„çš„å­èŠ‚ç‚¹ï¼Œæ’å…¥ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ä¹Ÿéœ€è¦åˆ›å»ºï¼Œä½†æ˜¯å€¼ä¸ºâ€œ233â€å’Œâ€œC++â€çš„èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ã€‚ Remove ä¸Putä¸åŒï¼Œæˆ‘ä½¿ç”¨é€’å½’æ¥è¿›è¡Œåˆ é™¤ï¼Œè¿™æ˜¯å› ä¸ºPutå¯ä»¥é¡ºåºéå†keyå€¼å¹¶ä¸æ–­å‘ä¸‹æ·»åŠ èŠ‚ç‚¹ï¼Œè€ŒRemoveéœ€è¦ä»è¦åˆ é™¤çš„èŠ‚ç‚¹ä¸æ–­å‘ä¸Šè¿›è¡Œåˆ é™¤ã€‚\nåˆ é™¤ä¸åˆæ³•çš„æƒ…å†µæœ‰ï¼š\nç¢°åˆ°ç©ºèŠ‚ç‚¹ æ— æ³•å†ç»§ç»­å¾€ä¸‹æŸ¥æ‰¾keyï¼ˆkeyä¸å­˜åœ¨ï¼‰ è¿™æ—¶æŒ‰ç…§ä»»åŠ¡è¦æ±‚åº”è¯¥è¿”å›åŸæ¥çš„Trieæ ‘ã€‚\nTask2 - Concurrent Key-Value Store Get åŠ é”è·å–root_ï¼Œç„¶åè°ƒç”¨ä¹‹å‰å†Task1ä¸­å®ç°çš„Getæ“ä½œè·å–keyå¯¹åº”çš„valueï¼Œå¦‚æœvalueä¸ä¸ºnullptrï¼Œåˆ™å°†rootå’Œvalueå°è£…ä¸ºValueGuardã€‚\nPutã€Remove è¿™ä¸¤ä¸ªæ“ä½œçš„é€»è¾‘ç›¸åŒã€‚ç”±äºä¹‹å‰æˆ‘ä»¬å®ç°Trieçš„ä¸‰ä¸ªæ“ä½œæ—¶ç”¨åˆ°äº†COWï¼Œå› æ­¤æ¯æ¬¡Putã€Removeæ—¶è¿”å›çš„éƒ½æ˜¯ä¸€ä¸ªæ–°çš„Trieï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨Task2ä¸­çš„æ“ä½œä¸­è¦ç”¨å…¨ç¨‹è·å–å†™é”ï¼ˆensure there is only one writer at a timeï¼‰ï¼Œç„¶åä½¿ç”¨Put or Removeè·å–æ–°çš„Trieï¼Œæ¥ç€è·å–root_lock_ï¼Œæœ€åç”¨è·å–çš„æ–°çš„Trieæ›´æ–°root_ã€‚\nTask3 - Debugging è¿™ä¸ªæ²¡ä»€ä¹ˆå¤ªå¤šéœ€è¦è¯´æ˜çš„ã€‚é€‰æ‹©Clionæˆ–VSCodeé…ç½®å¥½ç¯å¢ƒæ‰“æ–­ç‚¹Debugå°±è¡Œï¼Œå½“ç„¶ä½¿ç”¨printå¤§æ³•ä¹Ÿæ˜¯å¯ä»¥çš„hahaã€‚æ³¨æ„è¿™ä¸ªtaskè™½ç„¶æœ‰ç»™ä½ å•å…ƒæµ‹è¯•æ–‡ä»¶ï¼Œä½†æ˜¯è¿è¡Œè‚¯å®šæ˜¯ä¸é€šè¿‡ï¼Œå› ä¸ºé—®é¢˜ç­”æ¡ˆå¹¶ä¸åœ¨æºç ä¸­ï¼Œæˆ‘ä»¬åªèƒ½åœ¨gradescopeæ‰èƒ½æ£€æµ‹è‡ªå·±åšçš„æ˜¯å¦æ­£ç¡®ã€‚\nï¼ˆæˆ‘æ‰€åšçš„projectæ‰€å±è¯¾ç¨‹æ˜¯fall2023ç‰ˆæœ¬ï¼Œå¦‚æœæ˜¯spring2023ç‰ˆæœ¬ï¼Œtask3åœ¨æœ¬åœ°æµ‹è¯•å’Œgradescopeä¸Šçš„æµ‹è¯•å¯èƒ½ä¼šæœ‰åŒºåˆ«ï¼Œæ˜¯éšæœºæ•°çš„é—®é¢˜ï¼Œç›¸å…³è€å¸ˆæœ‰åœ¨Discordä¸Šè¯´æ˜ï¼‰\nTask4 - SQL String Functions è¿™ä¸ªtaskéœ€è¦æˆ‘ä»¬ä¸ºBusTubå®ç°ä¸¤ä¸ªç®€å•çš„å‡½æ•°ï¼šlowerå’Œupperã€‚å®ç°å¹¶ä¸éš¾ï¼Œæ‰¾åˆ°éœ€è¦ä¿®æ”¹çš„ä½ç½®ï¼Œæ·»åŠ ç›¸å…³å¤„ç†é€»è¾‘å’Œå¼‚å¸¸æ“ä½œã€‚\nå®Œæˆè¿™ä¸ªtaskæˆ‘è®¤ä¸ºéœ€è¦å¯¹string_expression.hè¿™ä¸ªæ–‡ä»¶çš„å†…å®¹æœ‰ä¸€å®šç†è§£ï¼Œè¦æ˜ç™½å¦‚ä½•åˆ¤æ–­è·å–çš„æ“ä½œæ˜¯lowerè¿˜æ˜¯upperï¼Œè¿˜æœ‰åœ¨plan_func_call.cppä¸­å¤„ç†éæ³•æ“ä½œã€‚æ€»ä½“æ¥è¯´ä¸éš¾ã€‚\næäº¤ æœ¬åœ°è·‘äº†æµ‹è¯•ä»£ç è¿˜ä¸å¤Ÿï¼Œè¯¾ç¨‹æœ‰ä¸ºæˆ‘ä»¬è¿™äº›éCMUçš„å­¦ç”Ÿå‡†å¤‡æ£€æµ‹å¹³å°gradescopeï¼Œå¦‚ä½•åŠ å…¥è¯¾ç¨‹å¯ä»¥çœ‹è¿™é‡Œã€‚\nåœ¨æäº¤ä¹‹å‰ï¼Œéœ€è¦ä½¿ç”¨è¿›è¡Œclang-tidyæ£€æµ‹ï¼Œå¹¶é€šè¿‡python3 gradescope_sign.pyç”Ÿæˆç­¾åï¼Œè¿™æ ·æ‰èƒ½é€šè¿‡å¹³å°çš„é¢„æ£€æµ‹ã€‚\nè¿™é‡Œè´´ä¸€ä¸ªé€šå…³çš„æˆªå›¾hhï¼š\næ€»ç»“ è¿™ä¸ªproject0æˆ‘ä¹Ÿæ˜¯åšäº†ä¸¤ä¸‰å¤©ï¼ˆè¿˜æ˜¯å¤ªèœäº†ï¼‰ï¼Œåœ¨å…¶ä¸­æˆ‘æ›´å¥½åœ°å·©å›ºäº†C++ä¸­çš„ä¸€äº›çŸ¥è¯†ï¼Œä¾‹å¦‚æ™ºèƒ½æŒ‡é’ˆã€ç§»åŠ¨èµ‹å€¼ã€dynamic_castã€‚ä¸ä¹‹å‰åšXv6çš„Labä¸åŒï¼Œè¿™æ¬¡çš„CMU15-445åœ¨ç½‘ä¸ŠåŸºæœ¬æ²¡æœ‰å…³äºå®ç°çš„æºä»£ç ï¼Œè¿™å°±è®©æˆ‘æ— æ³•ç›´æ¥é€šè¿‡ä»£ç æ¥å­¦ä¹ äº†ã€‚å½“ç„¶è¿™æ˜¯è¯¾ç¨‹çš„è¦æ±‚ï¼Œå¸Œæœ›æˆ‘ä»¬èƒ½ä¸€èµ·æ„å»ºä¸€ä¸ªè‰¯å¥½çš„å­¦ä¹ æ°›å›´ï¼Œé¼“åŠ±æˆ‘ä»¬ç‹¬ç«‹æ€è€ƒå®Œæˆï¼Œä¸ä»–äººäº¤æµè€Œä¸æ˜¯ç›´æ¥è¦ä»£ç ï¼Œæˆ‘è§‰å¾—è¿™æ˜¯ä¸€ä¸ªå¾ˆé”»ç‚¼è‡ªå·±çš„è¿‡ç¨‹ï¼Œç½‘ä¸Šå¤§å¤šæ˜¯ä¸€äº›æ€è·¯çš„ä»‹ç»ï¼ˆæˆ‘å†™çš„è¿™ç¯‡åšå®¢ä¹Ÿæ˜¯è‡ªå·±å®ç°çš„ç®€å•æ€è·¯ï¼Œå¸Œæœ›æ²¡æœ‰è¿åè¯¾ç¨‹çš„è¦æ±‚ï¼‰ï¼Œæˆ‘ä»¬åœ¨æ²¡æ€è·¯æ—¶å‚è€ƒä¸€ä¸‹è¿™äº›åšå®¢ï¼Œç„¶åå†é€šè¿‡è‡ªå·±æ¥å®Œæˆä»£ç ï¼Œè¿™æ¯”ç›´æ¥çœ‹åˆ«äººå†™å¥½çš„ä»£ç æ¥è¯´æ›´èƒ½å¤Ÿæå‡è‡ªå·±ï¼å¸Œæœ›æˆ‘èƒ½æŠŠæ¥ä¸‹æ¥çš„å‡ ä¸ªprojectéƒ½å®Œæˆï¼Œå°½é‡ä¸çƒ‚å°¾ï¼\n","permalink":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project0-c++-primer-%E5%B0%8F%E7%BB%93/","summary":"\u003cblockquote\u003e\n\u003cp\u003eè¯¥ç³»åˆ—åšå®¢åªæ˜¯ä¸ºäº†è®°å½•è‡ªå·±åœ¨å†™Labæ—¶çš„æ€è·¯ï¼ŒæŒ‰ç…§è¯¾ç¨‹è¦æ±‚ä¸ä¼šåœ¨Githubå’Œåšå®¢ä¸­å…¬å¼€æºä»£ç ã€‚æ¬¢è¿ä¸æˆ‘ä¸€èµ·è®¨è®ºäº¤æµï¼\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eproject0åªåœ¨task4ä¸­æµ…æµ…æ¶‰åŠäº†ä¸€ç‚¹BusTubçš„å†…å®¹ï¼Œå…¶ä»–éƒ½æ˜¯æ£€æµ‹æˆ‘ä»¬å¯¹äºC++çš„ä¸€ä¸ªæŒæ¡ï¼Œä¸»è¦æ¶‰åŠæ™ºèƒ½æŒ‡é’ˆå’ŒC++çš„å¸¸ç”¨ç‰¹æ€§ï¼ˆdynamic_castã€std::moveã€å¹¶å‘ä¸é”ç­‰ï¼‰ã€‚\u003c/p\u003e","title":"ã€CMU15-445 Fall2023ã€‘Project0 C++ Primer å°ç»“"},{"content":" ã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†ä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶å’Œä»£ç éšæƒ³å½•ä¸­çš„æ–‡æ¡£ã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\nhookå‡½æ•°çš„å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼šGithub: src/hook.cpp\nè¯¥åç¨‹åº“æ¡†æ¶çš„ç›®æ ‡å¹¶ä¸æ˜¯åšæˆç±»ä¼¼goroutineé‚£æ ·ï¼Œè€Œæ˜¯å¸Œæœ›èƒ½å¤Ÿé€šè¿‡åç¨‹æ¥æé«˜IOå¤„ç†çš„æ•ˆç‡ã€‚å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªæ–‡ä»¶æè¿°ç¬¦fdï¼Œæˆ‘ä»¬éƒ½å¸Œæœ›å®ƒæœ‰ä¸€ä¸ªè¯»å†™IOçš„è¶…æ—¶æ—¶é—´ã€‚\nhookçš„ç›®çš„æ˜¯åœ¨ä¸é‡æ–°ç¼–å†™ä»£ç çš„æƒ…å†µä¸‹ï¼ŒæŠŠè€ä»£ç ä¸­çš„socket IOç›¸å…³çš„APIéƒ½è½¬æˆå¼‚æ­¥ï¼Œä»¥æé«˜æ€§èƒ½ã€‚\néœ€è¦Hookçš„å‡ ç±»å‡½æ•° åœ¨sylarçš„è®¾è®¡ä¸­ï¼Œåªé’ˆå¯¹socket fdè¿›è¡Œhookï¼ˆå› ä¸ºæˆ‘ä»¬æ›´å…³å¿ƒçš„æ˜¯ç½‘ç»œIOï¼‰ï¼Œä¹Ÿå°±æ˜¯å¦‚æœæˆ‘ä»¬æ“ä½œçš„ä¸æ˜¯socket fdï¼Œé‚£ä¹ˆå°±ä¼šä½¿ç”¨åŸæ¥çš„APIã€‚\nsylarå¯¹å¦‚ä¸‹ä¸‰ç±»å‡½æ•°è¿›è¡Œäº†hookï¼š\nsleepå»¶æ—¶ç³»åˆ—æ¥å£ï¼šåŒ…æ‹¬sleep/usleep/nanosleepã€‚å¯¹äºè¿™äº›æ¥å£çš„hookï¼Œåªéœ€è¦ç»™IOåç¨‹è°ƒåº¦å™¨æ³¨å†Œä¸€ä¸ªå®šæ—¶äº‹ä»¶ï¼Œåœ¨å®šæ—¶äº‹ä»¶è§¦å‘åå†ç»§ç»­æ‰§è¡Œå½“å‰åç¨‹å³å¯ã€‚å½“å‰åç¨‹åœ¨æ³¨å†Œå®Œå®šæ—¶äº‹ä»¶åå³å¯yieldè®©å‡ºæ‰§è¡Œæƒ socket IOç³»åˆ—æ¥å£ï¼šåŒ…æ‹¬read/write/recv/send\u0026hellip;ç­‰ï¼ŒconnectåŠacceptä¹Ÿå¯ä»¥å½’åˆ°è¿™ç±»æ¥å£ä¸­ã€‚è¿™ç±»æ¥å£çš„hooké¦–å…ˆéœ€è¦åˆ¤æ–­æ“ä½œçš„fdæ˜¯å¦æ˜¯socket fdï¼Œä»¥åŠç”¨æˆ·æ˜¯å¦æ˜¾å¼åœ°å¯¹è¯¥fdè®¾ç½®è¿‡éé˜»å¡æ¨¡å¼ï¼Œå¦‚æœä¸æ˜¯socket fdæˆ–æ˜¯ç”¨æˆ·æ˜¾å¼è®¾ç½®è¿‡éé˜»å¡æ¨¡å¼ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦hookäº†ï¼Œç›´æ¥è°ƒç”¨æ“ä½œç³»ç»Ÿçš„IOæ¥å£å³å¯ã€‚å¦‚æœéœ€è¦hookï¼Œé‚£ä¹ˆé¦–å…ˆåœ¨IOåç¨‹è°ƒåº¦å™¨ä¸Šæ³¨å†Œå¯¹åº”çš„è¯»å†™äº‹ä»¶ï¼Œç­‰äº‹ä»¶å‘ç”Ÿåå†ç»§ç»­æ‰§è¡Œå½“å‰åç¨‹ã€‚å½“å‰åç¨‹åœ¨æ³¨å†Œå®ŒIOäº‹ä»¶å³å¯yieldè®©å‡ºæ‰§è¡Œæƒã€‚ socket/fcntl/ioctl/closeç­‰æ¥å£ï¼šè¿™ç±»æ¥å£ä¸»è¦å¤„ç†çš„æ˜¯è¾¹ç¼˜æƒ…å†µï¼Œæ¯”å¦‚åˆ†é…fdä¸Šä¸‹æ–‡ï¼Œå¤„ç†è¶…æ—¶åŠç”¨æˆ·æ˜¾å¼è®¾ç½®éé˜»å¡é—®é¢˜ã€‚ Hookçš„å®ç° æˆ‘ä»¬hookçš„æ‰€æœ‰å‡½æ•°ï¼Œéƒ½è¦ä¸åŸæ¥çš„APIçš„è¡Œä¸ºä¿æŒä¸€è‡´ï¼ˆä½¿ç”¨è¿™äº›hook apiçš„æ—¶å€™å°±å¥½åƒä½¿ç”¨çš„åŸæ¥çš„apiï¼‰ã€‚ä¾‹å¦‚åŸæ¥çš„APIçš„è¿”å›å€¼é€šå¸¸ç”¨0è¡¨ç¤ºæˆåŠŸï¼Œ-1è¡¨ç¤ºå¤±è´¥\nåœ¨ Sylar ä¸­ï¼ŒHook çš„å®ç°é€šå¸¸æ¶‰åŠä»¥ä¸‹å‡ ä¸ªå…³é”®æ–¹é¢ï¼š\nä¸€ã€å‡½æ•°æŒ‡é’ˆæ›¿æ¢\nä¿å­˜åŸå§‹å‡½æ•°æŒ‡é’ˆï¼šé¦–å…ˆï¼Œéœ€è¦ä¿å­˜è¢« Hook å‡½æ•°çš„åŸå§‹å®ç°çš„å‡½æ•°æŒ‡é’ˆã€‚è¿™å¯ä»¥é€šè¿‡åœ¨ç¨‹åºå¯åŠ¨æ—¶æˆ–è€…åœ¨é¦–æ¬¡éœ€è¦ Hook çš„æ—¶å€™ï¼Œè·å–åŸå§‹å‡½æ•°çš„åœ°å€å¹¶å­˜å‚¨èµ·æ¥ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªä¸è¢« Hook å‡½æ•°å…·æœ‰ç›¸åŒç­¾åçš„å‡½æ•°æŒ‡é’ˆå˜é‡ï¼Œå¹¶å°†å…¶åˆå§‹åŒ–ä¸ºæŒ‡å‘åŸå§‹å‡½æ•°çš„åœ°å€ã€‚ æ›¿æ¢å‡½æ•°æŒ‡é’ˆï¼šç„¶åï¼Œå°†è¢« Hook å‡½æ•°çš„å…¥å£åœ°å€æ›¿æ¢ä¸ºè‡ªå®šä¹‰çš„ Hook å‡½æ•°çš„åœ°å€ã€‚è¿™æ ·ï¼Œå½“ç¨‹åºè°ƒç”¨è¢« Hook å‡½æ•°æ—¶ï¼Œå®é™…ä¸Šä¼šæ‰§è¡Œ Hook å‡½æ•°ã€‚ äºŒã€å‚æ•°ä¼ é€’å’Œè¿”å›å€¼å¤„ç†\nå‚æ•°ä¼ é€’ï¼šåœ¨ Hook å‡½æ•°ä¸­ï¼Œéœ€è¦æ¥æ”¶ä¸è¢« Hook å‡½æ•°ç›¸åŒçš„å‚æ•°ã€‚è¿™å¯ä»¥é€šè¿‡å°†å‚æ•°ç›´æ¥ä¼ é€’ç»™ Hook å‡½æ•°ï¼Œæˆ–è€…ä½¿ç”¨ä¸€äº›æŠ€æœ¯ï¼ˆå¦‚å‡½æ•°è°ƒç”¨æ ˆçš„åˆ†æï¼‰æ¥è·å–å‚æ•°çš„å€¼ã€‚å¦‚æœè¢« Hook å‡½æ•°æ˜¯Â int func(int a, char* b)ï¼Œé‚£ä¹ˆ Hook å‡½æ•°ä¹Ÿåº”è¯¥å…·æœ‰ç›¸åŒçš„å‚æ•°åˆ—è¡¨Â int hook_func(int a, char* b)ã€‚ è¿”å›å€¼å¤„ç†ï¼šHook å‡½æ•°éœ€è¦æ ¹æ®éœ€è¦å¤„ç†è¢« Hook å‡½æ•°çš„è¿”å›å€¼ã€‚å¯ä»¥é€‰æ‹©ç›´æ¥è¿”å›è¢« Hook å‡½æ•°çš„åŸå§‹è¿”å›å€¼ï¼Œæˆ–è€…æ ¹æ®ç‰¹å®šçš„é€»è¾‘ä¿®æ”¹è¿”å›å€¼åå†è¿”å›ã€‚ ä¸‰ã€æ¡ä»¶åˆ¤æ–­å’Œæ§åˆ¶\nHook å¯ç”¨ / ç¦ç”¨ï¼šé€šå¸¸ä¼šæä¾›ä¸€ç§æœºåˆ¶æ¥å¯ç”¨æˆ–ç¦ç”¨ Hook åŠŸèƒ½ã€‚è¿™å¯ä»¥é€šè¿‡ä¸€ä¸ªå…¨å±€å˜é‡ã€é…ç½®æ–‡ä»¶æˆ–è€…è¿è¡Œæ—¶å‚æ•°æ¥æ§åˆ¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä»£ç ä¸­å®šä¹‰ä¸€ä¸ªå¸ƒå°”å˜é‡ï¼Œå¦‚Â bool hook_enableï¼Œå½“å®ƒä¸ºçœŸæ—¶å¯ç”¨ Hook åŠŸèƒ½ï¼Œä¸ºå‡æ—¶ç›´æ¥è°ƒç”¨åŸå§‹å‡½æ•°è€Œä¸æ‰§è¡Œ Hook å‡½æ•°ã€‚ ç‰¹å®šæ¡ä»¶ä¸‹çš„ Hookï¼šå¯ä»¥æ ¹æ®ç‰¹å®šçš„æ¡ä»¶æ¥å†³å®šæ˜¯å¦æ‰§è¡Œ Hook å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æ£€æŸ¥å‚æ•°çš„å€¼ã€å‡½æ•°çš„è°ƒç”¨è€…ã€å½“å‰çš„è¿è¡Œç¯å¢ƒç­‰æ¡ä»¶ï¼Œåªæœ‰åœ¨æ»¡è¶³ç‰¹å®šæ¡ä»¶æ—¶æ‰æ‰§è¡Œ Hook å‡½æ•°ã€‚ FdManager æˆ‘ä»¬ä¼šé€šè¿‡FdContextç±»ï¼ˆæ³¨æ„ä¸IOManagerä¸­çš„FdContextè¿›è¡ŒåŒºåˆ†ï¼‰æ¥ä¿å­˜fdçš„ä¸€äº›çŠ¶æ€ï¼Œä¾‹å¦‚fdæ˜¯å¦å…³é—­äº†ï¼Œæ˜¯å¦è®¾ç½®ä¸ºéé˜»å¡ï¼Œå…¶è¯»å†™äº‹ä»¶è¶…æ—¶æ—¶é—´æ˜¯å¤šå°‘ç­‰ã€‚\nsleep API å¯¹sleepï¼Œusleepï¼Œnanosleepä¸‰ä¸ªå‡½æ•°è¿›è¡Œhookæ“ä½œï¼Œå…¶é€»è¾‘ä¸€è‡´ï¼šsleepç±»å‡½æ•°ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æ”¹é€ æ–¹æ³•å°±æ˜¯ç”¨ä¸€ä¸ªå®šæ—¶å™¨æ¥ä»£æ›¿sleepçš„ä¼‘çœ é˜»å¡ï¼Œè·å–å½“å‰è¿è¡Œçš„åç¨‹ï¼Œç„¶åé€šè¿‡IOManageræ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨ï¼Œè§„å®šæ—¶é—´åå†å°†è¿™ä¸ªåç¨‹åŠ å…¥è°ƒåº¦ï¼Œä¹‹åyieldè¿™ä¸ªåç¨‹ã€‚\nsocket API socketï¼šå½“ä½¿ç”¨socketåˆ›å»ºå¥—æ¥å­—fdæ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒåŠ å…¥åˆ°FdManagerä¸­ã€‚ connectï¼šå¯¹äºåŸå§‹çš„connectï¼Œå®ƒæ˜¯ä¸€ä¸ªé˜»å¡è°ƒç”¨ï¼Œç›´åˆ°è¿æ¥æˆåŠŸæˆ–å‘ç”Ÿé”™è¯¯ï¼Œå¦‚æœç½‘ç»œå»¶è¿Ÿè¾ƒé«˜æˆ–ç›®æ ‡ä¸»æœºä¸å¯è¾¾ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç¨‹åºé•¿æ—¶é—´æŒ‚èµ·ã€‚æˆ‘ä»¬éœ€è¦å°†å…¶æ”¹é€ ä¸ºä¸å¼‚æ­¥æˆ–éé˜»å¡æ“ä½œç»“åˆã€‚å¯¹åº”çš„å®ç°æ–¹æ³•å°±æ˜¯é€šè¿‡è®¾ç½®ä¸€ä¸ªè¶…æ—¶æ—¶é—´ï¼Œåˆ°æ—¶é—´åå–æ¶ˆæ–‡ä»¶æè¿°ç¬¦çš„å†™äº‹ä»¶ã€‚ä¸ºsocket fdæ·»åŠ å†™äº‹ä»¶åï¼Œå¦‚æœæ·»åŠ æˆåŠŸï¼Œåˆ™yieldå½“å‰åç¨‹ï¼Œå¹¶å–æ¶ˆå®šæ—¶å™¨ setsockoptï¼šå¯¹äºoptnameä¸ºSO_RCVTIMEOå’ŒSO_RCVTIMEOçš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦è®¾ç½®sockfdå¯¹åº”çš„è¶…æ—¶æ—¶é—´ã€‚ socket IO API acceptã€readã€readvã€recvã€recvfromã€recvmsgã€writeã€writevã€sendã€sendtoã€sendmsgè¿™äº›å‡½æ•°æ‰€è¦ä½œçš„hookæ“ä½œéƒ½å¾ˆç±»ä¼¼ï¼Œä¸åŒçš„åœ°æ–¹æ— éå°±æ˜¯è¯»å†™äº‹ä»¶çš„ä¸åŒï¼Œå…¶å¤„ç†é€»è¾‘å’Œconnectç›¸ä¼¼ï¼Œæ‰€ä»¥åˆ©ç”¨äº†æ¨¡æ¿æ¥å‡å°‘å†—ä½™ä»£ç ã€‚\nother API è¿˜æœ‰ç±»ä¼¼closeã€ioctlã€fcntlçš„å‡½æ•°ï¼Œç”±äºæˆ‘ä»¬åœ¨ä¹‹å‰hook apiæ—¶å¤„ç†äº†æ–‡ä»¶æè¿°ç¬¦ï¼Œå› æ­¤åœ¨è¿™äº›å‡½æ•°ä¸­æˆ‘ä»¬éœ€è¦å¯¹æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œæ¸…ç†æˆ–å…¶ä»–æ“ä½œã€‚\n","permalink":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/","summary":"\u003cblockquote\u003e\n\u003cp\u003eã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†\u003ca href=\"https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952\"\u003eä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶\u003c/a\u003eå’Œä»£ç éšæƒ³å½•ä¸­çš„\u003ca href=\"https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\"\u003eæ–‡æ¡£\u003c/a\u003eã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\u003c/p\u003e\n\u003cp\u003ehookå‡½æ•°çš„å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\u003ca href=\"https://github.com/kerolt/coroutine-lib/blob/master/src/hook.cpp\"\u003eGithub: src/hook.cpp\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eè¯¥åç¨‹åº“æ¡†æ¶çš„ç›®æ ‡å¹¶ä¸æ˜¯åšæˆç±»ä¼¼goroutineé‚£æ ·ï¼Œè€Œæ˜¯å¸Œæœ›èƒ½å¤Ÿé€šè¿‡åç¨‹æ¥æé«˜IOå¤„ç†çš„æ•ˆç‡ã€‚å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªæ–‡ä»¶æè¿°ç¬¦fdï¼Œæˆ‘ä»¬éƒ½å¸Œæœ›å®ƒæœ‰ä¸€ä¸ªè¯»å†™IOçš„è¶…æ—¶æ—¶é—´ã€‚\u003c/p\u003e\n\u003cp\u003ehookçš„ç›®çš„æ˜¯åœ¨ä¸é‡æ–°ç¼–å†™ä»£ç çš„æƒ…å†µä¸‹ï¼ŒæŠŠè€ä»£ç ä¸­çš„socket IOç›¸å…³çš„APIéƒ½\u003cstrong\u003eè½¬æˆå¼‚æ­¥\u003c/strong\u003eï¼Œä»¥æé«˜æ€§èƒ½ã€‚\u003c/p\u003e","title":"ã€åŠ¨æ‰‹å†™åç¨‹åº“ 5ã€‘å¸¸ç”¨IOå‡½æ•°çš„HOOKåŠŸèƒ½"},{"content":" ã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†ä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶å’Œä»£ç éšæƒ³å½•ä¸­çš„æ–‡æ¡£ã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\nIOManagerç±»ä¸­å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼šGithub: src/iomanager.cpp\nä¹‹å‰å®ç°çš„åç¨‹è°ƒåº¦å™¨çš„åŠŸèƒ½å…¶å®éå¸¸ç®€å•ï¼Œå½“æ·»åŠ ä»»åŠ¡åè°ƒåº¦å™¨åªæ˜¯å•çº¯çš„ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡äº¤ç»™åç¨‹å»æ‰§è¡Œã€‚sylarçš„åç¨‹åº“çš„å…³æ³¨å¯¹è±¡æ˜¯ç½‘ç»œIOï¼Œå¦‚æœé‡‡ç”¨è¿™ä¹ˆç®€å•çš„è°ƒåº¦å°±æ ¹æœ¬æ²¡æœ‰ç”¨åˆ°åç¨‹çš„ç²¾é«“ã€‚\nsylarçš„IOåç¨‹è°ƒåº¦è§£å†³äº†ä¹‹å‰è°ƒåº¦å™¨åœ¨idleçŠ¶æ€ä¸‹å¿™ç­‰å¾…å¯¼è‡´CPUå ç”¨ç‡é«˜çš„é—®é¢˜ã€‚IOåç¨‹è°ƒåº¦å™¨ä½¿ç”¨ä¸€å¯¹ç®¡é“fdæ¥tickleè°ƒåº¦åç¨‹ï¼Œå½“è°ƒåº¦å™¨ç©ºé—²æ—¶ï¼Œidleåç¨‹é€šè¿‡epoll_waité˜»å¡åœ¨ç®¡é“çš„è¯»æè¿°ç¬¦ä¸Šï¼Œç­‰ç®¡é“çš„å¯è¯»äº‹ä»¶ã€‚æ·»åŠ æ–°ä»»åŠ¡æ—¶ï¼Œtickleæ–¹æ³•å†™ç®¡é“ï¼Œidleåç¨‹æ£€æµ‹åˆ°ç®¡é“å¯è¯»åé€€å‡ºï¼Œè°ƒåº¦å™¨æ‰§è¡Œè°ƒåº¦ã€‚\nIOManager API IOManagerçš„APIå¦‚ä¸‹ï¼š\n#ifndef IOMANAGER_H_ #define IOMANAGER_H_ #include \u0026lt;cstddef\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;shared_mutex\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;coroutine.h\u0026#34; #include \u0026#34;scheduler.h\u0026#34; #include \u0026#34;timer.h\u0026#34; // äº‹ä»¶ï¼šæ— ã€è¯»ã€å†™ enum Event { NONE = 0x0, READ = EPOLLIN, WRITE = EPOLLOUT, }; // IOåç¨‹è°ƒåº¦ class IOManager : public Scheduler, public TimerManager { public: IOManager(size_t threads = 1, bool use_caller = true, const std::string\u0026amp; name = \u0026#34;IOManager\u0026#34;); ~IOManager(); bool AddEvent(int fd, Event event, std::function\u0026lt;void()\u0026gt; cb = nullptr); bool DelEvent(int fd, Event event); bool CancelEvent(int fd, Event event); bool CancelAllEvent(int fd); static IOManager* GetIOManager(); protected: void Idle() override; void Tickle() override; void OnTimerInsertAtFront() override; bool IsStop() override; void ResizeContexts(size_t size); private: // socket fd ä¸Šä¸‹æ–‡ struct FdContext { struct EventContext { Scheduler* scheduler = nullptr; Coroutine::Ptr coroutine; std::function\u0026lt;void()\u0026gt; callback; }; // æ ¹æ®ç±»å‹è·å–å¯¹åº”çš„ä¸Šä¸‹æ–‡ EventContext\u0026amp; GetEventContext(Event\u0026amp; e); void ResetEventContext(EventContext\u0026amp; ectx); void TriggerEvent(Event e); EventContext read_ctx, write_ctx; int fd; Event events = Event::NONE; std::mutex mutex; }; private: int epfd_; int tickle_fd_[2]; std::atomic_size_t pending_evt_cnt_; std::mutex mutex_; std::shared_mutex rw_mutex_; // åˆ©ç”¨fdä½œä¸ºä¸‹æ ‡æ¥è·å–å¯¹åº”çš„FdContext*ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨ä»£æ›¿ std::vector\u0026lt;FdContext*\u0026gt; fd_contexts_; }; #endif /* IOMANAGER_H_ */ Scheduler::Run() æˆ‘ä»¬å¯ä»¥å…ˆå›é¡¾ä¸€ä¸‹Scheduler::Run()è¿™ä¸ªå‡½æ•°ï¼š\nvoid Scheduler::Run() { LOG \u0026lt;\u0026lt; \u0026#34;Scheduler running...\\n\u0026#34;; SetHookFlag(true); SetThisAsScheduler(); // å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯è°ƒåº¦å™¨æ‰€åœ¨çº¿ç¨‹ï¼Œè®¾ç½®è°ƒåº¦çš„åç¨‹ä¸ºå½“å‰çº¿ç¨‹è¿è¡Œçš„åç¨‹ if (std::this_thread::get_id() != sched_id_) { sched_coroutine = Coroutine::GetNowCoroutine().get(); } Coroutine::Ptr idle_co = std::make_shared\u0026lt;Coroutine\u0026gt;([this] { this-\u0026gt;Idle(); }); Coroutine::Ptr callback_co; SchedulerTask task; while (true) { task.Reset(); bool tickle = false; { std::lock_guard lock(mutex_); auto iter = tasks_.begin(); while (iter != tasks_.end()) { // å½“å‰éå†çš„taskå·²ç»åˆ†é…äº†çº¿ç¨‹å»æ‰§è¡Œä¸”è¿™ä¸ªçº¿ç¨‹ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œåˆ™ä¸ç”¨ç®¡ if (iter-\u0026gt;thread_id_ \u0026amp;\u0026amp; *iter-\u0026gt;thread_id_ != std::this_thread::get_id()) { ++iter; tickle = true; continue; } if (iter-\u0026gt;coroutine_ \u0026amp;\u0026amp; iter-\u0026gt;coroutine_-\u0026gt;GetState() != Coroutine::READY) { LOG \u0026lt;\u0026lt; \u0026#34;Coroutine task\u0026#39;s state should be READY!\\n\u0026#34;; assert(false); } task = *iter; tasks_.erase(iter++); active_threads_++; break; } // æœ‰ä»»åŠ¡å¯ä»¥å»æ‰§è¡Œï¼Œéœ€è¦tickleä¸€ä¸‹ tickle |= (iter != tasks_.end()); } if (tickle) { Tickle(); } // å­åç¨‹æ‰§è¡Œå®Œæ¯•åyieldä¼šå›åˆ°Run()ä¸­ // æ³¨æ„ï¼Œæ¯æ¬¡è¿è¡Œäº†ä¸€ä¸ªtaskåéœ€è¦Resetä¸€ä¸‹ if (task.coroutine_) { // ä»»åŠ¡ç±»å‹ä¸ºåç¨‹ task.coroutine_-\u0026gt;Resume(); active_threads_--; task.Reset(); } else if (task.callback_) { // ä»»åŠ¡ç±»å‹ä¸ºå›è°ƒå‡½æ•°ï¼Œå°†å…¶åŒ…è£…ä¸ºåç¨‹ if (callback_co) { callback_co-\u0026gt;Reset(task.callback_); } else { callback_co = std::make_shared\u0026lt;Coroutine\u0026gt;(task.callback_); } callback_co-\u0026gt;Resume(); active_threads_--; callback_co.reset(); task.Reset(); } else { // æ— ä»»åŠ¡ï¼Œä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º if (idle_co-\u0026gt;GetState() == Coroutine::FINISH) { LOG \u0026lt;\u0026lt; \u0026#34;Idle coroutine finish\\n\u0026#34;; break; } idle_threads_++; idle_co-\u0026gt;Resume(); // Idleæœ€åYeildæ—¶å›åˆ°è¿™é‡Œ idle_threads_--; } } LOG \u0026lt;\u0026lt; \u0026#34;Scheduler Run() exit\\n\u0026#34;; } è¿™ä¸ªå‡½æ•°å°±æ˜¯æ¯ä¸ªçº¿ç¨‹ä¼šå¯åŠ¨çš„åç¨‹è°ƒåº¦å‡½æ•°ï¼Œè´Ÿè´£ç®¡ç†å’Œæ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼ŒåŒ…æ‹¬åç¨‹å’Œå›è°ƒå‡½æ•°ä¸¤ç§ç±»å‹çš„ä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™æ‰§è¡ŒIdleåç¨‹ã€‚\nåœ¨Scheduler::Idle()å‡½æ•°ä¸­ï¼Œä»…ä»…åªæ˜¯åšäº†ä¸€ä¸ªç®€å•çš„å¤„ç†ï¼šè°ƒåº¦å™¨æ²¡æœ‰åœæ­¢å°±è®©å‡ºå½“å‰æ­£åœ¨æ‰§è¡Œçš„åç¨‹ï¼Œæˆ‘ä»¬è¦åšçš„å¢å¼ºåçš„IOManageréœ€è¦é‡å†™Idleå‡½æ•°ï¼Œè®©å®ƒä¸æ–­ç­‰å¾…äº‹ä»¶ã€å¤„ç†äº‹ä»¶ã€ç„¶åå†æ¬¡ç­‰å¾…äº‹ä»¶çš„å¾ªç¯è¿‡ç¨‹ï¼Œå®ƒåœ¨æ²¡æœ‰å…¶ä»–åç¨‹è¿è¡Œæ—¶ä¿æŒç³»ç»Ÿçš„æ´»è·ƒåº¦ï¼Œå¹¶åœ¨æœ‰äº‹ä»¶å‘ç”Ÿæ—¶è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚\né‡å†™Idleå‡½æ•° åœ¨IOManagerä¸­ï¼Œæˆ‘ä»¬å°±éœ€è¦é‡å†™Idleå‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦å®ƒæ˜¯ä¸€ä¸ªä¸æ–­ç­‰å¾…äº‹ä»¶ã€å¤„ç†äº‹ä»¶ã€ç„¶åå†æ¬¡ç­‰å¾…äº‹ä»¶çš„å¾ªç¯è¿‡ç¨‹ï¼Œå®ƒåœ¨æ²¡æœ‰å…¶ä»–åç¨‹è¿è¡Œæ—¶ä¿æŒç³»ç»Ÿçš„æ´»è·ƒåº¦ï¼Œå¹¶åœ¨æœ‰äº‹ä»¶å‘ç”Ÿæ—¶è¿›è¡Œç›¸åº”çš„å¤„ç†ï¼š\næˆ‘ä»¬ä¼šå…ˆæ‰¾åˆ°æœ€è¿‘ä¸€ä¸ªå®šæ—¶å™¨çš„è¶…æ—¶æ—¶é—´ï¼Œå¹¶å°†å…¶ä¸è‡ªå®šä¹‰æœ€é•¿è¶…æ—¶æ—¶é—´ï¼ˆæºç ä¸­æ˜¯5sï¼‰è¿›è¡Œæ¯”è¾ƒå–æœ€å°è€…ä½œä¸ºepoll_waitçš„è¶…æ—¶æ—¶é—´ å°†è¶…æ—¶çš„å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°åŠ å…¥è°ƒåº¦å™¨ å¤„ç†epoll_waité€æ¥çš„äº‹ä»¶ å°†å½“å‰çº¿ç¨‹è¿è¡Œçš„åç¨‹æš‚åœï¼ˆä¹Ÿå°±æ˜¯æš‚åœIdleåç¨‹ï¼‰ï¼Œå¹¶å°†æ‰§è¡Œæƒäº¤ç»™è°ƒåº¦åç¨‹ï¼ˆScheduler::Run()ï¼‰ ä»1.åˆå¼€å§‹é‡å¤æ‰§è¡Œ å…·ä½“æ“ä½œå¯çœ‹ä»£ç ï¼š\nvoid IOManager::Idle() { LOG \u0026lt;\u0026lt; \u0026#34;idle coroutine start up\\n\u0026#34;; const int MAX_EVENTS = 256; const int MAX_TIMEOUT = 5000; epoll_event events[MAX_EVENTS]{}; while (true) { // LOG \u0026lt;\u0026lt; \u0026#34;in idle now\\n\u0026#34;; if (IsStop()) { LOG \u0026lt;\u0026lt; GetName() \u0026lt;\u0026lt; \u0026#34;idle stop now\\n\u0026#34;; break; } uint64_t next_timeout = GetNextTimerInterval(); int triggered_events; do { // å¦‚æœæ—¶é—´å †ä¸­æœ‰è¶…æ—¶çš„å®šæ—¶å™¨ï¼Œåˆ™æ¯”è¾ƒè¿™ä¸ªè¶…æ—¶å®šæ—¶å™¨çš„ä¸‹ä¸€æ¬¡è§¦å‘çš„æ—¶é—´ä¸MAX_TIMEOUTï¼ˆ5sï¼‰ï¼Œé€‰å–æœ€å°å€¼ä½œä¸ºè¶…æ—¶æ—¶é—´ next_timeout = next_timeout != ~0ull ? std::min(static_cast\u0026lt;int\u0026gt;(next_timeout), MAX_TIMEOUT) : MAX_TIMEOUT; // æ²¡æœ‰äº‹ä»¶åˆ°æ¥æ—¶ä¼šé˜»å¡åœ¨epoll_waitä¸Šï¼Œé™¤éåˆ°äº†è¶…æ—¶æ—¶é—´ triggered_events = epoll_wait(epfd_, events, MAX_EVENTS, static_cast\u0026lt;int\u0026gt;(next_timeout)); if (triggered_events \u0026lt; 0 \u0026amp;\u0026amp; errno == EINTR) { continue; } else { break; } } while (true); // ç”¨while(true)çš„ç›®çš„æ˜¯ç¡®ä¿åœ¨å‡ºç°ç‰¹å®šé”™è¯¯æƒ…å†µæ—¶èƒ½å¤Ÿé‡æ–°å°è¯•æ‰§è¡Œ epoll_wait // å°†è¶…æ—¶çš„å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°åŠ å…¥è°ƒåº¦å™¨ // è¿™äº›å›è°ƒå‡½æ•°çš„ä½œç”¨å¯èƒ½æ˜¯å…³é—­è¿æ¥ç­‰æ“ä½œ std::vector\u0026lt;std::function\u0026lt;void()\u0026gt;\u0026gt; cbs = GetExpiredCbList(); for (auto\u0026amp; cb : cbs) { Sched(cb); } // å¤„ç†äº‹ä»¶ for (int i = 0; i \u0026lt; triggered_events; i++) { epoll_event\u0026amp; event = events[i]; // æ˜¯ä¸€ä¸ªç”¨äºé€šçŸ¥åç¨‹è°ƒåº¦çš„äº‹ä»¶ // epollä¸­ç›‘å¬äº†ç”¨äºé€šçŸ¥çš„ç®¡é“è¯»ç«¯fdï¼Œå½“æœ‰æ•°æ®åˆ°æ—¶å³ä¼šè§¦å‘ if (event.data.fd == tickle_fd_[0]) { char buf[256]{}; // å°†ç®¡é“å†…çš„æ•°æ®è¯»å®Œ while (read(tickle_fd_[0], buf, sizeof(buf)) \u0026gt; 0) ; continue; } // FdContext* fd_ctx = (FdContext*) event.data.ptr; FdContext* fd_ctx = static_cast\u0026lt;FdContext*\u0026gt;(event.data.ptr); std::lock_guard lock(fd_ctx-\u0026gt;mutex); // å‘ç”Ÿé”™è¯¯æ—¶ï¼Œå¦‚æœåŸæ¥çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šä¸‹æ–‡ï¼ˆfd_ctxï¼‰ä¸­æœ‰å¯è¯»æˆ–å¯å†™äº‹ä»¶æ ‡å¿—è¢«è®¾ç½®ï¼Œé‚£ä¹ˆç°åœ¨å°†é‡æ–°è§¦å‘è¿™äº›äº‹ä»¶ if (event.events \u0026amp; (EPOLLERR | EPOLLHUP)) { event.events |= (EPOLLIN | EPOLLOUT) \u0026amp; fd_ctx-\u0026gt;events; } // è·å–fd_ctxå¯¹åº”çš„äº‹ä»¶ int real_event = Event::NONE; if (event.events \u0026amp; EPOLLIN) { real_event |= Event::READ; } if (event.events \u0026amp; EPOLLOUT) { real_event |= Event::WRITE; } if ((fd_ctx-\u0026gt;events \u0026amp; real_event) == Event::NONE) { continue; } // å¦‚æœè¿˜æœ‰å‰©ä½™äº‹ä»¶ï¼Œåˆ™ä¿®æ”¹ï¼›å¦åˆ™å°†å…¶ä»epollä¸­åˆ é™¤ // æ³¨æ„è·å–rest_eventsæ—¶ä¸æ˜¯ä½¿ç”¨çš„event.events \u0026amp; ~real_eventï¼Œå› ä¸ºæ˜¯è¦å»é™¤fd_ctx-\u0026gt;fdä¸­æœ¬æ¬¡è§¦å‘çš„äº‹ä»¶ int rest_events = fd_ctx-\u0026gt;events \u0026amp; ~real_event; int op = rest_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL; event.events = EPOLLET | rest_events; if (epoll_ctl(epfd_, op, fd_ctx-\u0026gt;fd, \u0026amp;event) \u0026lt; 0) { LOG_ERROR \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; continue; } if (real_event \u0026amp; Event::READ) { fd_ctx-\u0026gt;TriggerEvent(Event::READ); --pending_evt_cnt_; } if (real_event \u0026amp; Event::WRITE) { fd_ctx-\u0026gt;TriggerEvent(Event::WRITE); --pending_evt_cnt_; } } // å°†å½“å‰çº¿ç¨‹è¿è¡Œçš„åç¨‹æš‚åœï¼ˆä¹Ÿå°±æ˜¯æš‚åœIdleåç¨‹ï¼‰ï¼Œå¹¶å°†æ‰§è¡Œæƒäº¤ç»™è°ƒåº¦åç¨‹ Coroutine::Ptr co_ptr = Coroutine::GetNowCoroutine(); auto co = co_ptr.get(); co_ptr.reset(); co-\u0026gt;Yield(); } } æ·»åŠ äº‹ä»¶ IOManageré™¤äº†é‡å†™Idleå‡½æ•°è¿™ä¸ªé‡è¦ç‚¹å¤–ï¼Œè¿˜æœ‰ä¸ªé‡è¦ç‚¹å°±æ˜¯ä¸ºæŒ‡å®šæ–‡ä»¶æè¿°ç¬¦æ·»åŠ äº‹ä»¶ã€‚\nIOManagerå†…éƒ¨æœ‰ä¸€ä¸ª[FdContext](#IOManger API)ç»“æ„ä½“ç”¨æ¥å°è£…socket fdçš„ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç»‘å®šçš„å›è°ƒå‡½æ•°ï¼Œå¯¹åº”çš„äº‹ä»¶ã€åç¨‹ï¼‰ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªvectorä¿å­˜è¿™äº›FdContextã€‚\næˆ‘ä»¬åœ¨æ·»åŠ fdçš„äº‹ä»¶æ—¶ï¼Œéœ€è¦å°†å…¶åŠ å…¥vectorä¸­ï¼Œå¹¶ä¸”éœ€è¦é€šè¿‡epoll_ctlæ³¨å†Œfdçš„å¯¹åº”äº‹ä»¶ã€‚\nbool IOManager::AddEvent(int fd, Event event, std::function\u0026lt;void()\u0026gt; cb) { FdContext* fd_ctx = nullptr; { std::shared_lock rw_lock(rw_mutex_); if (fd_contexts_.size() \u0026gt; fd) { fd_ctx = fd_contexts_[fd]; rw_lock.unlock(); } else { rw_lock.unlock(); std::unique_lock rw_lock2(rw_mutex_); ResizeContexts(fd * 1.5); fd_ctx = fd_contexts_[fd]; } } std::lock_guard lock(mutex_); if (fd_ctx-\u0026gt;events \u0026amp; event) { LOG_ERROR \u0026lt;\u0026lt; \u0026#34;A fd can\u0026#39;t add same event\\n\u0026#34;; return false; } int op = fd_ctx-\u0026gt;events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD; epoll_event ep_evt{}; ep_evt.events = static_cast\u0026lt;int\u0026gt;(fd_ctx-\u0026gt;events) | EPOLLET | event; ep_evt.data.ptr = fd_ctx; // åœ¨Idle()ä¸­å°†ä½¿ç”¨fdå¯¹åº”çš„è¿™ä¸ªep_evt int ret = epoll_ctl(epfd_, op, fd, \u0026amp;ep_evt); if (ret) { LOG_ERROR \u0026lt;\u0026lt; \u0026#34;epoll_ctl \u0026#34; \u0026lt;\u0026lt; strerror(errno); return false; } ++pending_evt_cnt_; // è®¾ç½®fdå¯¹åº”äº‹ä»¶çš„EventContext fd_ctx-\u0026gt;events = static_cast\u0026lt;Event\u0026gt;(fd_ctx-\u0026gt;events | event); // ä½¿ç”¨event_ctxç›¸å½“äºä½¿ç”¨fd_ctx-\u0026gt;read_ctx or fd_ctx-\u0026gt;write_ctxï¼ˆæ³¨æ„æ˜¯auto\u0026amp;è€Œä¸æ˜¯autoï¼‰ auto\u0026amp; event_ctx = fd_ctx-\u0026gt;GetEventContext(event); assert(!event_ctx.scheduler \u0026amp;\u0026amp; !event_ctx.callback \u0026amp;\u0026amp; !event_ctx.coroutine); event_ctx.scheduler = Scheduler::GetScheduler(); if (cb) { event_ctx.callback = cb; } else { // è®¾ç½®fdç›¸å…³äº‹ä»¶è§¦å‘æ—¶ä½¿ç”¨çš„åç¨‹ä¸ºå½“å‰ event_ctx.coroutine = Coroutine::GetNowCoroutine(); assert(event_ctx.coroutine-\u0026gt;GetState() == Coroutine::RUNNING); } return true; } ","permalink":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003eã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†\u003ca href=\"https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952\"\u003eä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶\u003c/a\u003eå’Œä»£ç éšæƒ³å½•ä¸­çš„\u003ca href=\"https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\"\u003eæ–‡æ¡£\u003c/a\u003eã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eIOManager\u003c/code\u003eç±»ä¸­å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\u003ca href=\"https://github.com/kerolt/coroutine-lib/blob/master/src/iomanager.cpp\"\u003eGithub: src/iomanager.cpp\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eä¹‹å‰å®ç°çš„åç¨‹è°ƒåº¦å™¨çš„åŠŸèƒ½å…¶å®éå¸¸ç®€å•ï¼Œå½“æ·»åŠ ä»»åŠ¡åè°ƒåº¦å™¨åªæ˜¯å•çº¯çš„ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡äº¤ç»™åç¨‹å»æ‰§è¡Œã€‚sylarçš„åç¨‹åº“çš„å…³æ³¨å¯¹è±¡æ˜¯ç½‘ç»œIOï¼Œå¦‚æœé‡‡ç”¨è¿™ä¹ˆç®€å•çš„è°ƒåº¦å°±æ ¹æœ¬æ²¡æœ‰ç”¨åˆ°åç¨‹çš„ç²¾é«“ã€‚\u003c/p\u003e\n\u003cp\u003esylarçš„IOåç¨‹è°ƒåº¦è§£å†³äº†ä¹‹å‰è°ƒåº¦å™¨åœ¨idleçŠ¶æ€ä¸‹å¿™ç­‰å¾…å¯¼è‡´CPUå ç”¨ç‡é«˜çš„é—®é¢˜ã€‚IOåç¨‹è°ƒåº¦å™¨ä½¿ç”¨ä¸€å¯¹ç®¡é“fdæ¥tickleè°ƒåº¦åç¨‹ï¼Œå½“è°ƒåº¦å™¨ç©ºé—²æ—¶ï¼Œidleåç¨‹é€šè¿‡epoll_waité˜»å¡åœ¨ç®¡é“çš„è¯»æè¿°ç¬¦ä¸Šï¼Œç­‰ç®¡é“çš„å¯è¯»äº‹ä»¶ã€‚æ·»åŠ æ–°ä»»åŠ¡æ—¶ï¼Œtickleæ–¹æ³•å†™ç®¡é“ï¼Œidleåç¨‹æ£€æµ‹åˆ°ç®¡é“å¯è¯»åé€€å‡ºï¼Œè°ƒåº¦å™¨æ‰§è¡Œè°ƒåº¦ã€‚\u003c/p\u003e","title":"ã€åŠ¨æ‰‹å†™åç¨‹åº“ 4ã€‘IOåç¨‹è°ƒåº¦å™¨"},{"content":" ã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†ä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶å’Œä»£ç éšæƒ³å½•ä¸­çš„æ–‡æ¡£ã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\nTimerManagerç±»ä¸­å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼šGithub: src/timer.cpp\né€šè¿‡å®šæ—¶å™¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°ç»™æœåŠ¡å™¨æ³¨å†Œå®šæ—¶äº‹ä»¶ã€‚sylarçš„å®šæ—¶å™¨é‡‡ç”¨æœ€å°å †è®¾è®¡ï¼Œæ‰€æœ‰å®šæ—¶å™¨æ ¹æ®ç»å¯¹çš„è¶…æ—¶æ—¶é—´ç‚¹ï¼ˆä¹Ÿå°±æ˜¯è¶…æ—¶åˆ°æœŸçš„å…·ä½“æ—¶é—´æˆ³ï¼‰è¿›è¡Œæ’åºï¼Œæ¯æ¬¡å–å‡ºç¦»å½“å‰æ—¶é—´æœ€è¿‘çš„ä¸€ä¸ªè¶…æ—¶æ—¶é—´ç‚¹ï¼Œè®¡ç®—å‡ºè¶…æ—¶éœ€è¦ç­‰å¾…çš„æ—¶é—´ï¼Œç„¶åç­‰å¾…è¶…æ—¶ã€‚è¶…æ—¶æ—¶é—´åˆ°åï¼Œè·å–å½“å‰çš„ç»å¯¹æ—¶é—´ç‚¹ï¼Œç„¶åæŠŠæœ€å°å †é‡Œè¶…æ—¶æ—¶é—´ç‚¹å°äºè¿™ä¸ªæ—¶é—´ç‚¹çš„å®šæ—¶å™¨éƒ½æ”¶é›†èµ·æ¥ï¼Œæ‰§è¡Œå®ƒä»¬çš„å›è°ƒå‡½æ•°ã€‚\nå®šæ—¶å™¨ç›¸å…³APIå¦‚ä¸‹ï¼š\nclass Timer : public std::enable_shared_from_this\u0026lt;Timer\u0026gt; { friend class TimerManager; public: using Ptr = std::shared_ptr\u0026lt;Timer\u0026gt;; bool Cancel(); bool Refresh(); bool Reset(uint64_t ms, bool from_now); private: Timer(uint64_t ms, std::function\u0026lt;void()\u0026gt; cb, bool recur, TimerManager* manager); Timer(uint64_t next); private: bool is_recur_; // æ˜¯å¦å¾ªç¯å®šæ—¶å™¨ uint64_t exec_cycle_; // æ‰§è¡Œå‘¨æœŸ uint64_t next_; // ä¸‹ä¸€æ¬¡çš„åˆ°æœŸæ—¶é—´ std::function\u0026lt;void()\u0026gt; callback_; TimerManager* manager_; struct Comp { bool operator()(const Timer::Ptr\u0026amp; lt, const Timer::Ptr\u0026amp; rt) const { if (!lt || !rt) { return !lt \u0026amp;\u0026amp; rt; } return lt-\u0026gt;next_ \u0026lt; rt-\u0026gt;next_; } }; }; class TimerManager { friend class Timer; public: TimerManager(); virtual ~TimerManager(); // public æ·»åŠ å®šæ—¶å™¨ Timer::Ptr AddTimer(uint64_t ms, std::function\u0026lt;void()\u0026gt; cb, bool is_recur = false); // æ·»åŠ æ¡ä»¶å®šæ—¶å™¨ï¼Œå¦‚æœæ¡ä»¶æˆç«‹åˆ™å®šæ—¶å™¨æ‰æœ‰æ•ˆ Timer::Ptr AddConditionTimer(uint64_t ms, std::function\u0026lt;void()\u0026gt; cb, std::weak_ptr\u0026lt;void\u0026gt; cond, bool is_recur = false); // è·å–ä¸‹ä¸€ä¸ªå®šæ—¶å™¨åˆ°ç°åœ¨çš„æ‰§è¡Œé—´éš”æ—¶é—´ // å¦‚æœæ²¡æœ‰å®šæ—¶å™¨äº†ï¼Œå°±è¿”å›uint64_tçš„æœ€å¤§å€¼ uint64_t GetNextTimerInterval(); // è·å–éœ€è¦æ‰§è¡Œçš„å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°åˆ—è¡¨ std::vector\u0026lt;std::function\u0026lt;void()\u0026gt;\u0026gt; GetExpiredCbList(); // æ˜¯å¦è¿˜æœ‰å®šæ—¶å™¨ bool HasTimer(); protected: virtual void OnTimerInsertAtFront() = 0; void AddTimer(Timer::Ptr timer, std::shared_lock\u0026lt;std::shared_mutex\u0026gt;\u0026amp; lock); private: // ç³»ç»Ÿæ—¶é’Ÿæ˜¯å¦å‡ºç°äº†å›ç»•ï¼ˆrolloverï¼‰ç°è±¡ï¼Œå³å½“å‰æ—¶é—´æ¯”ä¹‹å‰è®°å½•çš„æ—¶é—´è¦å°å¾ˆå¤š // ç”¨äºæ£€æµ‹æœåŠ¡å™¨æ—¶é—´æ˜¯å¦è¢«è°ƒåäº† bool DetectClockRollover(uint64_t now_ms); private: std::shared_mutex rw_mutex_; std::set\u0026lt;Timer::Ptr, Timer::Comp\u0026gt; timer_heap_; bool is_tickled_; uint64_t pre_exec_time_; }; ä¸ªäººæ„Ÿè§‰æœ€é‡è¦çš„APIæ˜¯AddTimerã€GetNextTimerIntervalå’ŒGetExpiredCbListã€‚\nAddTimerå‘æ—¶é—´å †ä¸­æ·»åŠ è¶…æ—¶è¶…æ—¶æ—¶é—´åˆ°äº†åçš„å›è°ƒå‡½æ•°ï¼ˆåˆ©ç”¨Timerç±»æ¥å°è£…ï¼‰ã€‚ GetNextTimerIntervalç”¨äºè·å–ä¸‹ä¸€ä¸ªå®šæ—¶å™¨åˆ°ç°åœ¨çš„æ‰§è¡Œé—´éš”æ—¶é—´ï¼Œè¿™ä¼šç”¨äºIOManager::Idle()ä¸­ç”¨äºä¸è§„å®šçš„æœ€å¤§è¶…æ—¶æ—¶é—´è¿›è¡Œæ¯”è¾ƒï¼Œç”¨è¾ƒå°è€…ä½œä¸ºepoll_waitçš„è¶…æ—¶æ—¶é—´å‚æ•°ã€‚ GetExpiredCbListè·å–çš„æ˜¯æ‰€æœ‰è¶…æ—¶å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ã€‚åœ¨IOManager::Idle()ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°å°†æ‰€æœ‰è¶…æ—¶å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ä½œä¸ºè°ƒåº¦ä»»åŠ¡åŠ å…¥ä»»åŠ¡é˜Ÿåˆ—è¿›è¡Œå¤„ç†ã€‚ åœ¨å®šæ—¶å™¨ä¸­ï¼Œä½¿ç”¨GetElapsedMS()æ¥è·å–ç³»ç»Ÿè‡ªå¯åŠ¨æ¥ç»è¿‡çš„æ—¶é—´ï¼Œå…¶å†…éƒ¨ä½¿ç”¨clock_gettimeæ¥è·å–æ—¶é—´ï¼Œè¿™ç›¸æ¯”äºä¸€äº›ä¼ ç»Ÿæ—¶é—´è·å–å‡½æ•°ï¼ˆå¦‚timeæˆ–gettimeofdayï¼‰æœ‰æ›´é«˜çš„ç²¾åº¦ï¼š\n// è·å–ç³»ç»Ÿè‡ªå¯åŠ¨æ¥ç»è¿‡çš„æ—¶é—´ static uint64_t GetElapsedMS() { struct timespec ts = {0}; clock_gettime(CLOCK_MONOTONIC_RAW, \u0026amp;ts); return ts.tv_sec * 1000 + ts.tv_nsec / 1000000; } ","permalink":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-3%E5%AE%9A%E6%97%B6%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003eã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†\u003ca href=\"https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952\"\u003eä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶\u003c/a\u003eå’Œä»£ç éšæƒ³å½•ä¸­çš„\u003ca href=\"https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\"\u003eæ–‡æ¡£\u003c/a\u003eã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTimerManager\u003c/code\u003eç±»ä¸­å…·ä½“å®šä¹‰å®ç°å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\u003ca href=\"https://github.com/kerolt/coroutine-lib/blob/master/src/timer.cpp\"\u003eGithub: src/timer.cpp\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eé€šè¿‡å®šæ—¶å™¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°ç»™æœåŠ¡å™¨æ³¨å†Œå®šæ—¶äº‹ä»¶ã€‚sylarçš„å®šæ—¶å™¨é‡‡ç”¨æœ€å°å †è®¾è®¡ï¼Œæ‰€æœ‰å®šæ—¶å™¨æ ¹æ®ç»å¯¹çš„è¶…æ—¶æ—¶é—´ç‚¹ï¼ˆä¹Ÿå°±æ˜¯è¶…æ—¶åˆ°æœŸçš„å…·ä½“æ—¶é—´æˆ³ï¼‰è¿›è¡Œæ’åºï¼Œæ¯æ¬¡å–å‡ºç¦»å½“å‰æ—¶é—´\u003cstrong\u003eæœ€è¿‘çš„ä¸€ä¸ªè¶…æ—¶æ—¶é—´ç‚¹\u003c/strong\u003eï¼Œè®¡ç®—å‡ºè¶…æ—¶éœ€è¦ç­‰å¾…çš„æ—¶é—´ï¼Œç„¶åç­‰å¾…è¶…æ—¶ã€‚è¶…æ—¶æ—¶é—´åˆ°åï¼Œè·å–å½“å‰çš„ç»å¯¹æ—¶é—´ç‚¹ï¼Œç„¶å\u003cstrong\u003eæŠŠæœ€å°å †é‡Œè¶…æ—¶æ—¶é—´ç‚¹å°äºè¿™ä¸ªæ—¶é—´ç‚¹çš„å®šæ—¶å™¨éƒ½æ”¶é›†èµ·æ¥\u003c/strong\u003eï¼Œæ‰§è¡Œå®ƒä»¬çš„å›è°ƒå‡½æ•°ã€‚\u003c/p\u003e","title":"ã€åŠ¨æ‰‹å†™åç¨‹åº“ 3ã€‘å®šæ—¶å™¨"},{"content":"æœ€è¿‘çš„ç»ƒæ‰‹é¡¹ç›®web-terminalä¸­ï¼ˆä¹Ÿå°±æ˜¯ä¸€ä¸ªç½‘é¡µç»ˆç«¯ï¼Œå¯æ‰§è¡Œä¸€äº›å‘½ä»¤ï¼‰ï¼Œåœ¨æŒ‰ä¸‹é”®ç›˜åä¼šæ˜¾ç¤ºå¯èƒ½åŒ¹é…çš„å‘½ä»¤åˆ—è¡¨ï¼ˆå‡è®¾å¯¹åº”çš„å‡½æ•°æ˜¯setHintListï¼‰ï¼Œè¿™ä¸ä»…æ˜¯æŒ‰ä¸‹å­—æ¯æŒ‰é”®ä¼šè§¦å‘ï¼ŒæŒ‰ä¸‹åˆ é™¤é”®ã€tabé”®éƒ½ä¼šè§¦å‘ã€‚é‚£å°±ä¸å¾—ä¸è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬æ‰‹é€Ÿå¤ªå¿«ï¼Œé‚£ä¹ˆsetHintListå°±ä¼šé¢‘ç¹è§¦å‘ï¼Œä½†æˆ‘ä»¬åªéœ€è¦å“åº”ç”¨æˆ·æœ€åä¸€æ¬¡è¾“å…¥çš„å‘½ä»¤å³å¯ï¼Œè™½ç„¶åœ¨è¿™ä¸ªå°é¡¹ç›®ä¸­æ²¡å•¥é—®é¢˜ï¼Œä½†æ˜¯ç”±æ­¤å¯ä»¥å¼•å‡ºä¸€äº›å¯¹äºä»¥åå¤§é¡¹ç›®çš„è€ƒè™‘ï¼šå¦‚ä½•å‡å°è¿™ç§å¤šæ¬¡é¢‘ç¹æ‰§è¡Œå‡½æ•°å¸¦æ¥çš„æ€§èƒ½å¼€é”€é—®é¢˜ï¼Ÿé‚£å°±æ˜¯å‡½æ•°é˜²æŠ–~\nå‡½æ•°é˜²æŠ–æ˜¯ä¸€ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œç”¨æ¥é™åˆ¶æŸä¸ªå‡½æ•°åœ¨ä¸€å®šæ—¶é—´å†…è¢«è°ƒç”¨çš„é¢‘ç‡ã€‚å½“äº‹ä»¶è¢«è§¦å‘åï¼Œå®ƒä¼šç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœåœ¨è¿™æ®µæ—¶é—´å†…å†æ¬¡è¢«è§¦å‘ï¼Œé‚£ä¹ˆå®ƒä¼šé‡æ–°å¼€å§‹ç­‰å¾…ã€‚\nä¸‹é¢æ˜¯ä¸€ç§å®ç°æ–¹å¼ï¼š\nexport function buildDebounce(fn: (...arg: any[]) =\u0026gt; any, duration: number = 300) { let timer = -1; return function (this: unknown, ...args: any[]) { if (timer \u0026gt; -1) { clearTimeout(timer); } timer = window.setTimeout(() =\u0026gt; { fn.bind(this)(...args); timer = -1; }, duration); }; } buildDebounceæ¥å—ä¸€ä¸ªå‡½æ•°fnå’Œä¸€ä¸ªå¯é€‰çš„æ—¶é—´é—´éš”durationï¼ˆé»˜è®¤ä¸º 300 æ¯«ç§’ï¼‰ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°ã€‚\nå†…éƒ¨ä½¿ç”¨äº†ä¸€ä¸ªå˜é‡timeræ¥è·Ÿè¸ªå®šæ—¶å™¨çš„å¼•ç”¨ã€‚åˆå§‹å€¼ä¸º -1ï¼Œè¡¨ç¤ºæ²¡æœ‰å®šæ—¶å™¨åœ¨è¿è¡Œã€‚ è¿”å›çš„å‡½æ•°åœ¨è¢«è°ƒç”¨æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥timeræ˜¯å¦å¤§äº -1ã€‚å¦‚æœæ˜¯ï¼Œè¯´æ˜ä¹‹å‰å·²ç»æœ‰ä¸€ä¸ªå®šæ—¶å™¨åœ¨è¿è¡Œï¼Œæ­¤æ—¶ä¼šè°ƒç”¨clearTimeoutæ¸…é™¤è¿™ä¸ªå®šæ—¶å™¨ï¼Œä»¥å–æ¶ˆä¹‹å‰å¯èƒ½æ­£åœ¨ç­‰å¾…æ‰§è¡Œçš„å‡½æ•°è°ƒç”¨ã€‚ ç„¶åï¼Œä½¿ç”¨window.setTimeoutåˆ›å»ºä¸€ä¸ªæ–°çš„å®šæ—¶å™¨ï¼Œåœ¨durationæ¯«ç§’åæ‰§è¡Œä¼ å…¥çš„å‡½æ•°fnï¼Œå¹¶é€šè¿‡bindæ–¹æ³•ç¡®ä¿å‡½æ•°åœ¨æ­£ç¡®çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œã€‚ å½“å®šæ—¶å™¨æ‰§è¡Œå®Œå‡½æ•°åï¼Œå°†timeré‡ç½®ä¸º -1ï¼Œè¡¨ç¤ºæ²¡æœ‰å®šæ—¶å™¨åœ¨è¿è¡Œã€‚ åœ¨(this: unknown, ...args: any[])ä¸­ï¼Œthisçš„å€¼æ˜¯åœ¨è°ƒç”¨ç”±buildDebounceè¿”å›çš„å‡½æ•°æ—¶ï¼Œæ ¹æ®è°ƒç”¨çš„ä¸Šä¸‹æ–‡ç¡®å®šçš„ã€‚ä¹Ÿå°±æ˜¯å½“è¿™ä¸ªè¿”å›çš„å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œé€šè¿‡ä¿ç•™ä¼ å…¥çš„Â thisÂ å€¼ï¼Œå¯ä»¥ç¡®ä¿åœ¨æœ€ç»ˆæ‰§è¡Œè¢«åŒ…è£¹çš„å‡½æ•°Â fnÂ æ—¶ï¼ŒfnÂ èƒ½å¤Ÿåœ¨æ­£ç¡®çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œã€‚\nbuildDebounceçš„ä½¿ç”¨å¦‚ä¸‹ï¼š\nfunction printMessage(message) { console.log(message); } const debouncedPrint = buildDebounce(printMessage); debouncedPrint(\u0026#39;Hello\u0026#39;); debouncedPrint(\u0026#39;World\u0026#39;); // å¦‚æœåœ¨ 300 æ¯«ç§’å†…è¿ç»­è°ƒç”¨ debouncedPrintï¼Œåªæœ‰æœ€åä¸€æ¬¡è°ƒç”¨ä¼šåœ¨ 300 æ¯«ç§’åæ‰§è¡Œæ‰“å°æ“ä½œã€‚ ","permalink":"https://kerolt.github.io/posts/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/","summary":"\u003cp\u003eæœ€è¿‘çš„ç»ƒæ‰‹é¡¹ç›®web-terminalä¸­ï¼ˆä¹Ÿå°±æ˜¯ä¸€ä¸ªç½‘é¡µç»ˆç«¯ï¼Œå¯æ‰§è¡Œä¸€äº›å‘½ä»¤ï¼‰ï¼Œåœ¨æŒ‰ä¸‹é”®ç›˜åä¼šæ˜¾ç¤ºå¯èƒ½åŒ¹é…çš„å‘½ä»¤åˆ—è¡¨ï¼ˆå‡è®¾å¯¹åº”çš„å‡½æ•°æ˜¯\u003ccode\u003esetHintList\u003c/code\u003eï¼‰ï¼Œè¿™ä¸ä»…æ˜¯æŒ‰ä¸‹å­—æ¯æŒ‰é”®ä¼šè§¦å‘ï¼ŒæŒ‰ä¸‹åˆ é™¤é”®ã€tabé”®éƒ½ä¼šè§¦å‘ã€‚é‚£å°±ä¸å¾—ä¸è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬æ‰‹é€Ÿå¤ªå¿«ï¼Œé‚£ä¹ˆ\u003ccode\u003esetHintList\u003c/code\u003eå°±ä¼šé¢‘ç¹è§¦å‘ï¼Œä½†æˆ‘ä»¬åªéœ€è¦å“åº”ç”¨æˆ·æœ€åä¸€æ¬¡è¾“å…¥çš„å‘½ä»¤å³å¯ï¼Œè™½ç„¶åœ¨è¿™ä¸ªå°é¡¹ç›®ä¸­æ²¡å•¥é—®é¢˜ï¼Œä½†æ˜¯ç”±æ­¤å¯ä»¥å¼•å‡ºä¸€äº›å¯¹äºä»¥åå¤§é¡¹ç›®çš„è€ƒè™‘ï¼šå¦‚ä½•å‡å°è¿™ç§å¤šæ¬¡é¢‘ç¹æ‰§è¡Œå‡½æ•°å¸¦æ¥çš„æ€§èƒ½å¼€é”€é—®é¢˜ï¼Ÿé‚£å°±æ˜¯å‡½æ•°é˜²æŠ–~\u003c/p\u003e","title":"å‡½æ•°é˜²æŠ–"},{"content":"C++ ä¸­ï¼Œstd::enable_shared_from_thisç±»æ¨¡æ¿å’Œshared_from_thisæˆå‘˜å‡½æ•°ä¸»è¦ç”¨äºåœ¨ä¸€ä¸ªç±»çš„æˆå‘˜å‡½æ•°ä¸­å®‰å…¨åœ°è·å–æŒ‡å‘è‡ªèº«çš„std::shared_ptrã€‚å®ƒä»¬çš„ä½œç”¨æ›´å¤šæ˜¯ä¸ºäº†ç¡®ä¿èµ„æºæ­£ç¡®ç®¡ç†ã€‚\nå½“ä¸€ä¸ªå¯¹è±¡è¢«å¤šä¸ªstd::shared_ptrç®¡ç†æ—¶ï¼Œå¦‚æœåœ¨å¯¹è±¡å†…éƒ¨çš„æˆå‘˜å‡½æ•°ä¸­ç›´æ¥åˆ›å»ºæ–°çš„std::shared_ptræŒ‡å‘è‡ªèº«ï¼ˆä¹Ÿå°±æ˜¯thisï¼‰ï¼Œå¯èƒ½ä¼šå¯¼è‡´å¤šä¸ªç‹¬ç«‹çš„å¼•ç”¨è®¡æ•°ï¼Œä»è€Œæ— æ³•æ­£ç¡®ç®¡ç†å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚è€Œä½¿ç”¨shared_from_thiså¯ä»¥ç¡®ä¿æ‰€æœ‰æŒ‡å‘è¯¥å¯¹è±¡çš„std::shared_ptrå…±äº«åŒä¸€ä¸ªå¼•ç”¨è®¡æ•°ï¼Œä»è€Œæ­£ç¡®ç®¡ç†å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚\nä¾‹å¦‚ï¼š\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class MyClass : public std::enable_shared_from_this\u0026lt;MyClass\u0026gt; { public: void print() { std::shared_ptr\u0026lt;MyClass\u0026gt; ptr = shared_from_this(); std::cout \u0026lt;\u0026lt; \u0026#34;Use count: \u0026#34; \u0026lt;\u0026lt; ptr.use_count() \u0026lt;\u0026lt; std::endl; } }; int main() { std::shared_ptr\u0026lt;MyClass\u0026gt; obj = std::make_shared\u0026lt;MyClass\u0026gt;(); obj-\u0026gt;print(); return 0; } printå‡½æ•°ä¸­ä½¿ç”¨shared_from_thisè·å–æŒ‡å‘è‡ªèº«çš„std::shared_ptrï¼Œç¡®ä¿äº†ä¸å¤–éƒ¨åˆ›å»ºçš„std::shared_ptrå…±äº«åŒä¸€ä¸ªå¼•ç”¨è®¡æ•°ã€‚\nå¦‚æœåœ¨å¯¹è±¡å†…éƒ¨çš„æˆå‘˜å‡½æ•°ä¸­ç›´æ¥è¿”å›ä¸€ä¸ªæŒ‡å‘è‡ªèº«çš„æ™®é€šæŒ‡é’ˆï¼Œå½“å¤–éƒ¨çš„std::shared_ptrè¢«é”€æ¯åï¼Œè¿™ä¸ªæ™®é€šæŒ‡é’ˆå°±ä¼šå˜æˆæ‚¬ç©ºæŒ‡é’ˆã€‚è€Œä½¿ç”¨shared_from_thiså¯ä»¥é¿å…è¿™ç§æƒ…å†µï¼Œå› ä¸ºå®ƒè¿”å›çš„std::shared_pträ¼šåœ¨å¼•ç”¨è®¡æ•°ä¸ºé›¶æ—¶è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡æ‰€å ç”¨çš„å†…å­˜ã€‚ä¾‹å¦‚è¿™é‡Œä¸ä½¿ç”¨enable_shared_from_thiså’Œshared_from_thisï¼Œåˆ™å¯¹è±¡ä¼šå¤šæ¬¡é‡Šæ”¾ï¼Œå¯¼è‡´ç¨‹åºå‡ºé”™ã€‚\nä»£ç åŠå…¶æ‰§è¡Œç»“æœå¯å‚è§ï¼šè¿™é‡Œ\n","permalink":"https://kerolt.github.io/posts/c++/enable_shared_from_this%E7%9A%84%E4%BD%9C%E7%94%A8/","summary":"\u003cp\u003eC++ ä¸­ï¼Œ\u003ccode\u003estd::enable_shared_from_this\u003c/code\u003eç±»æ¨¡æ¿å’Œ\u003ccode\u003eshared_from_this\u003c/code\u003eæˆå‘˜å‡½æ•°ä¸»è¦ç”¨äºåœ¨ä¸€ä¸ªç±»çš„æˆå‘˜å‡½æ•°ä¸­å®‰å…¨åœ°è·å–æŒ‡å‘è‡ªèº«çš„\u003ccode\u003estd::shared_ptr\u003c/code\u003eã€‚å®ƒä»¬çš„ä½œç”¨æ›´å¤šæ˜¯ä¸ºäº†ç¡®ä¿èµ„æºæ­£ç¡®ç®¡ç†ã€‚\u003c/p\u003e","title":"enable_shared_from_thisçš„ä½œç”¨"},{"content":" ã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†ä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶å’Œä»£ç éšæƒ³å½•ä¸­çš„æ–‡æ¡£ã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\nSchedulerç±»ä¸­å…¶ä»–å‡½æ•°çš„å®šä¹‰å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼šGithub: src/scheduler.cpp\nSylarçš„åç¨‹è°ƒåº¦å™¨æ˜¯ä¸€ä¸ªN-Mæ¨¡å‹ï¼Œæ„å‘³ç€Nä¸ªçº¿ç¨‹å¯ä»¥è¿è¡ŒMä¸ªåç¨‹ï¼Œåç¨‹èƒ½å¤Ÿåœ¨çº¿ç¨‹ä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼Œä¹Ÿå¯ä»¥è¢«ç»‘å®šåˆ°ç‰¹å®šçš„çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚\nè°ƒåº¦å™¨å¯ä»¥ç”±åº”ç”¨ç¨‹åºä¸­çš„ä»»ä½•çº¿ç¨‹åˆ›å»ºï¼Œä½†åˆ›å»ºå®ƒçš„çº¿ç¨‹ï¼ˆç§°ä¸ºcallerçº¿ç¨‹ï¼‰å¯ä»¥é€‰æ‹©æ˜¯å¦å‚ä¸åç¨‹çš„è°ƒåº¦ã€‚å¦‚æœcallerçº¿ç¨‹å‚ä¸è°ƒåº¦ï¼Œé‚£ä¹ˆè°ƒåº¦å™¨çš„çº¿ç¨‹æ•°ä¼šç›¸åº”å‡å°‘ä¸€ä¸ªï¼Œå› ä¸ºcallerçº¿ç¨‹æœ¬èº«ä¹Ÿä¼šä½œä¸ºä¸€ä¸ªè°ƒåº¦çº¿ç¨‹ã€‚\nSchedulerç›¸å…³APIå¦‚ä¸‹ï¼š\n#ifndef SCHEDULER_H_ #define SCHEDULER_H_ #include \u0026lt;atomic\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;coroutine.h\u0026#34; #include \u0026#34;util.h\u0026#34; // åç¨‹è°ƒåº¦å™¨ class Scheduler { private: // è°ƒåº¦ä»»åŠ¡ï¼Œä»»åŠ¡ç±»å‹å¯ä»¥æ˜¯åç¨‹/å‡½æ•°äºŒé€‰ä¸€ï¼Œå¹¶ä¸”å¯æŒ‡å®šè°ƒåº¦çº¿ç¨‹ using ThreadIdPtr = std::shared_ptr\u0026lt;std::thread::id\u0026gt;; struct SchedulerTask { ThreadIdPtr thread_id_; Coroutine::Ptr coroutine_; std::function\u0026lt;void()\u0026gt; callback_; SchedulerTask() {} SchedulerTask(Coroutine::Ptr co, ThreadIdPtr id) : coroutine_(co) , thread_id_(std::move(id)) {} SchedulerTask(std::function\u0026lt;void()\u0026gt; callback, ThreadIdPtr id) : callback_(callback) , thread_id_(std::move(id)) {} void Reset() { thread_id_.reset(); callback_ = nullptr; coroutine_ = nullptr; } }; public: Scheduler(size_t threads = 1, bool use_caller = true, const std::string\u0026amp; name = \u0026#34;scheduler\u0026#34;); virtual ~Scheduler(); std::string GetName() const { return name_; } void Start(); void Stop(); template \u0026lt;typename TaskType\u0026gt; void Sched(TaskType t, ThreadIdPtr id = nullptr) requires(std::invocable\u0026lt;TaskType\u0026gt; || std::same_as\u0026lt;TaskType, Coroutine::Ptr\u0026gt;) { bool is_need_tick = false; { std::lock_guard lock(mutex_); is_need_tick = tasks_.empty(); SchedulerTask task(t, id); if (task.callback_ || task.coroutine_) { tasks_.push_back(task); } } if (is_need_tick) { Tickle(); } } public: static Scheduler* GetScheduler(); static Coroutine* GetSchedCoroutine(); protected: virtual void Tickle(); void Run(); void SetThisAsScheduler(); virtual void Idle(); virtual bool IsStop(); bool HasIdleThreads() { return idle_threads_ \u0026gt; 0; } private: std::string name_; std::mutex mutex_; std::vector\u0026lt;std::thread\u0026gt; thread_pool_; std::vector\u0026lt;std::thread::id\u0026gt; thread_ids_; std::list\u0026lt;SchedulerTask\u0026gt; tasks_; size_t threads_size_; std::atomic_size_t active_threads_{0}; std::atomic_size_t idle_threads_{0}; std::thread::id sched_id_; // use_callerä¸ºtrueæ—¶ï¼Œè°ƒåº¦å™¨æ‰€åœ¨çš„çº¿ç¨‹id Coroutine::Ptr sched_co_; // use_callerä¸ºtrueæ—¶è°ƒåº¦å™¨æ‰€åœ¨çº¿ç¨‹çš„è°ƒåº¦åç¨‹ bool is_stop_; bool is_use_caller_; }; #endif /* SCHEDULER_H_ */ è°ƒåº¦å™¨çš„å·¥ä½œæµå¤§è‡´ä¸ºï¼š\nåç¨‹è°ƒåº¦å™¨åœ¨åˆå§‹åŒ–æ—¶å¯ä¼ å…¥çº¿ç¨‹æ•°å’Œä¸€ä¸ªå¸ƒå°”å‹çš„use_callerå‚æ•°ï¼Œè¡¨ç¤ºæ˜¯å¦ä½¿ç”¨callerçº¿ç¨‹ã€‚åœ¨ä½¿ç”¨callerçº¿ç¨‹çš„æƒ…å†µä¸‹ï¼Œçº¿ç¨‹æ•°è‡ªåŠ¨å‡ä¸€ï¼Œå¹¶ä¸”è°ƒåº¦å™¨å†…éƒ¨ä¼šåˆå§‹åŒ–ä¸€ä¸ªå±äºcallerçº¿ç¨‹çš„è°ƒåº¦åç¨‹å¹¶ä¿å­˜èµ·æ¥ï¼ˆæ¯”å¦‚ï¼Œåœ¨mainå‡½æ•°ä¸­åˆ›å»ºçš„è°ƒåº¦å™¨ï¼Œå¦‚æœuse_callerä¸ºtrueï¼Œé‚£è°ƒåº¦å™¨ä¼šåˆå§‹åŒ–ä¸€ä¸ªå±äºmainå‡½æ•°çº¿ç¨‹çš„è°ƒåº¦åç¨‹ï¼‰ã€‚ è°ƒåº¦å™¨åˆ›å»ºå¥½åÂ ï¼Œå³å¯è°ƒç”¨è°ƒåº¦å™¨çš„Schedå‡½æ•°å‘è°ƒåº¦å™¨æ·»åŠ è°ƒåº¦ä»»åŠ¡ï¼Œä½†æ­¤æ—¶è°ƒåº¦å™¨å¹¶ä¸ä¼šç«‹åˆ»æ‰§è¡Œè¿™äº›ä»»åŠ¡ï¼Œè€Œæ˜¯å°†å®ƒä»¬ä¿å­˜åˆ°å†…éƒ¨çš„ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—ä¸­ã€‚ è°ƒç”¨Scheduler::Start()å‡½æ•°å¯åŠ¨è°ƒåº¦Â ã€‚è°ƒç”¨Startä¼šåˆ›å»ºè°ƒåº¦çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ•°é‡ç”±åˆå§‹åŒ–æ—¶çš„çº¿ç¨‹æ•°å’Œuse_callerç¡®å®šã€‚è°ƒåº¦çº¿ç¨‹ä¸€æ—¦åˆ›å»ºï¼Œå°±ä¼šç«‹åˆ»ä»ä»»åŠ¡é˜Ÿåˆ—é‡Œå–ä»»åŠ¡æ‰§è¡Œã€‚æ¯”è¾ƒç‰¹æ®Šçš„ä¸€ç‚¹æ˜¯ï¼Œå¦‚æœåˆå§‹åŒ–æ—¶æŒ‡å®šçº¿ç¨‹æ•°ä¸º1ä¸”use_callerä¸ºtrueï¼Œé‚£ä¹ˆStartæ–¹æ³•ä»€ä¹ˆä¹Ÿä¸åšï¼Œå› ä¸ºä¸éœ€è¦åˆ›å»ºæ–°çº¿ç¨‹ç”¨äºè°ƒåº¦ã€‚å¹¶ä¸”ï¼Œç”±äºæ²¡æœ‰åˆ›å»ºæ–°çš„è°ƒåº¦çº¿ç¨‹ï¼Œé‚£åªèƒ½ç”±callerçº¿ç¨‹çš„è°ƒåº¦åç¨‹æ¥è´Ÿè´£è°ƒåº¦åç¨‹ï¼ˆè¿™é‡Œæœ‰ç‚¹ç»•ï¼‰ï¼Œè€Œcallerçº¿ç¨‹çš„è°ƒåº¦åç¨‹çš„æ‰§è¡Œæ—¶æœºä¸Startå‡½æ•°å¹¶ä¸åœ¨åŒä¸€ä¸ªåœ°æ–¹ã€‚callerçº¿ç¨‹çš„è°ƒåº¦åç¨‹çš„æ‰§è¡Œæ—¶æœºåœ¨Stopå‡½æ•°ä¸­ã€‚ æ¥ä¸‹æ¥æ˜¯è°ƒåº¦åç¨‹ï¼Œå¯¹åº”Scheduler::Run()Â ã€‚è°ƒåº¦åç¨‹è´Ÿè´£ä»è°ƒåº¦å™¨çš„ä»»åŠ¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡æ‰§è¡Œã€‚å–å‡ºçš„ä»»åŠ¡å³å­åç¨‹ï¼Œæ¯ä¸ªå­åç¨‹æ‰§è¡Œå®Œåéƒ½å¿…é¡»è¿”å›è°ƒåº¦åç¨‹ï¼Œç”±è°ƒåº¦åç¨‹é‡æ–°ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–æ–°çš„åç¨‹å¹¶æ‰§è¡Œã€‚å¦‚æœä»»åŠ¡é˜Ÿåˆ—ç©ºäº†ï¼Œé‚£ä¹ˆè°ƒåº¦åç¨‹ä¼šåˆ‡æ¢åˆ°ä¸€ä¸ªidleåç¨‹ï¼Œç­‰æœ‰æ–°ä»»åŠ¡è¿›æ¥æ—¶ï¼Œidleåç¨‹æ‰ä¼šé€€å‡ºå¹¶å›åˆ°è°ƒåº¦åç¨‹ï¼Œé‡æ–°å¼€å§‹ä¸‹ä¸€è½®è°ƒåº¦ã€‚ï¼ˆåœ¨Schedulerä¸­ï¼Œidleå‡½æ•°çš„å®šä¹‰ååˆ†ç®€å•ç²—æš´ï¼Œå› ä¸ºå®é™…ä½¿ç”¨åç¨‹åº“æ—¶å¹¶ä¸æ˜¯ç›´æ¥ä½¿ç”¨Schedulerç±»ï¼Œè€Œæ˜¯ä½¿ç”¨å®ƒçš„æ´¾ç”Ÿç±»ï¼Œåœ¨æ´¾ç”Ÿç±»ä¸­å°†ä¼šå®ç°æ›´ä¸ºå®Œå–„çš„è°ƒåº¦ï¼‰ æ¥ä¸‹æ¥æ˜¯æ·»åŠ è°ƒåº¦ä»»åŠ¡ï¼Œå¯¹åº”Scheduler::Sched()Â ï¼Œè¿™ä¸ªæ–¹æ³•æ”¯æŒä¼ å…¥åç¨‹æˆ–å‡½æ•°ï¼Œå¹¶ä¸”æ”¯æŒä¸€ä¸ªçº¿ç¨‹idå‚æ•°ï¼Œè¡¨ç¤ºæ˜¯å¦å°†è¿™ä¸ªåç¨‹æˆ–å‡½æ•°ç»‘å®šåˆ°ä¸€ä¸ªå…·ä½“çš„çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚å¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œé‚£ä¹ˆåœ¨æ·»åŠ ä»»åŠ¡ä¹‹åï¼Œè¦è°ƒç”¨ä¸€æ¬¡tickleæ–¹æ³•ä»¥é€šçŸ¥å„è°ƒåº¦çº¿ç¨‹çš„è°ƒåº¦åç¨‹æœ‰æ–°ä»»åŠ¡æ¥äº†ã€‚åœ¨æ‰§è¡Œè°ƒåº¦ä»»åŠ¡æ—¶ï¼Œè¿˜å¯ä»¥é€šè¿‡è°ƒåº¦å™¨çš„GetScheduler()è·å–åˆ°å½“å‰è°ƒåº¦å™¨ï¼Œå†é€šè¿‡Schedå‡½æ•°ç»§ç»­æ·»åŠ æ–°çš„ä»»åŠ¡ï¼Œè¿™å°±å˜ç›¸å®ç°äº†åœ¨å­åç¨‹ä¸­åˆ›å»ºå¹¶è¿è¡Œæ–°çš„å­åç¨‹çš„åŠŸèƒ½ã€‚ æ¥ä¸‹æ¥æ˜¯è°ƒåº¦å™¨çš„åœæ­¢ã€‚è°ƒåº¦å™¨çš„åœæ­¢è¡Œä¸ºè¦åˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼Œé¦–å…ˆæ˜¯use_callerä¸ºfalseçš„æƒ…å†µï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºæ²¡æœ‰ä½¿ç”¨callerçº¿ç¨‹è¿›è¡Œè°ƒåº¦ï¼Œé‚£ä¹ˆåªéœ€è¦ç®€å•åœ°ç­‰å„ä¸ªè°ƒåº¦çº¿ç¨‹çš„è°ƒåº¦åç¨‹é€€å‡ºå°±è¡Œäº†ã€‚å¦‚æœuse_callerä¸ºtrueï¼Œè¡¨ç¤ºcallerçº¿ç¨‹ä¹Ÿè¦å‚äºè°ƒåº¦ï¼Œè¿™æ—¶ï¼Œè°ƒåº¦å™¨åˆå§‹åŒ–æ—¶è®°å½•çš„å±äºcallerçº¿ç¨‹çš„è°ƒåº¦åç¨‹å°±è¦èµ·ä½œç”¨äº†ï¼Œåœ¨è°ƒåº¦å™¨åœæ­¢å‰ï¼Œåº”è¯¥è®©è¿™ä¸ªcallerçº¿ç¨‹çš„è°ƒåº¦åç¨‹ä¹Ÿè¿è¡Œä¸€æ¬¡ï¼Œè®©callerçº¿ç¨‹å®Œæˆè°ƒåº¦å·¥ä½œåå†é€€å‡ºã€‚å¦‚æœè°ƒåº¦å™¨åªä½¿ç”¨äº†callerçº¿ç¨‹è¿›è¡Œè°ƒåº¦ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„è°ƒåº¦ä»»åŠ¡è¦åœ¨è°ƒåº¦å™¨åœæ­¢æ—¶æ‰ä¼šè¢«è°ƒåº¦ã€‚ è°ƒåº¦å™¨ä¸­æœ€é‡è¦çš„ä¸€ä¸ªå‡½æ•°æˆ‘è®¤ä¸ºå°±æ˜¯Run()å‡½æ•°äº†ï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºåç¨‹çš„è°ƒåº¦ï¼Œæˆ–è€…ï¼Œä½ å¯ä»¥å°†ä»–ç†è§£ä¸ºæ˜¯ä¸€ä¸ªè°ƒåº¦åç¨‹ï¼ˆåè¯ï¼‰ã€‚\nåˆ›å»ºScheduleræ—¶ä¼šä¸ºæ¯ä¸€ä¸ªå†…éƒ¨çº¿ç¨‹æ± ä¸­çš„æ¯ä¸€ä¸ªçº¿ç¨‹éƒ½ç»‘å®šä¸€ä¸ªè°ƒåº¦åç¨‹ï¼Œçº¿ç¨‹æ•°é‡é»˜è®¤ä¸º1ï¼Œæ­¤æ—¶ä¹Ÿé»˜è®¤ä¼šä½¿ç”¨callerçº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨çš„ä¸»çº¿ç¨‹ã€‚è°ƒåº¦åç¨‹Scheduler::Run()ä¼šä»ä»»åŠ¡é˜Ÿåˆ—Task Queueä¸­ä¸æ–­å»å–ä»»åŠ¡å»æ‰§è¡Œã€‚å¦‚æœæœ‰ä»»åŠ¡å¯æ‰§è¡Œï¼Œé‚£å°±åˆ‡æ¢è‡³ä»»åŠ¡åç¨‹æ‰§è¡Œï¼Œä»»åŠ¡åç¨‹æ‰§è¡Œå®Œæ¯•ååˆåˆ‡æ¢å›è°ƒåº¦åç¨‹ï¼›æ— ä»»åŠ¡æ‰§è¡Œæ—¶ï¼Œè°ƒåº¦åç¨‹åˆ‡æ¢è‡³Idleåç¨‹è¿›è¡Œç­‰å¾…ã€‚\n// ç”¨äºåç¨‹çš„è°ƒåº¦ void Scheduler::Run() { LOG \u0026lt;\u0026lt; \u0026#34;Scheduler running...\\n\u0026#34;; SetThisAsScheduler(); // å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯è°ƒåº¦å™¨æ‰€åœ¨çº¿ç¨‹ï¼Œè®¾ç½®è°ƒåº¦çš„åç¨‹ä¸ºå½“å‰çº¿ç¨‹è¿è¡Œçš„åç¨‹ if (std::this_thread::get_id() != sched_id_) { sched_coroutine = Coroutine::GetNowCoroutine().get(); } Coroutine::Ptr idle_co = std::make_shared\u0026lt;Coroutine\u0026gt;([this] { this-\u0026gt;Idle(); }); Coroutine::Ptr callback_co; SchedulerTask task; while (true) { task.Reset(); bool tickle = false; { std::lock_guard lock(mutex_); auto iter = tasks_.begin(); while (iter != tasks_.end()) { // å½“å‰éå†çš„taskå·²ç»åˆ†é…äº†çº¿ç¨‹å»æ‰§è¡Œä¸”è¿™ä¸ªçº¿ç¨‹ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œåˆ™ä¸ç”¨ç®¡ if (iter-\u0026gt;thread_id_ \u0026amp;\u0026amp; *iter-\u0026gt;thread_id_ != std::this_thread::get_id()) { ++iter; tickle = true; continue; } if (iter-\u0026gt;coroutine_ \u0026amp;\u0026amp; iter-\u0026gt;coroutine_-\u0026gt;GetState() != Coroutine::READY) { LOG \u0026lt;\u0026lt; \u0026#34;Coroutine task\u0026#39;s state should be READY!\\n\u0026#34;; assert(false); } task = *iter; tasks_.erase(iter++); active_threads_++; break; } // æœ‰ä»»åŠ¡å¯ä»¥å»æ‰§è¡Œï¼Œéœ€è¦tickleä¸€ä¸‹ tickle |= (iter != tasks_.end()); } if (tickle) { Tickle(); } // å­åç¨‹æ‰§è¡Œå®Œæ¯•åyieldä¼šå›åˆ°Run()ä¸­ if (task.coroutine_) { // ä»»åŠ¡ç±»å‹ä¸ºåç¨‹ task.coroutine_-\u0026gt;Resume(); active_threads_--; } else if (task.callback_) { // ä»»åŠ¡ç±»å‹ä¸ºå›è°ƒå‡½æ•° if (callback_co) { callback_co-\u0026gt;Reset(task.callback_); } else { callback_co = std::make_shared\u0026lt;Coroutine\u0026gt;(task.callback_); } callback_co-\u0026gt;Resume(); active_threads_--; } else { // æ— ä»»åŠ¡ï¼Œä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º if (idle_co-\u0026gt;GetState() == Coroutine::FINISH) { LOG \u0026lt;\u0026lt; \u0026#34;Idle coroutine finish\\n\u0026#34;; break; } idle_threads_++; idle_co-\u0026gt;Resume(); // Idleæœ€åYeildæ—¶å›åˆ°è¿™é‡Œ idle_threads_--; } } LOG \u0026lt;\u0026lt; \u0026#34;Scheduler Run() exit\\n\u0026#34;; } è¿™ä¸ªScheduleræ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„è°ƒåº¦å™¨ï¼Œè¦å¯¹ä»»åŠ¡åšæ›´å¥½çš„è°ƒåº¦ï¼Œå°‘ä¸äº†Idleåç¨‹çš„å¸®åŠ©ã€‚Idleåç¨‹çš„å…·ä½“å®ç°è¦åœ¨ä¹‹åçš„IOManagerä¸­ï¼Œå…¶ç»§æ‰¿è‡ªSchedulerï¼Œé‡å†™äº†Tickle()ã€Idle()ç­‰å‡½æ•°ï¼Œå¹¶ä¸”ä½¿ç”¨epollæ¥å®ç°åœ¨ä¸åŒçš„ I/O äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œè§¦å‘ç›¸åº”çš„å¤„ç†é€»è¾‘ã€‚è¿™ä½¿å¾—ç¨‹åºå¯ä»¥ä»¥éé˜»å¡çš„æ–¹å¼å¤„ç†å¤šä¸ª I/O æ“ä½œï¼Œè€Œä¸å¿…ç­‰å¾…æ¯ä¸ªæ“ä½œå®Œæˆåå†è¿›è¡Œä¸‹ä¸€ä¸ªæ“ä½œã€‚\n","permalink":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-2%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003eã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†\u003ca href=\"https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952\"\u003eä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶\u003c/a\u003eå’Œä»£ç éšæƒ³å½•ä¸­çš„\u003ca href=\"https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\"\u003eæ–‡æ¡£\u003c/a\u003eã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eScheduler\u003c/code\u003eç±»ä¸­å…¶ä»–å‡½æ•°çš„å®šä¹‰å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\u003ca href=\"https://github.com/kerolt/coroutine-lib/blob/master/src/scheduler.cpp\"\u003eGithub: src/scheduler.cpp\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSylarçš„åç¨‹è°ƒåº¦å™¨æ˜¯ä¸€ä¸ªN-Mæ¨¡å‹ï¼Œæ„å‘³ç€Nä¸ªçº¿ç¨‹å¯ä»¥è¿è¡ŒMä¸ªåç¨‹ï¼Œåç¨‹èƒ½å¤Ÿåœ¨çº¿ç¨‹ä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼Œä¹Ÿå¯ä»¥è¢«ç»‘å®šåˆ°ç‰¹å®šçš„çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚\u003c/p\u003e\n\u003cp\u003eè°ƒåº¦å™¨å¯ä»¥ç”±åº”ç”¨ç¨‹åºä¸­çš„ä»»ä½•çº¿ç¨‹åˆ›å»ºï¼Œä½†åˆ›å»ºå®ƒçš„çº¿ç¨‹ï¼ˆç§°ä¸ºcallerçº¿ç¨‹ï¼‰å¯ä»¥é€‰æ‹©æ˜¯å¦å‚ä¸åç¨‹çš„è°ƒåº¦ã€‚å¦‚æœcallerçº¿ç¨‹å‚ä¸è°ƒåº¦ï¼Œé‚£ä¹ˆè°ƒåº¦å™¨çš„çº¿ç¨‹æ•°ä¼šç›¸åº”å‡å°‘ä¸€ä¸ªï¼Œå› ä¸ºcallerçº¿ç¨‹æœ¬èº«ä¹Ÿä¼šä½œä¸ºä¸€ä¸ªè°ƒåº¦çº¿ç¨‹ã€‚\u003c/p\u003e","title":"ã€åŠ¨æ‰‹å†™åç¨‹åº“ 2ã€‘åç¨‹è°ƒåº¦å™¨"},{"content":" ã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†ä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶å’Œä»£ç éšæƒ³å½•ä¸­çš„æ–‡æ¡£ã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\nCoroutineç±»ä¸­å…¶ä»–å‡½æ•°çš„å®šä¹‰å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼šGithub: src/coroutine.cpp\nå¯¹äºä»€ä¹ˆæ˜¯åç¨‹ï¼Œä¸ºä»€ä¹ˆè¦ä½¿ç”¨åç¨‹ï¼Œå¯ä»¥çœ‹çœ‹ä¹‹å‰çš„ç¬”è®°ï¼šã€åç¨‹ã€‘C++20åç¨‹åˆä½“éªŒã€‚\nå¯¹äºæˆ‘ä»¬è‡ªå·±æ¥å®ç°åç¨‹ï¼Œå…¶å®åœ¨ä¹‹å‰Xv6çš„Labä¸­å°±æœ‰åšè¿‡ï¼šã€MIT6.S081ã€‘Lab6 multithreadingï¼Œå½“åˆåšè¿™ä¸ªlabçš„æ—¶å€™æ²¡æœ‰æ„è¯†åˆ°è¿™å°±æ˜¯åç¨‹ã€‚åç¨‹çš„åˆ‡æ¢æœ€é‡è¦çš„å°±æ˜¯è¦ä¿å­˜å’Œæ¢å¤ä¸Šä¸‹æ–‡ï¼Œåœ¨è¿™ä¸ªlabä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä¿å­˜æ¯ä¸ªåç¨‹åœ¨åˆ‡æ¢ä¹‹å‰çš„å¯„å­˜å™¨çš„å€¼ï¼Œä»¥æ­¤å¯ç”¨æ¥æ¢å¤åŸæ¥çš„æ‰§è¡Œæµã€‚\nåœ¨sylarçš„åç¨‹åº“å®ç°ä¸­ï¼Œä½¿ç”¨çš„æ˜¯LinuxåŸç”Ÿæä¾›çš„ucontextæ¥ä¿å­˜åç¨‹çš„ä¸Šä¸‹æ–‡å’Œåˆ‡æ¢ã€‚å¯¹äºåç¨‹åˆ‡æ¢ï¼Œæœ€é‡è¦çš„ä¸¤ä¸ªAPIå°±æ˜¯yieldå’Œresumeï¼Œåˆ†åˆ«å¯¹åº”åç¨‹è®©å‡ºæ‰§è¡Œæƒå’Œæ¢å¤åç¨‹ã€‚åˆ©ç”¨ ucontext æä¾›çš„å››ä¸ªå‡½æ•°getcontext()ã€setcontext()ã€makecontext()ã€swapcontext()å¯ä»¥åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­å®ç°åç¨‹åˆ‡æ¢ã€‚ï¼ˆè¿™é‡Œå°±ä¸ä»‹ç»è¿™å‡ ä¸ªå‡½æ•°çš„ç”¨æ³•æ¥ï¼Œè¯¦ç»†æ–‡æ¡£å¯ä½¿ç”¨manå‘½ä»¤æŸ¥çœ‹ï¼‰\nCoroutineçš„ç›¸å…³APIå¦‚ä¸‹ï¼š\n#ifndef COROUTINE_H_ #define COROUTINE_H_ #include \u0026lt;sys/ucontext.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;memory\u0026gt; class Coroutine : public std::enable_shared_from_this\u0026lt;Coroutine\u0026gt; { public: using Ptr = std::shared_ptr\u0026lt;Coroutine\u0026gt;; enum State { READY, RUNNING, FINISH }; Coroutine(std::function\u0026lt;void()\u0026gt; callback, size_t stack_size = 0, bool run_in_scheduler = true); ~Coroutine(); void Yield(); void Resume(); void Reset(std::function\u0026lt;void()\u0026gt; callback); uint64_t GetId() const { return id_; } State GetState() const { return state_; } public: static void SetNowCoroutine(Coroutine* co); static Coroutine::Ptr GetNowCoroutine(); static uint64_t TotalCoNums(); static void Task(); static uint64_t GetCurrentId(); private: Coroutine(); private: uint64_t id_ = 0; uint32_t stack_size_ = 0; State state_ = READY; bool is_run_in_sched_; ucontext_t ctx_; // åç¨‹ä¸Šä¸‹æ–‡ void* pstack_ = nullptr; // åç¨‹çš„æ ˆåœ°å€ std::function\u0026lt;void()\u0026gt; callback_; }; #endif /* COROUTINE_H_ */ ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿è¡Œå¤šä¸ªåç¨‹ï¼Œä½†æ˜¯åœ¨æŸä¸€ä¸ªæ—¶åˆ»åªèƒ½è¿è¡Œä¸€ä¸ªåç¨‹ã€‚æˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªçº¿ç¨‹è®¾ç½®å½“å‰è¿è¡Œçš„åç¨‹çš„æŒ‡é’ˆå’Œè¡¨ç¤ºçº¿ç¨‹çš„ä¸»åç¨‹çš„æŒ‡é’ˆã€‚è¿™é‡Œç”¨åˆ°äº†C++ä¸­çš„thread_localå…³é”®å­—ï¼š\nstatic thread_local Coroutine* cur_coroutine = nullptr; static thread_local Coroutine::Ptr main_coroutine = nullptr; æ¯å½“æˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªåç¨‹æ¥æ‰§è¡Œä»»åŠ¡æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è¦ä¼ å…¥çš„å‚æ•°ä¸ºè¦æ‰§è¡Œçš„å‡½æ•°ï¼Œè€Œåç¨‹çš„æ ˆå¤§å°æœ‰é»˜è®¤å€¼ï¼Œé»˜è®¤ä½¿ç”¨è°ƒåº¦å™¨è¿›è¡Œè°ƒåº¦ï¼š\nCoroutine::Coroutine(std::function\u0026lt;void()\u0026gt; callback, size_t stack_size, bool run_in_scheduler) : callback_(callback) , is_run_in_sched_(run_in_scheduler) { co_count++; stack_size_ = stack_size \u0026gt; 0 ? stack_size : CO_STACK_SIZE; pstack_ = malloc(stack_size_); // getcontext()ç”¨äºä¿å­˜å½“å‰ä¸Šä¸‹æ–‡ï¼Œä»¥ä¾¿å°†æ¥å¯ä»¥ä»è¿™ä¸ªç‚¹æ¢å¤æ‰§è¡Œ if (getcontext(\u0026amp;ctx_) != 0) { std::cout \u0026lt;\u0026lt; \u0026#34;err: Coroutine::getcontext\\n\u0026#34;; exit(1); } // åˆå§‹åŒ–åç¨‹ä¸Šä¸‹æ–‡ ctx_.uc_link = nullptr; ctx_.uc_stack.ss_sp = pstack_; ctx_.uc_stack.ss_size = stack_size_; // ä¸ºå·²ç»åˆå§‹åŒ–çš„ä¸Šä¸‹æ–‡è®¾ç½®ä¸€ä¸ªå°†åœ¨è¯¥ä¸Šä¸‹æ–‡è¢«æ¿€æ´»æ—¶æ‰§è¡Œçš„å‡½æ•°ï¼Œå¹¶ä¸ºè¯¥å‡½æ•°ä¼ é€’å‚æ•°ã€‚ // ä¸ºä»€ä¹ˆè¿™é‡Œçš„ç¬¬äºŒä¸ªå‚æ•°ä¸ç›´æ¥è®¾ç½®æˆcallbackå‘¢ï¼Ÿæ˜¯å› ä¸ºæˆ‘ä»¬è‡ªå·±å†™åç¨‹çš„è¯ä¸ä»…ä»…åªè¦å°†ä»»åŠ¡å‡½æ•°æ‰§è¡Œå®Œæˆå°±è¡Œäº†ï¼Œæ‰§è¡Œå®Œæˆåè¿˜è¦è®¾ç½®åç¨‹çš„çŠ¶æ€ makecontext(\u0026amp;ctx_, \u0026amp;Coroutine::Task, 0); } // æ¯ä¸ªåç¨‹ä¼šè¿è¡Œå®ƒæ‰€ç»‘å®šçš„callbackï¼Œå¹¶ä¸”åœ¨æ‰§è¡Œå®Œæˆåå°†é‡ç½®è¯¥åç¨‹çš„çŠ¶æ€ï¼Œå¹¶è®©å‡ºæ‰§è¡Œæƒ void Coroutine::Task() { auto cur = GetNowCoroutine(); assert(cur); cur-\u0026gt;callback_(); cur-\u0026gt;callback_ = nullptr; cur-\u0026gt;state_ = FINISH; auto raw_ptr = cur.get(); cur.reset(); raw_ptr-\u0026gt;Yield(); } Yieldå’ŒResumeå‡½æ•°åˆ©ç”¨swapcontextæ¥è¿›è¡Œåç¨‹çš„åˆ‡æ¢ã€‚ç”±äºæˆ‘ä»¬åœ¨ä¹‹åä¼šéœ€è¦å°†åç¨‹æ·»åŠ åˆ°è°ƒåº¦å™¨ä¸­è€Œä¸æ˜¯æ‰‹åŠ¨è°ƒåº¦ï¼Œæ‰€ä»¥è¦æ³¨æ„åç¨‹æœ‰ä½¿ç”¨è°ƒåº¦å™¨æ ‡å¿—æ—¶è¦ä¸è°ƒåº¦å™¨åç¨‹è¿›è¡Œåˆ‡æ¢ï¼š\n// è®©å‡ºè¯¥åç¨‹çš„æ‰§è¡Œæƒï¼Œè½¬äº¤åˆ°ä¸»åç¨‹ void Coroutine::Yield() { assert(state_ == FINISH || state_ == RUNNING); SetNowCoroutine(main_coroutine.get()); if (state_ != FINISH) { state_ = READY; } if (is_run_in_sched_) { if (swapcontext(\u0026amp;ctx_, \u0026amp;(Scheduler::GetSchedCoroutine()-\u0026gt;ctx_)) != 0) { std::cout \u0026lt;\u0026lt; \u0026#34;err: Yield::swapcontext\\n\u0026#34;; assert(false); } } else { if (swapcontext(\u0026amp;ctx_, \u0026amp;(main_coroutine-\u0026gt;ctx_)) \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;err: Yield::swapcontext\\n\u0026#34;; exit(1); } } } // ä»å½“å‰è¿è¡Œçš„åç¨‹æ¢å¤åˆ°è¯¥åç¨‹ void Coroutine::Resume() { assert(state_ != FINISH \u0026amp;\u0026amp; state_ != RUNNING); // æ¯æ¬¡æ¢å¤æ—¶éœ€è¦å°†å½“å‰è¿è¡Œçš„åç¨‹è®¾ç½®ä¸ºè‡ªèº« SetNowCoroutine(this); state_ = RUNNING; if (is_run_in_sched_) { if (swapcontext(\u0026amp;(Scheduler::GetSchedCoroutine()-\u0026gt;ctx_), \u0026amp;ctx_) != 0) { std::cout \u0026lt;\u0026lt; \u0026#34;err: Resume::swapcontext\\n\u0026#34;; assert(false); } } else { if (swapcontext(\u0026amp;(main_coroutine-\u0026gt;ctx_), \u0026amp;ctx_) != 0) { std::cout \u0026lt;\u0026lt; \u0026#34;err: Resume::swapcontext\\n\u0026#34;; exit(1); } } } ","permalink":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-1%E5%8D%8F%E7%A8%8B%E5%AE%9A%E4%B9%89/","summary":"\u003cblockquote\u003e\n\u003cp\u003eã€åŠ¨æ‰‹å†™åç¨‹åº“ã€‘ç³»åˆ—ç¬”è®°æ˜¯å­¦ä¹ sylarçš„åç¨‹åº“æ—¶çš„è®°å½•ï¼Œå‚è€ƒäº†\u003ca href=\"https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952\"\u003eä»é›¶å¼€å§‹é‡å†™sylar C++é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡å™¨æ¡†æ¶\u003c/a\u003eå’Œä»£ç éšæƒ³å½•ä¸­çš„\u003ca href=\"https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F\"\u003eæ–‡æ¡£\u003c/a\u003eã€‚æ–‡ç« å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰ä»£ç çš„è¯¦ç»†è§£é‡Šï¼Œè€Œæ˜¯ä¸ºäº†è‡ªå·±ç†è§£ä¸€äº›ç‰‡æ®µæ‰€åšçš„ç¬”è®°ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCoroutine\u003c/code\u003eç±»ä¸­å…¶ä»–å‡½æ•°çš„å®šä¹‰å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ï¼š\u003ca href=\"https://github.com/kerolt/coroutine-lib/blob/master/src/coroutine.cpp\"\u003eGithub: src/coroutine.cpp\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eå¯¹äºä»€ä¹ˆæ˜¯åç¨‹ï¼Œä¸ºä»€ä¹ˆè¦ä½¿ç”¨åç¨‹ï¼Œå¯ä»¥çœ‹çœ‹ä¹‹å‰çš„ç¬”è®°ï¼š\u003ca href=\"https://kerolt.github.io/posts/f663291a/\"\u003eã€åç¨‹ã€‘C++20åç¨‹åˆä½“éªŒ\u003c/a\u003eã€‚\u003c/p\u003e\n\u003cp\u003eå¯¹äºæˆ‘ä»¬è‡ªå·±æ¥å®ç°åç¨‹ï¼Œå…¶å®åœ¨ä¹‹å‰Xv6çš„Labä¸­å°±æœ‰åšè¿‡ï¼š\u003ca href=\"https://kerolt.github.io/posts/cb4e63bc/#Uthread-switching-between-threads\"\u003eã€MIT6.S081ã€‘Lab6 multithreading\u003c/a\u003eï¼Œå½“åˆåšè¿™ä¸ªlabçš„æ—¶å€™æ²¡æœ‰æ„è¯†åˆ°è¿™å°±æ˜¯åç¨‹ã€‚åç¨‹çš„åˆ‡æ¢æœ€é‡è¦çš„å°±æ˜¯è¦ä¿å­˜å’Œæ¢å¤ä¸Šä¸‹æ–‡ï¼Œåœ¨è¿™ä¸ªlabä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ä¿å­˜æ¯ä¸ªåç¨‹åœ¨åˆ‡æ¢ä¹‹å‰çš„å¯„å­˜å™¨çš„å€¼ï¼Œä»¥æ­¤å¯ç”¨æ¥æ¢å¤åŸæ¥çš„æ‰§è¡Œæµã€‚\u003c/p\u003e","title":"ã€åŠ¨æ‰‹å†™åç¨‹åº“ 1ã€‘åç¨‹å®šä¹‰"},{"content":" Debianç³»Linuxå®‰è£…Nå¡é©±åŠ¨å‚è€ƒè¿™ç¯‡åšå®¢\næœ€è¿‘Debianç»ˆäºæ˜¯è£…å¥½nvidiaçš„é©±åŠ¨äº†ï¼Œä½†æ˜¯åªèƒ½ç”¨åœ¨X11ä¸Šï¼Œå¹¶ä¸”ç›¸æ¯”äºä¸ç”¨nå¡é©±åŠ¨æ—¶çš„Waylandï¼ŒX11ä¸‹çš„çª—å£æ‹–åŠ¨å’Œè§†é¢‘æ’­æ”¾ä¼šæœ‰æ¯”è¾ƒæ˜æ˜¾çš„æ’•è£‚æ„Ÿï¼Œä»¥ä¸‹æ˜¯è§£å†³çš„ä¸€ä¸ªæ–¹æ³•ã€‚\nä¿®æ”¹/etc/X11/xorg.confÂ æ–‡ä»¶ï¼Œåœ¨å±å¹•ç›¸å…³çš„åŒºåŸŸå†…åŠ ä¸Šï¼š\nOption \u0026#34;TripleBuffer\u0026#34; \u0026#34;true\u0026#34; Option \u0026#34;ForceFullCompositionPipeline\u0026#34; \u0026#34;on\u0026#34; Option \u0026quot;TripleBuffer\u0026quot; \u0026quot;true\u0026quot; å¯ç”¨ä¸‰é‡ç¼“å†²ï¼ˆTriple Bufferingï¼‰æ¥å‡å°‘å±å¹•æ’•è£‚ï¼Œå®ƒé€šè¿‡å¢åŠ ä¸€ä¸ªé¢å¤–çš„ç¼“å†²åŒºæ¥åŒæ­¥è§†é¢‘è¾“å‡ºå’Œæ˜¾ç¤ºå™¨çš„åˆ·æ–°ç‡ã€‚ Option \u0026quot;ForceFullCompositionPipeline\u0026quot; \u0026quot;on\u0026quot; ç”¨äºå¼ºåˆ¶ä½¿ç”¨å®Œæ•´çš„åˆæˆç®¡çº¿ï¼ˆFull Composition Pipelineï¼‰ã€‚å¯ç”¨è¿™ä¸ªé€‰é¡¹å¯ä»¥æé«˜æ€§èƒ½ï¼Œåœ¨æŸäº›æ¸¸æˆå’Œåº”ç”¨ç¨‹åºä¸­ï¼Œå®ƒå¯ä»¥å¸®åŠ©å‡å°‘å»¶è¿Ÿå’Œæé«˜å¸§ç‡ã€‚ ","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%A7%A3%E5%86%B3x11%E4%B8%8B%E7%AA%97%E5%8F%A3%E6%8B%96%E5%8A%A8%E6%92%95%E8%A3%82%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDebianç³»Linuxå®‰è£…Nå¡é©±åŠ¨å‚è€ƒè¿™ç¯‡\u003ca href=\"https://www.if-not-true-then-false.com/2021/debian-ubuntu-linux-mint-nvidia-guide/\"\u003eåšå®¢\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eæœ€è¿‘Debianç»ˆäºæ˜¯è£…å¥½nvidiaçš„é©±åŠ¨äº†ï¼Œä½†æ˜¯åªèƒ½ç”¨åœ¨X11ä¸Šï¼Œå¹¶ä¸”ç›¸æ¯”äºä¸ç”¨nå¡é©±åŠ¨æ—¶çš„Waylandï¼ŒX11ä¸‹çš„çª—å£æ‹–åŠ¨å’Œè§†é¢‘æ’­æ”¾ä¼šæœ‰æ¯”è¾ƒæ˜æ˜¾çš„æ’•è£‚æ„Ÿï¼Œä»¥ä¸‹æ˜¯è§£å†³çš„ä¸€ä¸ªæ–¹æ³•ã€‚\u003c/p\u003e","title":"è§£å†³X11ä¸‹çª—å£æ‹–åŠ¨æ’•è£‚çš„ä¸€ä¸ªæ–¹æ³•"},{"content":"æˆ‘ä»¬çŸ¥é“åœ¨C++20çš„åç¨‹ä¸­ï¼Œè‡ªå·±å®ç°çš„Coroutineä¸­å¿…é¡»åŒ…å«ä¸€ä¸ªPromiseï¼Œå¹¶ä¸”è¿™ä¸ªPromiseå¿…é¡»è¦å®ç°ï¼š\nget_return_object() initial_suspend() final_suspend() unhandled_exception() å°‘äº†å…¶ä¸­ä»»ä½•ä¸€ä¸ªï¼Œç¼–è¯‘å™¨éƒ½ä¼šæŠ¥é”™ã€‚é‚£è¿™æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿå¦‚æœæ˜¯åƒjavaé‚£æ ·æ˜¯ä¸€ä¸ªæ¥å£è€Œæ²¡æœ‰å¯¹åº”çš„å®ç°ä»è€ŒæŠ¥é”™è¿˜èƒ½ç†è§£ï¼Œä½†æ˜¯æˆ‘ä»¬çš„ä»£ç ä¸­çš„Promiseå®Œå®Œå…¨å…¨æ˜¯æˆ‘ä»¬è‡ªå·±å†™çš„ï¼Œä¹Ÿæ²¡æœ‰ä½¿ç”¨ç»§æ‰¿ï¼Œç¼–è¯‘å™¨ä½ æ€ä¹ˆçŸ¥é“æˆ‘åœ¨å®ç°åç¨‹æ—¶å°‘äº†ä»€ä¹ˆä¸œè¥¿å‘¢ï¼Ÿ\nç­”æ¡ˆå°±æ˜¯ï¼šSFINAEï¼ˆSubstitution Failure Is Not An Errorï¼Œæ›¿æ¢å¤±è´¥ä¸æ˜¯é”™è¯¯ï¼‰ã€‚\nSFINAE ä¸»è¦åº”ç”¨äºå‡½æ•°æ¨¡æ¿çš„é‡è½½è§£æè¿‡ç¨‹ä¸­ã€‚å½“ç¼–è¯‘å™¨å°è¯•é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„å‡½æ•°æ¨¡æ¿é‡è½½ç‰ˆæœ¬æ—¶ï¼Œå¦‚æœæŸä¸ªæ¨¡æ¿å‚æ•°çš„æ›¿æ¢å¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œç¼–è¯‘å™¨ä¸ä¼šç«‹å³æŠ¥é”™ï¼Œè€Œæ˜¯ç»§ç»­å°è¯•å…¶ä»–å¯èƒ½çš„é‡è½½ç‰ˆæœ¬ã€‚\nåœ¨ C++20 åç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®åç¨‹å‡½æ•°çš„å®šä¹‰å’ŒÂ promise_typeÂ çš„å®ç°æ¥ç”Ÿæˆåç¨‹çš„æ‰§è¡Œä»£ç ã€‚promise_typeÂ æ˜¯ä¸€ä¸ªç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼Œå®ƒå¿…é¡»æä¾›ä¸€äº›ç‰¹å®šçš„å‡½æ•°ï¼Œå¦‚Â get_return_objectã€initial_suspendã€final_suspendã€unhandled_exceptionÂ å’ŒÂ return_valueÂ ç­‰ã€‚è¿™äº›å‡½æ•°å®šä¹‰äº†åç¨‹çš„è¡Œä¸ºå’ŒçŠ¶æ€ï¼Œç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æœŸæ£€æŸ¥è¿™äº›å‡½æ•°çš„å­˜åœ¨æ€§å’Œæ­£ç¡®æ€§ï¼Œä»¥ç¡®ä¿åç¨‹èƒ½å¤Ÿæ­£ç¡®åœ°æ‰§è¡Œã€‚\nç¼–è¯‘å™¨ä½¿ç”¨ SFINAE æœºåˆ¶æ¥æ£€æŸ¥Â promise_typeÂ ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šçš„å‡½æ•°ã€‚å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯ç¼–è¯‘å™¨ä¼šåœ¨åç¨‹çš„å®ç°ä»£ç ä¸­ä½¿ç”¨è¡¨è¾¾å¼ SFINAEï¼Œå°è¯•è°ƒç”¨è¿™äº›å‡½æ•°ï¼Œå¹¶æ ¹æ®è°ƒç”¨çš„ç»“æœæ¥ç¡®å®šå‡½æ•°çš„å­˜åœ¨æ€§ã€‚\næˆ‘ä»¬æ¥å†™ä¸ªç®€å•çš„ä¾‹å­ï¼Œåªæ£€æŸ¥get_return_objectå‡½æ•°ï¼š\n#include \u0026lt;type_traits\u0026gt; /* * check(int) æ˜¯ä¸€ä¸ªé‡è½½çš„æ¨¡æ¿å‡½æ•°ï¼Œç”¨äºæ£€æŸ¥Uç±»å‹æ˜¯å¦æœ‰get_return_object()å‡½æ•°ã€‚ * decltype(std::declval\u0026lt;U\u0026gt;().get_return_object(), std::true_type{}) ä¼šåœ¨Uå…·æœ‰get_return_object()æ—¶è¿”å›std::true_typeã€‚ * å¦‚æœUæ²¡æœ‰get_return_object()ï¼Œåˆ™ä¼šåŒ¹é…check(...)é‡è½½ï¼Œè¿”å›std::false_typeã€‚ * valueæˆå‘˜æ˜¯ä¸€ä¸ªå¸¸é‡å¸ƒå°”å€¼ï¼ŒæŒ‡ç¤ºTæ˜¯å¦å…·æœ‰get_return_object()å‡½æ•°ã€‚ */ template \u0026lt;typename T\u0026gt; struct has_get_return_object { template \u0026lt;typename U\u0026gt; static auto check(int) -\u0026gt; decltype(std::declval\u0026lt;U\u0026gt;().get_return_object(), std::true_type{}); template \u0026lt;typename\u0026gt; static std::false_type check(...); static constexpr bool value = decltype(check\u0026lt;T\u0026gt;(0))::value; }; template \u0026lt;typename T\u0026gt; void check_promise_type() { static_assert(has_get_return_object\u0026lt;T\u0026gt;::value, \u0026#34;Promise type must have a get_return_object() method.\u0026#34;); } struct MyCoroutine { struct promise_type { MyCoroutine get_return_object() { return {}; } }; }; int main() { check_promise_type\u0026lt;MyCoroutine::promise_type\u0026gt;(); } å½“æˆ‘ä»¬å»æ‰Mycoroutine::promise_typeä¸­çš„get_return_objectå‡½æ•°æ—¶ï¼Œcheck_promise_typeå‡½æ•°ä¸­å°±ä¼šå‡ºå‘æ–­è¨€å¤±è´¥ï¼Œä»è€Œç¼–è¯‘ä¸é€šè¿‡ã€‚\nè¿™ä¹Ÿå°±æ˜¯åœ¨å°†ä¸€ä¸ªå‡½æ•°å˜ä¸ºåç¨‹æ—¶ç¼–è¯‘å™¨æ˜¯å¦‚ä½•æ£€æŸ¥çš„ä¸€ä¸ªå¤§æ¦‚æ€è·¯äº†ã€‚ä¸å¾—ä¸æ„Ÿå¹ï¼ŒC++çœŸæ˜¯åšå¤§ç²¾æ·±ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/%E5%8D%8F%E7%A8%8Bc++%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87sfinae%E6%9D%A5%E6%A3%80%E6%9F%A5promise_type%E7%9A%84/","summary":"\u003cp\u003eæˆ‘ä»¬çŸ¥é“åœ¨C++20çš„åç¨‹ä¸­ï¼Œè‡ªå·±å®ç°çš„Coroutineä¸­å¿…é¡»åŒ…å«ä¸€ä¸ª\u003ccode\u003ePromise\u003c/code\u003eï¼Œå¹¶ä¸”è¿™ä¸ª\u003ccode\u003ePromise\u003c/code\u003eå¿…é¡»è¦å®ç°ï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eget_return_object()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einitial_suspend()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efinal_suspend()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunhandled_exception()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eå°‘äº†å…¶ä¸­ä»»ä½•ä¸€ä¸ªï¼Œç¼–è¯‘å™¨éƒ½ä¼šæŠ¥é”™ã€‚é‚£è¿™æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿå¦‚æœæ˜¯åƒjavaé‚£æ ·æ˜¯ä¸€ä¸ªæ¥å£è€Œæ²¡æœ‰å¯¹åº”çš„å®ç°ä»è€ŒæŠ¥é”™è¿˜èƒ½ç†è§£ï¼Œä½†æ˜¯æˆ‘ä»¬çš„ä»£ç ä¸­çš„\u003ccode\u003ePromise\u003c/code\u003eå®Œå®Œå…¨å…¨æ˜¯æˆ‘ä»¬è‡ªå·±å†™çš„ï¼Œä¹Ÿæ²¡æœ‰ä½¿ç”¨ç»§æ‰¿ï¼Œç¼–è¯‘å™¨ä½ æ€ä¹ˆçŸ¥é“æˆ‘åœ¨å®ç°åç¨‹æ—¶å°‘äº†ä»€ä¹ˆä¸œè¥¿å‘¢ï¼Ÿ\u003c/p\u003e\n\u003cp\u003eç­”æ¡ˆå°±æ˜¯ï¼š\u003cstrong\u003eSFINAE\u003c/strong\u003eï¼ˆSubstitution Failure Is Not An Errorï¼Œæ›¿æ¢å¤±è´¥ä¸æ˜¯é”™è¯¯ï¼‰ã€‚\u003c/p\u003e","title":"ã€åç¨‹ã€‘C++æ˜¯å¦‚ä½•é€šè¿‡SFINAEæ¥æ£€æŸ¥promise_typeçš„"},{"content":"å‰è¨€ æš‘å‡é‡Œè·Ÿç€é±¼çš®çš„yuindexé¡¹ç›®å†™äº†ä¸ªwebç»ˆç«¯çš„å°ç©å…·ï¼Œå®Œæˆçš„ç»ˆç«¯å‘½ä»¤ä¸å¤šï¼Œä½†æ˜¯å¤§ä½“ä¸Šæˆå‹äº†ã€‚ç”±äºæˆ‘æ‰“ç®—åšä¸€ä¸ªçº¯å‰ç«¯çš„é¡¹ç›®ï¼Œå¹¶æ²¡æœ‰å†™åç«¯apiï¼Œè¿™æ ·ä¹Ÿæ–¹ä¾¿æˆ‘æœ€ç»ˆç›´æ¥éƒ¨ç½²åˆ°Github Pagesä¸Šï¼ˆè¿™æ ·å°±ä¸ç”¨èŠ±é’±äº†hhï¼‰ã€‚\né¡¹ç›®ä½¿ç”¨viteæ„å»ºï¼Œå¹¶ä½¿ç”¨äº†tsã€‚åœ¨æ„å»ºéƒ¨ç½²æ—¶é‡åˆ°äº†ä¸€äº›é—®é¢˜ï¼Œç”±äºæ˜¯ç¬¬ä¸€æ¬¡å°†å‰ç«¯é¡¹ç›®å‘å¸ƒåˆ°github pagesä¸Šï¼Œè¿™é‡Œè®°å½•ä¸‹ã€‚\nç”Ÿæˆäº†é¢å¤–çš„æºæ˜ å°„æ–‡ä»¶ ä¾‹å¦‚åœ¨æ‰§è¡Œäº†pnpm run buildåï¼Œè™½ç„¶ç”Ÿæˆäº†distæ–‡ä»¶å¤¹å’Œå…¶ä¸­çš„å†…å®¹ï¼Œä½†æ˜¯æºæ–‡ä»¶ä¸­çš„.tsæ–‡ä»¶ä¼šé¢å¤–ç”Ÿæˆ.jså’Œ.js.mapæ–‡ä»¶ï¼Œ.vueæ–‡ä»¶ä¼šé¢å¤–ç”Ÿæˆ.vue.jså’Œ.vue.js.mapæ–‡ä»¶ï¼š\nå¾ˆæ˜æ˜¾è¿™äº›é¢å¤–ç”Ÿæˆçš„æ–‡ä»¶æˆ‘ä»¬åœ¨å‘å¸ƒéƒ¨ç½²é¡¹ç›®æ—¶ç”¨ä¸ä¸Šï¼Œè€Œä¸”ä¹Ÿæ— éœ€æäº¤åˆ°gitä¸Šã€‚æ‘¸ç´¢ä¸€ç•ªåï¼ŒçŸ¥é“äº†è¿™æ˜¯TypeScriptç¼–è¯‘å™¨ç”Ÿæˆçš„ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹é¡¹ç›®çš„tsconfig.jsonæ–‡ä»¶ã€‚\nå¯¹äº.mapæ–‡ä»¶ï¼š\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;sourceMap\u0026#34;: false } } å¯¹äºtsç”Ÿæˆçš„å¯¹åº”çš„jsæ–‡ä»¶ï¼š\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;allowJs\u0026#34;: false, // ç¦æ­¢ç¼–è¯‘JSæ–‡ä»¶ \u0026#34;noEmit\u0026#34;: true, // ä»…è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œè€Œä¸è¾“å‡ºä»»ä½•æ–‡ä»¶ } } å¦‚ä½•éƒ¨ç½²åˆ°Github Pages åœ¨è§£å†³å®Œå‰é¢çš„é—®é¢˜åï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†distç›®å½•æäº¤åˆ°githubä¸Šäº†ï¼ˆè®°ä½è¦åœ¨.gitignoreæ–‡ä»¶ä¸­æ’é™¤distç›®å½•ï¼‰ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ï¼š\ngit subtree push --prefix dist origin gh-pages è¿™ä¼šå°†é¡¹ç›®çš„å­ç›®å½•distæ¨é€åˆ°è¿œç¨‹ä»“åº“çš„gh-pagesåˆ†æ”¯ï¼Œå¦‚æœè¿œç¨‹ä»“åº“æ²¡æœ‰gh-pagesåˆ†æ”¯ï¼ŒGit ä¼šè‡ªåŠ¨åˆ›å»ºå®ƒå¹¶æ¨é€å†…å®¹ã€‚\næ¥ç€åœ¨Githubä»“åº“çš„Settingsä¸­è®¾ç½®éƒ¨ç½²çš„ä½ç½®ï¼š\nGithub Pagesé¡¹ç›®è·¯å¾„é”™è¯¯ ç”±äºkerolt.github.ioç”¨ä½œäº†æˆ‘çš„åšå®¢ï¼Œè¿™ä¸ªé¡¹ç›®åªèƒ½ä½œä¸ºå­é¡¹æ¥éƒ¨ç½²ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡kerolt.github.io/web-terminalæ¥è®¿é—®ã€‚å®Œæˆå‰é¢çš„æ­¥éª¤åï¼Œæˆ‘è™½ç„¶èƒ½è®¿é—®ï¼Œä½†æ˜¯å…¶ä¸­çš„å†…å®¹æ— æ³•æ˜¾ç¤ºï¼Œå…¶åŸå› ä¸ºæ— æ³•æ­£ç¡®è·å–å¯¹åº”çš„æ–‡ä»¶ã€‚\nè¿™æ˜¯å› ä¸ºç›¸å½“äºæ˜¯åœ¨åµŒå¥—çš„å…¬å…±è·¯å¾„ä¸‹éƒ¨ç½²é¡¹ç›®ï¼Œåœ¨viteä¸­éœ€æŒ‡å®šÂ baseÂ é…ç½®é¡¹ï¼š\n// vite.config.ts export default defineConfig({ base: \u0026#34;/web-terminal/\u0026#34;, // ... }); è‡³æ­¤ï¼Œé¡¹ç›®å·²ç»å¯ä»¥é€šè¿‡https://kerolt.github.io/web-terminal/æ¥è®¿é—®ã€‚\n","permalink":"https://kerolt.github.io/posts/%E5%89%8D%E7%AB%AF/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E7%9A%84%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eæš‘å‡é‡Œè·Ÿç€é±¼çš®çš„\u003ccode\u003eyuindex\u003c/code\u003eé¡¹ç›®å†™äº†ä¸ªwebç»ˆç«¯çš„å°ç©å…·ï¼Œå®Œæˆçš„ç»ˆç«¯å‘½ä»¤ä¸å¤šï¼Œä½†æ˜¯å¤§ä½“ä¸Šæˆå‹äº†ã€‚ç”±äºæˆ‘æ‰“ç®—åšä¸€ä¸ªçº¯å‰ç«¯çš„é¡¹ç›®ï¼Œå¹¶æ²¡æœ‰å†™åç«¯apiï¼Œè¿™æ ·ä¹Ÿæ–¹ä¾¿æˆ‘æœ€ç»ˆç›´æ¥éƒ¨ç½²åˆ°\u003cstrong\u003eGithub Pages\u003c/strong\u003eä¸Šï¼ˆè¿™æ ·å°±ä¸ç”¨èŠ±é’±äº†hhï¼‰ã€‚\u003c/p\u003e\n\u003cp\u003eé¡¹ç›®ä½¿ç”¨viteæ„å»ºï¼Œå¹¶ä½¿ç”¨äº†tsã€‚åœ¨æ„å»ºéƒ¨ç½²æ—¶é‡åˆ°äº†ä¸€äº›é—®é¢˜ï¼Œç”±äºæ˜¯ç¬¬ä¸€æ¬¡å°†å‰ç«¯é¡¹ç›®å‘å¸ƒåˆ°github pagesä¸Šï¼Œè¿™é‡Œè®°å½•ä¸‹ã€‚\u003c/p\u003e","title":"è®°ä¸€æ¬¡é¡¹ç›®æ„å»ºéƒ¨ç½²çš„æ€»ç»“"},{"content":"åœ¨ä½¿ç”¨æ‰‹æœºæµè§ˆå™¨æœç´¢æ—¶ä¸ºäº†å…äºCSDNåƒåœ¾ä¿¡æ¯çš„å½±å“ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Bingï¼ˆå…¶ä»–æœç´¢å¼•æ“ä¹Ÿæœ‰ç±»ä¼¼çš„åŠŸèƒ½ï¼Œä½†æ˜¯å›½å†…ä¸å€ŸåŠ©å…¶ä»–æ–¹æ³•çš„æƒ…å†µä¸‹ä½“éªŒæ„Ÿæœ€å¥½çš„ä¹Ÿåªæœ‰Bingäº†ï¼‰çš„â€œ-site:*.csdn.netâ€æ¥å±è”½CSDNï¼Œä½†æ˜¯æ¯æ¬¡è¾“å…¥æœç´¢å†…å®¹åè¿˜è¦åŠ è¿™ä¹ˆä¸€ä¸ªå­—ç¬¦ä¸²çœŸæ˜¯å¤ªéº»çƒ¦äº†ï¼Œå› æ­¤å¯ä»¥å†™ä¸€ä¸ªæµè§ˆå™¨è„šæœ¬æ¥å®Œæˆè¿™ä¸€æ“ä½œã€‚\nåœ¨PCä¸Šå¯ä»¥ç›´æ¥ä½¿ç”¨æ²¹çŒ´ä¸­å…¶ä»–å¤§ä½¬å†™çš„è„šæœ¬ï¼Œè€Œæˆ‘åœ¨æ‰‹æœºä¸Šä½¿ç”¨Viaæµè§ˆå™¨æ—¶ä¸ä¸€å®šèƒ½ç”¨ï¼ˆå¯èƒ½å¯ä»¥ï¼Œä¸è¿‡æˆ‘è¿˜æ²¡è¯•ï½ï¼‰è¿™äº›è„šæœ¬ï¼ŒåŒæ—¶æˆ‘éœ€è¦çš„åŠŸèƒ½æ¯”è¾ƒç®€å•ï¼Œæ•…å†™ä¸€ä¸ªViaæµè§ˆå™¨çš„è„šæœ¬ã€‚\nå…¶å®ä¸»è¦å°±æ˜¯ä¸€ä¸ªç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œå…¶ä¸­å¯¹äºè¾“å…¥æ¡†æ³¨å†Œäº†keydownçš„äº‹ä»¶ï¼Œå½“æŒ‰ä¸‹å›è½¦é”®æ—¶å¯ä»¥åœ¨è¾“å…¥æ¡†çš„æ–‡æœ¬åæ·»åŠ -site:*.csdn.netã€‚éœ€è¦æ³¨æ„çš„æ˜¯éœ€è¦ä½¿ç”¨preventDefault()æ–¹æ³•æ¥é˜²æ­¢é»˜è®¤çš„è¡¨å•æäº¤åŠ¨ä½œï¼š\n// ==UserScript== // @name Bing CSDN Filter // @namespace https://viayoo.com/ // @version 0.0 // @description è‡ªåŠ¨åœ¨Bingæœç´¢æ¡†è¾“å…¥å†…å®¹åæ·»åŠ -csdnï¼Œå±è”½CSDNå†…å®¹ // @author kerolt // @match https://*.bing.com/* // @grant none // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; // è·å–æœç´¢æ¡†ä¸­çš„textareaå…ƒç´  let searchInput = document.querySelector(\u0026#39;textarea[name=\u0026#34;q\u0026#34;]\u0026#39;); if (searchInput) { // ç›‘å¬æœç´¢æ¡†ä¸­çš„æŒ‰é”®äº‹ä»¶ searchInput.addEventListener(\u0026#39;keydown\u0026#39;, function(event) { // æ£€æŸ¥æ˜¯å¦æŒ‰ä¸‹å›è½¦é”® if (event.key === \u0026#39;Enter\u0026#39;) { // å¦‚æœè¾“å…¥ä¸­æ²¡æœ‰-site:*.csdn.netï¼Œè‡ªåŠ¨æ·»åŠ  if (!searchInput.value.includes(\u0026#39;-site:*.csdn.net\u0026#39;)) { searchInput.value += \u0026#39; -site:*.csdn.net\u0026#39;; } // æäº¤è¡¨å•ï¼Œè¿›è¡Œæœç´¢ event.preventDefault(); // é˜²æ­¢é»˜è®¤çš„è¡¨å•æäº¤åŠ¨ä½œ let searchForm = searchInput.closest(\u0026#39;form\u0026#39;); if (searchForm) { searchForm.submit(); // æ‰‹åŠ¨æäº¤è¡¨å• } } }); } })(); ","permalink":"https://kerolt.github.io/posts/%E5%89%8D%E7%AB%AF/%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC%E6%9D%A5%E5%B1%8F%E8%94%BDcsdn/","summary":"\u003cp\u003eåœ¨ä½¿ç”¨æ‰‹æœºæµè§ˆå™¨æœç´¢æ—¶ä¸ºäº†å…äºCSDNåƒåœ¾ä¿¡æ¯çš„å½±å“ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Bingï¼ˆå…¶ä»–æœç´¢å¼•æ“ä¹Ÿæœ‰ç±»ä¼¼çš„åŠŸèƒ½ï¼Œä½†æ˜¯å›½å†…ä¸å€ŸåŠ©å…¶ä»–æ–¹æ³•çš„æƒ…å†µä¸‹ä½“éªŒæ„Ÿæœ€å¥½çš„ä¹Ÿåªæœ‰Bingäº†ï¼‰çš„â€œ\u003ccode\u003e-site:*.csdn.net\u003c/code\u003eâ€æ¥å±è”½CSDNï¼Œä½†æ˜¯æ¯æ¬¡è¾“å…¥æœç´¢å†…å®¹åè¿˜è¦åŠ è¿™ä¹ˆä¸€ä¸ªå­—ç¬¦ä¸²çœŸæ˜¯å¤ªéº»çƒ¦äº†ï¼Œå› æ­¤å¯ä»¥å†™ä¸€ä¸ªæµè§ˆå™¨è„šæœ¬æ¥å®Œæˆè¿™ä¸€æ“ä½œã€‚\u003c/p\u003e","title":"å†™ä¸€ä¸ªç®€å•çš„æµè§ˆå™¨è„šæœ¬æ¥å±è”½CSDN"},{"content":"åœ¨ç”¨C++åˆ·leetcodeæ—¶ï¼Œæˆ‘å¸Œæœ›æŠŠä¸€ä¸ªé€’å½’å‡½æ•°åƒjsã€pythoné‚£æ ·å†™åœ¨è¿è¡Œå‡½æ•°å†…éƒ¨ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨functionå’Œlambdaè¡¨è¾¾å¼æ¥å®ç°ã€‚ä½†å¦‚æœè¿™ä¸ªé€’å½’å‡½æ•°çš„å‚æ•°æ¯”è¾ƒå¤šï¼Œé‚£ä¹ˆfunctionçš„æ¨¡æ¿å‚æ•°åŒæ ·éœ€è¦å†™å¾ˆå¤šï¼Œèƒ½ä¸èƒ½ç”¨autoæ¥å®ç°å¾—ç®€å•ä¸€ç‚¹å‘¢ï¼Ÿ\nåœ¨C++ä¸­ï¼Œä½¿ç”¨lambdaè¡¨è¾¾å¼å®ç°é€’å½’æ—¶ï¼Œç”±äºlambdaæœ¬èº«æ²¡æœ‰æ˜¾å¼çš„ç±»å‹åï¼Œéœ€è¦é€šè¿‡ä¸€äº›æŠ€å·§æ¥å®ç°é€’å½’è°ƒç”¨ã€‚ä½¿ç”¨auto\u0026amp;\u0026amp;ä½œä¸ºå‚æ•°ç±»å‹æ˜¯å…¶ä¸­ä¸€ç§å¸¸è§çš„åšæ³•ï¼š\nLambdaè¡¨è¾¾å¼çš„ç±»å‹æ¨æ–­ï¼šC++ä¸­çš„lambdaè¡¨è¾¾å¼æ²¡æœ‰ç±»å‹åï¼Œæ„å‘³ç€æ— æ³•ç›´æ¥åœ¨lambdaå†…éƒ¨è°ƒç”¨è‡ªèº«ã€‚å¦‚æœç›´æ¥å°†lambdaè¡¨è¾¾å¼å®šä¹‰ä¸ºé€’å½’å‡½æ•°ï¼Œä¼šé‡åˆ°æ— æ³•è¯†åˆ«çš„ç¼–è¯‘é”™è¯¯ã€‚\n#include \u0026lt;iostream\u0026gt; int main() { auto factorial = [](auto\u0026amp;\u0026amp; self, int n) -\u0026gt; int { if (n \u0026lt;= 1) return 1; return n * self(self, n - 1); // é€’å½’è°ƒç”¨lambda }; std::cout \u0026lt;\u0026lt; factorial(factorial, 5) \u0026lt;\u0026lt; std::endl; // è¾“å‡º120 return 0; } è¿™é‡Œä¸åƒjsã€pythonç›´æ¥å®šä¹‰å°±å¥½äº†ï¼Œè¿˜éœ€è¦å¤šå†™ä¸€ä¸ªé€šç”¨å¼•ç”¨ï¼ˆä»€ä¹ˆæ˜¯é€šç”¨å¼•ç”¨ï¼Œå¯å‚è€ƒè¿™ç¯‡åšå®¢ï¼‰ï¼Œå…·ä½“ä¸ºä»€ä¹ˆæˆ‘ä¹Ÿæš‚æ—¶ä¸æ¸…æ¥šï¼ŒåªçŸ¥é“å’ŒYç»„åˆå­çš„çŸ¥è¯†ç‚¹æœ‰å…³ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/c++%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8lambda%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92/","summary":"\u003cp\u003eåœ¨ç”¨C++åˆ·leetcodeæ—¶ï¼Œæˆ‘å¸Œæœ›æŠŠä¸€ä¸ªé€’å½’å‡½æ•°åƒjsã€pythoné‚£æ ·å†™åœ¨è¿è¡Œå‡½æ•°å†…éƒ¨ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨\u003ccode\u003efunction\u003c/code\u003eå’Œ\u003ccode\u003elambdaè¡¨è¾¾å¼\u003c/code\u003eæ¥å®ç°ã€‚ä½†å¦‚æœè¿™ä¸ªé€’å½’å‡½æ•°çš„å‚æ•°æ¯”è¾ƒå¤šï¼Œé‚£ä¹ˆfunctionçš„æ¨¡æ¿å‚æ•°åŒæ ·éœ€è¦å†™å¾ˆå¤šï¼Œèƒ½ä¸èƒ½ç”¨\u003ccode\u003eauto\u003c/code\u003eæ¥å®ç°å¾—ç®€å•ä¸€ç‚¹å‘¢ï¼Ÿ\u003c/p\u003e","title":"C++ä¸­å¦‚ä½•ä½¿ç”¨lambdaå®ç°é€’å½’"},{"content":"ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦åç¨‹ï¼Ÿ ä¸ºä»€ä¹ˆæˆ‘ä»¬æœ‰äº†çº¿ç¨‹è¿˜éœ€è¦åç¨‹å‘¢ï¼Ÿï¼ˆå…¶å®è¿™ä¸ªé—®é¢˜ä¸åº”è¯¥è¿™ä¹ˆé—®ï¼Œåç¨‹çš„å‡ºç°åœ¨çº¿ç¨‹ä¹‹å‰ï¼‰åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­è™½ç„¶æˆ‘ä»¬å¯ä»¥åˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­èƒ½åˆ›å»ºçš„çº¿ç¨‹æ•°é‡æ˜¯æœ‰é™åˆ¶çš„ï¼Œå¹¶ä¸”çº¿ç¨‹çš„è°ƒåº¦ä»ç„¶å—æ“ä½œç³»ç»Ÿæ§åˆ¶ï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹ä½•æ—¶æŠ¢å ã€ä½•æ—¶è¢«æŠ¢å å¯¹äºå¼€å‘è€…æ¥è¯´éƒ½æ˜¯é€æ˜çš„ï¼Œå¹¶ä¸”åœ¨è°ƒåº¦çš„è¿‡ç¨‹ä¸­è¿˜å¯èƒ½æ¶‰åŠåˆ°ç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„åˆ‡æ¢å¼€é”€ã€‚\nå½“æˆ‘ä»¬éœ€è¦å»å¤„ç†ä¸€ä¸ªéå¸¸è€—æ—¶çš„IOæ“ä½œæ—¶ï¼ˆå‡è®¾ä½¿ç”¨çš„é˜»å¡IOï¼‰ï¼Œä¸ºäº†ä¸é˜»å¡å½“å‰çº¿ç¨‹ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæƒ³åˆ°æ–°å»ºä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œè¿™ä¸ªæ“ä½œï¼Œä½†æ˜¯çº¿ç¨‹çš„åˆ›å»ºå’Œè°ƒåº¦ä¹Ÿæ˜¯éœ€è¦æ¶ˆè€—èµ„æºçš„ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰æ›´åŠ è½»ä¾¿çš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼šåœ¨å½“å‰çº¿ç¨‹ä¸­ï¼Œä¸€ä¸ªä»»åŠ¡é‡åˆ°é˜»å¡IOæ—¶ï¼Œä¸è¦å‚»å‚»çš„åœåœ¨è¿™é‡Œï¼Œè€Œæ˜¯æš‚åœè¿™ä¸ªä»»åŠ¡ï¼Œè½¬è€Œå»æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼Œç›´åˆ°IOå®Œæˆå†æ¢å¤ä¹‹å‰çš„ä»»åŠ¡æ¥è¿è¡Œã€‚\nè¿™é‡Œçœ‹èµ·æ¥æ˜¯ä¸æ˜¯åƒä¸¤ä¸ªå‡½æ•°ä¹‹é—´çš„è°ƒç”¨å’Œè¢«è°ƒç”¨å…³ç³»ï¼Ÿç¡®å®æœ‰ç‚¹åƒï¼Œä½†åŒºåˆ«å¯å¤§äº†ï¼Œåœ¨ä»»åŠ¡1ä¸­æˆ‘ä»¬å¹¶æ²¡æœ‰å»æ˜¾å¼åœ°è°ƒç”¨ä»»åŠ¡2ï¼\nåç¨‹çš„æœ€æœ¬è´¨çš„è§£é‡Šæ˜¯â€œå¯ä»¥æŒ‚èµ·å’Œæ¢å¤çš„å‡½æ•°â€ã€‚ä¾‹å¦‚ä¸Šå›¾ä¸­æˆ‘ä»¬é‡åˆ°è€—æ—¶çš„IOæ“ä½œäº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸»åŠ¨å°†å½“å‰è¿è¡Œçš„å‡½æ•°æŒ‚èµ·ï¼ˆsuspendï¼‰ï¼Œè®©å…¶ç­‰å¾…ï¼ˆawaitï¼‰IOæ“ä½œï¼Œè®©çº¿ç¨‹å»è¿è¡Œå…¶ä»–çš„å‡½æ•°ï¼Œç›´åˆ°IOæ“ä½œå®Œæˆåå†æ¢å¤ï¼ˆresumeï¼‰ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ—¶æœºæ˜¯é è°ƒç”¨æ–¹ï¼ˆå†™ä»£ç çš„å¼€å‘äººå‘˜ï¼‰è‡ªèº«å»æ§åˆ¶çš„ï¼Œè¿™æ ·åç¨‹çš„è°ƒåº¦æŒæ¡åœ¨æˆ‘ä»¬è‡ªå·±æ‰‹ä¸­ï¼Œç›¸æ¯”ä¸çº¿ç¨‹å‡å°äº†ç³»ç»Ÿåˆ‡æ¢ä¸Šä¸‹æ–‡å’Œå…¶ä»–èµ„æºçš„å¼€é”€ã€‚å› æ­¤åç¨‹åœ¨éœ€è¦å¤„ç†å¤§é‡I/Oæ“ä½œæˆ–è€…å¹¶å‘ä»»åŠ¡çš„æƒ…å†µä¸‹æé«˜ç¨‹åºçš„æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚\nC++20å¸¦æ¥çš„åç¨‹ C++20å¸¦æ¥çš„åç¨‹å¹¶ä¸åƒpythonæˆ–luaä¸­çš„é‚£ä¹ˆæ˜“ç”¨ï¼Œç›¸åï¼ŒC++ç»™æˆ‘ä»¬æä¾›çš„æ˜¯æ›´ä¸ºåº•å±‚çš„æ“ä½œï¼ˆä¸è¿‡C++23å·²ç»æœ‰std::generatorè¿™ç§æ›´é«˜çº§çš„æŠ½è±¡ï¼Œä¹‹åä¹Ÿä¼šæœ‰æ›´å¤šä¸°å¯Œçš„ç”¨æ³•ï¼‰ã€‚\nC++åç¨‹ä¸­æœ‰å¾ˆé‡è¦çš„ä¸‰ä¸ªæ¦‚å¿µï¼š\nPromise Awaitable Coroutine Handle Promise promise_type æ˜¯æ¯ä¸ªåç¨‹å‡½æ•°çš„å¹•åæ‰§è¡Œå¯¹è±¡ã€‚å®ƒä¸»è¦è´Ÿè´£ä»¥ä¸‹å‡ ä¸ªä»»åŠ¡ï¼š\nåˆ›å»ºå’Œåˆå§‹åŒ–åç¨‹ï¼šå½“åç¨‹å¼€å§‹æ‰§è¡Œæ—¶ï¼Œç¼–è¯‘å™¨ä¼šé€šè¿‡ promise_type åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶è°ƒç”¨å…¶ get_return_object() æ–¹æ³•æ¥è·å–åç¨‹çš„è¿”å›å¯¹è±¡ã€‚ å¤„ç†åç¨‹çš„æš‚åœå’Œæ¢å¤ï¼šåç¨‹åœ¨æš‚åœæ—¶ä¼šè°ƒç”¨ yield_value() æˆ– await_suspend() ç­‰æ–¹æ³•æ¥å¤„ç†åç¨‹çš„çŠ¶æ€ï¼Œå¹¶å†³å®šä½•æ—¶æ¢å¤ã€‚ å¤„ç†åç¨‹çš„ç»“æŸï¼šå½“åç¨‹æ‰§è¡Œç»“æŸæ—¶ï¼Œreturn_void() æˆ– return_value() ä¼šè¢«è°ƒç”¨ï¼Œæ¥å¤„ç†åç¨‹çš„è¿”å›ç»“æœã€‚ ä»¥ä¸‹æ˜¯ promise_type ä¸­ä¸€äº›å¸¸è§çš„æ–¹æ³•ï¼š\nget_return_object()ï¼šç”¨äºåˆ›å»ºå’Œè¿”å›åç¨‹çš„è¿”å›å¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯åç¨‹è¿”å›ç±»å‹çš„å®ä¾‹ã€‚ initial_suspend()ï¼šè¿”å›ä¸€ä¸ª std::suspend_always æˆ– std::suspend_neverï¼Œå†³å®šåç¨‹åœ¨å¯åŠ¨æ—¶æ˜¯å¦ç«‹å³æš‚åœã€‚ final_suspend()ï¼šè¿”å›ä¸€ä¸ª std::suspend_always æˆ– std::suspend_neverï¼Œå†³å®šåç¨‹åœ¨ç»“æŸæ—¶æ˜¯å¦æš‚åœï¼Œä»¥å…è®¸è°ƒç”¨æ–¹æ‰§è¡Œæ¸…ç†æ“ä½œã€‚ return_void() æˆ– return_value(T value)ï¼šç”¨äºåœ¨åç¨‹å®Œæˆæ—¶è¿”å›ç»“æœã€‚return_void() ç”¨äºæ²¡æœ‰è¿”å›å€¼çš„åç¨‹ï¼Œè€Œ return_value(T) åˆ™ç”¨äºæœ‰è¿”å›å€¼çš„åç¨‹ã€‚ yield_value(T value)ï¼šç”¨äºç”Ÿæˆå€¼å¹¶è®©åç¨‹æš‚åœï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡æ¢å¤æ—¶ç»§ç»­æ‰§è¡Œã€‚ Awaitable Awaitable æ˜¯ä¸€ä¸ªå¯ä»¥ä¸ co_await è¡¨è¾¾å¼ä¸€èµ·ä½¿ç”¨çš„å¯¹è±¡æˆ–ç±»å‹ã€‚Awaitable å¯¹è±¡å¿…é¡»æä¾›ä¸€ç»„ç‰¹å®šçš„æ–¹æ³•ï¼Œä½¿åç¨‹å¯ä»¥æš‚åœæ‰§è¡Œï¼Œå¹¶åœ¨æŸä¸ªæ¡ä»¶æ»¡è¶³æ—¶ç»§ç»­æ‰§è¡Œã€‚\nco_await æ˜¯ C++ åç¨‹ä¸­çš„ä¸€ç§æ“ä½œç¬¦ï¼Œç”¨äºæš‚åœåç¨‹å¹¶ç­‰å¾…æŸä¸ªæ¡ä»¶çš„æ»¡è¶³ã€‚å½“åç¨‹é‡åˆ° co_await æ—¶ï¼Œå®ƒä¼šæš‚åœï¼Œå¹¶è¿”å›æ§åˆ¶æƒç»™è°ƒç”¨è€…ã€‚åç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨ co_await some_awaitable æ¥ç­‰å¾… some_awaitable å®Œæˆã€‚\nä¸€ä¸ª Awaitable å¯¹è±¡éœ€è¦æä¾›ä»¥ä¸‹ä¸‰ä¸ªæ–¹æ³•ä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ªï¼š\noperator co_awaitï¼šè¿”å›ä¸€ä¸ª Awaitable å¯¹è±¡ã€‚Awaitable å¯¹è±¡æ˜¯å®é™…å®ç°ç­‰å¾…é€»è¾‘çš„å¯¹è±¡ã€‚ await_ready()ï¼šè¿™æ˜¯ Awaitable å¯¹è±¡ä¸Šçš„æ–¹æ³•ã€‚å®ƒè¿”å›ä¸€ä¸ª boolï¼Œç”¨äºæŒ‡ç¤ºæ˜¯å¦éœ€è¦ç­‰å¾…ã€‚å¦‚æœè¿”å› trueï¼Œåç¨‹å°†ä¸ä¼šæš‚åœã€‚ await_suspend(std::coroutine_handle\u0026lt;\u0026gt;)ï¼šè¿™æ˜¯ Awaitable å¯¹è±¡ä¸Šçš„æ–¹æ³•ã€‚å®ƒæ¥å—ä¸€ä¸ª std::coroutine_handle\u0026lt;\u0026gt; å‚æ•°ï¼Œå¹¶åœ¨åç¨‹æš‚åœæ—¶è°ƒç”¨ã€‚è¿™ä¸ªæ–¹æ³•å†³å®šåç¨‹ä½•æ—¶æ¢å¤æ‰§è¡Œã€‚ await_resume()ï¼šè¿™æ˜¯ Awaitable å¯¹è±¡ä¸Šçš„æ–¹æ³•ã€‚å®ƒåœ¨åç¨‹æ¢å¤æ—¶è°ƒç”¨ï¼Œå¹¶è¿”å› co_await è¡¨è¾¾å¼çš„ç»“æœã€‚ C++ä¸­æä¾›äº†ä¸¤ä¸ªç®€å•çš„Awaitableï¼šstd::suspend_neverå’Œstd::suspend_alwaysã€‚\nCoroutine Handle std::coroutine_handle æ˜¯ C++20 åç¨‹åº“ä¸­ä¸€ä¸ªæ ¸å¿ƒçš„å·¥å…·ç±»ï¼Œç”¨äºè¡¨ç¤ºå’Œæ“ä½œåç¨‹ã€‚å®ƒæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œé€šå¸¸ç”¨æ¥æŒ‡å‘åç¨‹çš„çŠ¶æ€ä¿¡æ¯ã€‚å®ƒå¯ä»¥é€šè¿‡åç¨‹çš„ promise_type è®¿é—®å’Œæ§åˆ¶åç¨‹çš„çŠ¶æ€ã€‚æ¯ä¸ªåç¨‹åœ¨åˆ›å»ºæ—¶ï¼Œéƒ½ä¼šç”Ÿæˆä¸€ä¸ª std::coroutine_handleï¼Œç”¨äºç®¡ç†åç¨‹çš„ç”Ÿå‘½å‘¨æœŸã€‚\nstd::coroutine_handle æä¾›äº†ä¸€ç³»åˆ—æ–¹æ³•æ¥æ§åˆ¶åç¨‹çš„æ‰§è¡Œï¼ŒåŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªä¸»è¦åŠŸèƒ½ï¼š\nåˆ›å»ºå’Œè·å–å¥æŸ„ï¼š std::coroutine_handle\u0026lt;\u0026gt;::from_address(void* ptr)ï¼šé€šè¿‡æŒ‡é’ˆè·å–ä¸€ä¸ªå¥æŸ„ã€‚ std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(promise_type\u0026amp; promise)ï¼šé€šè¿‡ promise_type å¯¹è±¡åˆ›å»ºä¸€ä¸ªå¥æŸ„ã€‚ æ§åˆ¶åç¨‹çš„æ‰§è¡Œï¼š void resume()ï¼šæ¢å¤åç¨‹çš„æ‰§è¡Œã€‚ void destroy()ï¼šé”€æ¯åç¨‹å¹¶é‡Šæ”¾å…¶å ç”¨çš„èµ„æºã€‚ void operator()()ï¼šç­‰æ•ˆäº resume()ï¼Œæ¢å¤åç¨‹çš„æ‰§è¡Œã€‚ void* address()ï¼šè¿”å›åç¨‹å¥æŸ„çš„åœ°å€ï¼Œç”¨äºä½çº§æ“ä½œã€‚ æ£€æŸ¥åç¨‹çš„çŠ¶æ€ï¼š bool done()ï¼šæ£€æŸ¥åç¨‹æ˜¯å¦å·²ç»å®Œæˆæ‰§è¡Œã€‚ è®¿é—® promise_typeï¼š promise_type\u0026amp; promise()ï¼šè·å–ä¸å½“å‰åç¨‹å…³è”çš„ promise_type å¯¹è±¡ï¼Œå…è®¸è®¿é—®åç¨‹å†…éƒ¨çŠ¶æ€ã€‚ ç®€å•ç¤ºä¾‹ è¿™é‡Œæœ‰ä¸€ä¸ªä½¿ç”¨C++20 coroutineæ¥å®ç°æŒ‚èµ·å’Œæ¢å¤å‡½æ•°çš„ä¾‹å­ã€‚\n#include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std::chrono_literals; struct Result { struct Promise { Result get_return_object() { return std::coroutine_handle\u0026lt;Promise\u0026gt;::from_promise(*this); } std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() noexcept { return {}; } void unhandled_exception() {} }; using promise_type = Promise; Result(std::coroutine_handle\u0026lt;Promise\u0026gt; h) : handle(h) {} std::coroutine_handle\u0026lt;Promise\u0026gt; handle; }; Result hello() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; std::endl; co_await std::suspend_always{}; // æŒ‚èµ·hello std::cout \u0026lt;\u0026lt; \u0026#34;world!\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;hello one\\n\u0026#34;; } Result hello2() { std::cout \u0026lt;\u0026lt; \u0026#34;ä½ å¥½ \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;hello two two\\n\u0026#34;; co_await std::suspend_always{}; // æŒ‚èµ·hello2 std::cout \u0026lt;\u0026lt; \u0026#34;ä¸–ç•Œ!\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { Result coro = hello(); Result coro2 = hello2(); coro.handle.resume(); // æ¢å¤hello coro2.handle.resume(); // æ¢å¤hello2 } åœ¨mainå‡½æ•°ä¸­ï¼Œä¸€å¼€å§‹æˆ‘ä»¬å¯åŠ¨äº†åç¨‹helloï¼Œè¾“å‡ºäº†â€œHelloâ€åè¢«æŒ‚èµ·ï¼›ä¹‹åå¯åŠ¨äº†åç¨‹hello2ï¼Œå…¶è¾“å‡ºâ€œä½ å¥½\\nhello two two\\nâ€åä¹Ÿè¢«æŒ‚èµ·ã€‚ç´§æ¥ç€æˆ‘ä»¬é€šè¿‡coroutine_handleæ¥ä¾æ¬¡æ¢å¤è¿™ä¸¤ä¸ªåç¨‹ï¼Œæœ€ç»ˆè¾“å‡ºç»“æœä¸ºï¼š\nHello ä½ å¥½ hello two two world! hello one ä¸–ç•Œ! References https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/ https://www.bluepuni.com/archives/stackless-coroutine-and-asio-coroutine https://zhuanlan.zhihu.com/p/355100152?utm_psn=1808059511308697600 https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d https://jasonkayzk.github.io/2022/06/03/%E6%B5%85%E8%B0%88%E5%8D%8F%E7%A8%8B/ https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await https://juejin.cn/post/6844903715099377672 ","permalink":"https://kerolt.github.io/posts/c++/%E5%8D%8F%E7%A8%8Bc++20%E5%8D%8F%E7%A8%8B%E5%88%9D%E4%BD%93%E9%AA%8C/","summary":"\u003ch2 id=\"ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦åç¨‹\"\u003eä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦åç¨‹ï¼Ÿ\u003c/h2\u003e\n\u003cp\u003eä¸ºä»€ä¹ˆæˆ‘ä»¬æœ‰äº†çº¿ç¨‹è¿˜éœ€è¦åç¨‹å‘¢ï¼Ÿï¼ˆå…¶å®è¿™ä¸ªé—®é¢˜ä¸åº”è¯¥è¿™ä¹ˆé—®ï¼Œåç¨‹çš„å‡ºç°åœ¨çº¿ç¨‹ä¹‹å‰ï¼‰åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­è™½ç„¶æˆ‘ä»¬å¯ä»¥åˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­èƒ½åˆ›å»ºçš„çº¿ç¨‹æ•°é‡æ˜¯æœ‰é™åˆ¶çš„ï¼Œå¹¶ä¸”çº¿ç¨‹çš„è°ƒåº¦ä»ç„¶å—æ“ä½œç³»ç»Ÿæ§åˆ¶ï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹ä½•æ—¶æŠ¢å ã€ä½•æ—¶è¢«æŠ¢å å¯¹äºå¼€å‘è€…æ¥è¯´éƒ½æ˜¯é€æ˜çš„ï¼Œå¹¶ä¸”åœ¨è°ƒåº¦çš„è¿‡ç¨‹ä¸­è¿˜å¯èƒ½æ¶‰åŠåˆ°ç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„åˆ‡æ¢å¼€é”€ã€‚\u003c/p\u003e","title":"ã€åç¨‹ã€‘C++20åç¨‹åˆä½“éªŒ"},{"content":" éš¾åº¦ï¼šHard\næ ‡ç­¾ï¼šä½è¿ç®—ï¼›å›¾è®ºï¼›Floydç®—æ³•\né“¾æ¥ï¼š https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/\né¢˜ç›®ä¸­ç»™å‡ºçš„nèŒƒå›´ä¸º1 \u0026lt;= n \u0026lt;= 10ï¼Œé‚£ä¹ˆè¯´æ˜æœ€å¤šçš„10ä¸ªåˆ†éƒ¨çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥é€‰æ‹©å…³é—­çš„å¯è¡Œæƒ…å†µæœ‰2^10ç§ï¼Œè¿™ä¸ªæ•°æ®é‡å¹¶ä¸å¤§ï¼Œå¯ä»¥ç”¨æš´åŠ›æšä¸¾åšå‡ºæ¥ã€‚\nä½†æ˜¯å¦‚ä½•çŸ¥é“é€‰æ‹©äº†å“ªäº›é¡¶ç‚¹å‘¢ï¼Ÿè¿™é‡Œæœ‰ç”¨åˆ°ä½è¿ç®—è¿™ä¸ªå¾ˆå·§å¦™çš„æ–¹æ³•ï¼Œä¸€ä¸ªintå‹æ•°æ®æœ‰32ä½ï¼Œæˆ‘ä»¬æœ€å¤šåªè¦ç”¨å…¶ä¸­çš„10ä½å³å¯è¡¨ç¤ºæ‰€æœ‰çš„æƒ…å†µï¼ŒåŒæ—¶è¿˜èƒ½ç”¨æ¯ä¸€ä½æ¥è¡¨ç¤ºæ˜¯å¦é€‰æ‹©äº†æŸä¸€ä¸ªé¡¶ç‚¹ï¼ˆåˆ†éƒ¨ï¼‰ã€‚\nåˆ©ç”¨Floydç®—æ³•å¯ä»¥æ±‚è§£å‡ºä¸€ä¸ªå›¾ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€å°è·ç¦»ã€‚å½“æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªå¯èƒ½çš„é›†åˆæ—¶ï¼Œåˆ¤æ–­è¿™ä¸ªé›†åˆä¸­æœ‰çš„åˆ†éƒ¨ä¹‹é—´çš„æœ€çŸ­è·ç¦»æ˜¯å¦ä¼šå¤§äºé¢˜ç›®è¦æ±‚çš„æœ€è¿œè·ç¦»maxDistanceï¼Œå¦‚æœæœ‰å¤§äºçš„ï¼Œè¯´æ˜æœ‰åˆ†éƒ¨ä¹‹é—´æœ€çŸ­çš„è·ç¦»éƒ½æ— æ³•æ»¡è¶³è¦æ±‚ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯ä¸€ç§æƒ…å†µæˆ‘ä»¬åªéœ€è¦å¤„ç†åœ¨é›†åˆä¸­åŒ…å«çš„åˆ†éƒ¨ã€‚\nclass Solution { public: int numberOfSets(int n, int maxDistance, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n, INT_MAX / 2)); for (int i = 0; i \u0026lt; n; i++) { g[i][i] = 0; } for (auto\u0026amp; r : roads) { int x = r[0], y = r[1], w = r[2]; g[x][y] = min(g[x][y], w); g[y][x] = min(g[y][x], w); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(n); // ç”¨fæ¥å­˜å‚¨æ¯ä¸€ç§æƒ…å†µå¯¹åº”çš„å›¾ auto check = [\u0026amp;](int set) { for (int i = 0; i \u0026lt; n; i++) { // åªè¦æ¯ç§æƒ…å†µå¯¹åº”é›†åˆä¸­çš„åˆ†éƒ¨æ„æˆçš„å›¾ if ((set \u0026gt;\u0026gt; i) \u0026amp; 1) { f[i] = g[i]; } } // Floydç®—æ³•ï¼Œå¤„ç†fä¸­åˆ†éƒ¨ä¹‹é—´çš„æœ€çŸ­è·ç¦»ï¼Œéœ€è¦æ ¹æ®setçš„å€¼æ¥é€‰æ‹©è¿›è¡Œè®¡ç®— // å› ä¸ºåœ¨ä¹‹å‰æˆ‘ä»¬åªé€‰æ‹©äº†é›†åˆä¸­æœ‰çš„åˆ†éƒ¨å»ºå›¾ for (int k = 0; k \u0026lt; n; k++) { if (((set \u0026gt;\u0026gt; k) \u0026amp; 1) == 0) continue; for (int i = 0; i \u0026lt; n; i++) { if (((set \u0026gt;\u0026gt; i) \u0026amp; 1) == 0) continue; for (int j = 0; j \u0026lt; n; j++) { if (((set \u0026gt;\u0026gt; j) \u0026amp; 1) == 0) continue; f[i][j] = min(f[i][j], f[i][k] + f[k][j]); } } } // æ£€æŸ¥å›¾ä¸­å„ä¸ªåˆ†éƒ¨çš„æœ€çŸ­è·ç¦» for (int i = 0; i \u0026lt; n; i++) { if (((set \u0026gt;\u0026gt; i) \u0026amp; 1) == 0) continue; for (int j = 0; j \u0026lt; n; j++) { if (((set \u0026gt;\u0026gt; j) \u0026amp; 1) \u0026amp;\u0026amp; f[i][j] \u0026gt; maxDistance) { return false; } } } return true; }; int res = 0; // æš´åŠ›æšä¸¾æ‰€æœ‰æƒ…å†µ for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { res += check(i); // trueå’Œfalseåˆ†åˆ«éšå¼è½¬æ¢ä¸º1å’Œ0 } return res; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/259.-%E5%85%B3%E9%97%AD%E5%88%86%E9%83%A8%E7%9A%84%E5%8F%AF%E8%A1%8C%E9%9B%86%E5%90%88%E6%95%B0%E7%9B%AE/","summary":"\u003cblockquote\u003e\n\u003cp\u003eéš¾åº¦ï¼šHard\u003c/p\u003e\n\u003cp\u003eæ ‡ç­¾ï¼šä½è¿ç®—ï¼›å›¾è®ºï¼›Floydç®—æ³•\u003c/p\u003e\n\u003cp\u003eé“¾æ¥ï¼š \u003ca href=\"https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/\"\u003ehttps://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"259. å…³é—­åˆ†éƒ¨çš„å¯è¡Œé›†åˆæ•°ç›®"},{"content":"å‡è®¾ä½¿ç”¨viteå¯åŠ¨é¡¹ç›®åï¼Œå¸Œæœ›åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šé€šè¿‡ipå’Œç«¯å£å·æ¥è®¿é—®é¡¹ç›®ï¼Œé€šå¸¸éœ€è¦åœ¨Linuxä¸Šå¼€æ”¾ç«¯å£å·ã€‚\nè¿™é‡Œé€šè¿‡firewalldæ¥å®Œæˆï¼Œå¯èƒ½éœ€è¦è‡ªå·±å®‰è£…ä¸€ä¸‹ï¼š\nsudo apt install firewalld å¯é€šè¿‡systemctlæ¥æ£€æµ‹å…¶æ˜¯å¦å·¥ä½œï¼š\nsystemctl status firewalld æ·»åŠ ç«¯å£æƒ³è¦çš„ç«¯å£ï¼Œè¿”å› success ä»£è¡¨æˆåŠŸï¼ˆâ€“permanentè¡¨ç¤ºæ°¸ä¹…ç”Ÿæ•ˆï¼Œæ²¡æœ‰æ­¤å‚æ•°é‡å¯åå¤±æ•ˆï¼‰ã€‚ä¾‹å¦‚viteçš„é»˜è®¤ç«¯å£ä¸º5173ï¼š\nfirewall-cmd --zone=public --add-port=5173/tcp --permanent ä¹‹åæ‰§è¡Œfirewall-cmd --reloadï¼Œè¿”å› success ä»£è¡¨æˆåŠŸã€‚\næŸ¥è¯¢ç«¯å£å·ï¼š\nfirewall-cmd --zone=public --query-port=5173/tcp å…³é—­ç«¯å£å·ï¼š\nfirewall-cmd --zone=public --remove-port=5173/tcp --permanent ","permalink":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%8F%B7/","summary":"\u003cp\u003eå‡è®¾ä½¿ç”¨viteå¯åŠ¨é¡¹ç›®åï¼Œå¸Œæœ›åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šé€šè¿‡ipå’Œç«¯å£å·æ¥è®¿é—®é¡¹ç›®ï¼Œé€šå¸¸éœ€è¦åœ¨Linuxä¸Šå¼€æ”¾ç«¯å£å·ã€‚\u003c/p\u003e","title":"Linuxå¼€æ”¾ç«¯å£å·"},{"content":" éš¾åº¦ï¼šHard\næ ‡ç­¾ï¼šå“ˆå¸Œè¡¨ï¼›æ»‘åŠ¨çª—å£ï¼›å­—ç¬¦ä¸²\né“¾æ¥ï¼š https://leetcode.cn/problems/minimum-window-substring/description/\næ¯”è¾ƒå®¹æ˜“æƒ³åˆ°è¦ç”¨æ»‘åŠ¨çª—å£æ¥è§£å†³ï¼Œä½¿ç”¨ä¸¤ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½•ä¿¡æ¯ï¼šcnt_tç”¨äºè®°å½•å­—ç¬¦ä¸²tä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°è¿‡çš„æ¬¡æ•°ï¼Œcnt_sç”¨äºæ»‘åŠ¨çª—å£ä¸­çš„å­—ç¬¦çš„å‡ºç°æ¬¡æ•°ã€‚\næ»‘åŠ¨çª—å£çš„åŒºé—´ä¸º[left, right]ï¼Œå¹¶è®°å½•æœ€å°çš„å·¦å³åŒºé—´ï¼ˆè¿™é‡Œæˆ‘ä½¿ç”¨ä¸€ä¸ªresæ•°ç»„ï¼‰ã€‚ç§»åŠ¨rightæœ‰åŒºé—´ï¼Œç›´åˆ°ç§»åŠ¨åˆ°så­—ç¬¦ä¸²ç»“æŸéƒ¨åˆ†ã€‚å°†s[right]åŠ å…¥cnt_sä¸­ï¼Œå¦‚æœcnt_såŒ…å«cnt_tï¼Œåˆ™ï¼š\nè‹¥å½“å‰åŒºé—´é•¿åº¦å°äºè®°å½•çš„æœ€å°åŒºé—´é•¿åº¦ï¼Œæ›´æ–°è¿™ä¸ªæœ€å°åŒºé—´é•¿åº¦ï¼› å°†cnt_sä¸­s[left]å‡ºç°çš„æ¬¡æ•°-1ï¼› leftå³ç§»+1ï¼› é‡å¤ä¸Šé¢3æ­¥ï¼Œç›´åˆ°cnt_sä¸åŒ…å«cnt_tï¼› æœ€åï¼Œè‹¥res[0] \u0026lt; 0ï¼ˆæœ€å°å·¦åŒºé—´ï¼‰ï¼Œè¯´æ˜sÂ ä¸­ä¸å­˜åœ¨æ¶µç›–Â tÂ æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸²Â \u0026quot;\u0026quot;Â ï¼›åä¹‹ï¼Œè¿”å›æœ€å°å·¦å³åŒºé—´ä¸­çš„å­—ç¬¦ä¸²ã€‚\nè¿™é‡Œçš„â€œcnt_såŒ…å«cnt_tâ€æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿcnt_tä¸­æœ‰çš„å­—ç¬¦cnt_sä¸­éƒ½è¦æœ‰ï¼Œå¹¶ä¸”cnt_tä¸­å­—ç¬¦çš„æ¬¡æ•°è¦å°äºç­‰äºcnt_sä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ã€‚\nclass Solution { public: string minWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; cnt_s, cnt_t; for (char c : t) { cnt_t[c]++; } int left = 0, right = 0, n = s.length(); int res[2]{-1, n}; while (right \u0026lt; n) { cnt_s[s[right]]++; while (cover(cnt_s, cnt_t)) { if (right - left \u0026lt; res[1] - res[0]) { res[0] = left; res[1] = right; } cnt_s[s[left++]]--; } right++; } return res[0] \u0026lt; 0 ? \u0026#34;\u0026#34; : s.substr(res[0], res[1] - res[0] + 1); } bool cover(unordered_map\u0026lt;char, int\u0026gt;\u0026amp; cnt_s, unordered_map\u0026lt;char, int\u0026gt;\u0026amp; cnt_t) { for (auto\u0026amp; [k, v] : cnt_t) { if (cnt_s.find(k) == cnt_t.end() || cnt_s[k] \u0026lt; v) { return false; } } return true; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","summary":"\u003cblockquote\u003e\n\u003cp\u003eéš¾åº¦ï¼šHard\u003c/p\u003e\n\u003cp\u003eæ ‡ç­¾ï¼šå“ˆå¸Œè¡¨ï¼›æ»‘åŠ¨çª—å£ï¼›å­—ç¬¦ä¸²\u003c/p\u003e\n\u003cp\u003eé“¾æ¥ï¼š \u003ca href=\"https://leetcode.cn/problems/minimum-window-substring/description/\"\u003ehttps://leetcode.cn/problems/minimum-window-substring/description/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e","title":"76. æœ€å°è¦†ç›–å­ä¸²"},{"content":"è®°å½•ä¸€ä¸‹å¦‚ä½•é…ç½®eslintï¼ˆå…¶å®æ˜¯æ€•ä¸‹ä¸€æ¬¡åˆè¢«æŠ˜ç£¨ï¼‰ã€‚\nuni-cliåˆ›å»ºé¡¹ç›® ç”±äºæˆ‘æ˜¯åœ¨linuxä¸Šä½¿ç”¨uniappï¼Œæ— æ³•ä½¿ç”¨HBuilderXï¼Œæ•…é‡‡ç”¨uni-cliæ¥åˆ›å»ºé¡¹ç›®å¹¶ä½¿ç”¨vscodeè¿›è¡Œå¼€å‘ã€‚\nuni-cliåˆ›å»ºé¡¹ç›®å¾ˆç®€å•ï¼Œä¸€è¡Œå‘½ä»¤å³å¯ï¼Œè¿™é‡Œé‡‡ç”¨vue3/viteç‰ˆï¼š\nnpx degit dcloudio/uni-preset-vue#vite my-vue3-project è¿™é‡Œåªç”¨æ¥åˆ›å»ºé¡¹ç›®ï¼Œå‘å¸ƒè¿è¡Œä»€ä¹ˆçš„å…·ä½“å¯ä»¥çœ‹å®˜ç½‘ã€‚\nä½¿ç”¨eslint eslintçš„é…ç½®æ–‡ä»¶å’Œé…ç½®æ–¹å¼æˆ‘æ„Ÿè§‰æœ‰å¥½å¤šç§ï¼Œæ‰€ä»¥åœ¨é…ç½®çš„æ—¶å€™æŠ˜è…¾äº†æŒºä¹…ï¼Œæœ€å¥½è¿˜æ˜¯æŒ‰ç…§å®˜ç½‘æœ€æ–°æ–‡æ¡£æ¥ï¼š\neslintï¼šhttps://eslint.org/docs/latest/use/getting-started eslint-plugin-vueï¼šhttps://eslint.vuejs.org/ å®‰è£…eslint npm init @eslint/config@latest é…ç½® å®‰è£…å®Œåï¼Œä¸€èˆ¬é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹å°±ä¼šå‡ºç°eslint.config.mjsæ–‡ä»¶ï¼ˆeslint 9.4.0ç‰ˆæœ¬ï¼Œé‡‡ç”¨vueæ¡†æ¶ï¼‰ï¼Œä¸»ä½“å¦‚ä¸‹ï¼š\nimport pluginVue from \u0026#34;eslint-plugin-vue\u0026#34;; export default [ ...... { rules: { } } ]; ç°åœ¨æˆ‘ä»¬å°±è¦æ¥æŒ‰ç…§è‡ªå·±çš„è¦æ±‚æ¥é…ç½®ï¼Œæœ€å¥½æ˜¯æŒ‰ç…§å®˜æ–¹çš„æ–‡æ¡£æ¥å®šåˆ¶ï¼šeslint-plugin-vueï¼Œä¸€èˆ¬ä½¿ç”¨çš„è§„åˆ™ä¼šå†™åœ¨ruleså¯¹è±¡ä¸­ã€‚\nä¸¾ä¸ªğŸŒ° æ¯”å¦‚æˆ‘å¸Œæœ›åœ¨ä»£ç ä¸­ä½¿ç”¨åŒå¼•å·ï¼Œå¹¶ä¸”è¯­å¥ä½¿ç”¨åˆ†å·ç»“å°¾ï¼Œé‚£ä¹ˆeslint.config.mjsæ–‡ä»¶å°±å¯ä»¥è¿™æ ·å†™ï¼š\nimport pluginVue from \u0026#34;eslint-plugin-vue\u0026#34;; export default [ ...pluginVue.configs[\u0026#34;flat/recommended\u0026#34;], { rules: { quotes: [\u0026#34;error\u0026#34;, \u0026#34;double\u0026#34;], semi: [\u0026#34;error\u0026#34;] } } ]; å¦‚æœåœ¨ä»£ç ä¸­ç¢°åˆ°ä¸€äº›eslintçš„æŠ¥é”™ï¼Œä¾‹å¦‚\né‚£ä¹ˆå¯ä»¥åœ¨æŠ¥é”™ä¿¡æ¯ä¸­ç»™å‡ºçš„é“¾æ¥ç½‘é¡µä¸­æŸ¥æ‰¾\nåœ¨eslint.config.mjsä¸­çš„rulesä¸­åŠ å…¥\u0026quot;vue/multi-word-component-names\u0026quot;: 0åï¼ŒæŠ¥é”™å°±æ¶ˆå¤±äº†ã€‚\n","permalink":"https://kerolt.github.io/posts/%E5%89%8D%E7%AB%AF/%E7%94%A8uni-cli%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%90%8E%E4%BD%BF%E7%94%A8eslint/","summary":"\u003cp\u003eè®°å½•ä¸€ä¸‹å¦‚ä½•é…ç½®eslintï¼ˆå…¶å®æ˜¯æ€•ä¸‹ä¸€æ¬¡åˆè¢«æŠ˜ç£¨ï¼‰ã€‚\u003c/p\u003e","title":"ç”¨uni-cliåˆ›å»ºé¡¹ç›®åä½¿ç”¨eslint"},{"content":" éš¾åº¦ï¼šHard\næ ‡ç­¾ï¼šå“ˆå¸Œè¡¨ã€å­—ç¬¦ä¸²ã€æ»‘åŠ¨çª—å£\né“¾æ¥ï¼šhttps://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/\nåœ¨Bç«™ä¸Šçœ‹è§ä¸€ä¸ªupçš„è§†é¢‘ï¼Œæ„Ÿè§‰è¯´çš„å¾ˆæ¸…æ™°ï¼Œè¨€ç®€æ„èµ…ï¼šã€äº”åˆ†é’ŸåŠ›æ‰£ Leetcode ç¬¬30é¢˜ ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²é™¤ Pythonå…¥é—¨ç®—æ³•åˆ·é¢˜ æç®€è§£æ³• 23è¡Œä»£ç  97%ã€‘ ã€‚\nçœ‹å®Œè§†é¢‘åï¼Œæˆ‘è§‰å¾—å…³é”®ç‚¹åœ¨äºï¼Œå¯ä»¥é€šè¿‡æ¯”è¾ƒä¸¤ä¸ªå“ˆå¸Œè¡¨æ˜¯å¦â€œç›¸ç­‰â€ æ¥åˆ¤æ–­å­ä¸²æ˜¯å¦æ»¡è¶³è¦æ±‚ã€‚\nclass Solution { public: vector\u0026lt;int\u0026gt; findSubstring(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) { int words_num = words.size(); int uni_len = words[0].size(); int n = s.size(); vector\u0026lt;int\u0026gt; res; unordered_map\u0026lt;string, int\u0026gt; dict; // è®°å½•æ¯ä¸ªå•è¯çš„å‡ºç°æ¬¡æ•° for (auto\u0026amp; w : words) { dict[w]++; } // å¤–å¾ªç¯éå†çš„æ¬¡æ•°ä¸ºå•ä¸ªå•è¯çš„é•¿åº¦ for (int i = 0; i \u0026lt; uni_len; i++) { int start = i; // startä¸ºå­ä¸²å¼€å§‹çš„ç´¢å¼• unordered_map\u0026lt;string, int\u0026gt; cache; // cacheç”¨äºè®°å½•å†…å¾ªç¯ä¸­ï¼Œä½äºdictä¸­çš„å•è¯çš„å‡ºç°æ¬¡æ•° // å†…å¾ªç¯ï¼Œæ¯æ¬¡å¢åŠ ä¸€ä¸ªå•è¯é•¿åº¦ï¼ˆå³ä»¥ä¸€ä¸ªå•è¯é•¿åº¦ä¸ºæœ€å°å•ä½ï¼‰ for (int j = i; j \u0026lt; n; j += uni_len) { string sub = s.substr(j, uni_len); // åˆ¤æ–­å½“å‰æˆªå–çš„å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨äºdictä¸­ if (dict.find(sub) != dict.end()) { cache[sub]++; // å½“subåœ¨cacheä¸­å‡ºç°æ¬¡æ•°å¤§äºdictä¸­ï¼Œè¯´æ˜å½“å‰startä¸å¯èƒ½ä¸ºå­ä¸²çš„å¼€å§‹ç´¢å¼•ï¼ˆå› ä¸ºå•è¯æ•°ç›®éƒ½ä¸ç›¸ç­‰äº†ï¼‰ï¼Œä¸æ–­ç§»åŠ¨startä½ç½®ï¼ˆç§»åŠ¨å•å…ƒä¸ºuni_lenï¼‰ï¼Œç›´åˆ°cache[sub] \u0026lt;= dict[sub] while (cache[sub] \u0026gt; dict[sub]) { string remove_str = s.substr(start, uni_len); cache[remove_str]--; start += uni_len; } // è‹¥cacheå’Œdictä¸­å†…å®¹ä¸€è‡´ï¼Œè¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„å­ä¸² if (dict == cache) { res.push_back(start); } } else { // è‹¥å½“å‰æˆªå–å­—ç¬¦ä¸²ä¸å­˜åœ¨äºdictä¸­ï¼Œè·³è¿‡è¿™ä¸ªå•è¯ start = j + uni_len; cache.clear(); } } } return res; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/30.-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","summary":"\u003cblockquote\u003e\n\u003cp\u003eéš¾åº¦ï¼šHard\u003c/p\u003e\n\u003cp\u003eæ ‡ç­¾ï¼šå“ˆå¸Œè¡¨ã€å­—ç¬¦ä¸²ã€æ»‘åŠ¨çª—å£\u003c/p\u003e\n\u003cp\u003eé“¾æ¥ï¼šhttps://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/\u003c/p\u003e\n\u003c/blockquote\u003e","title":"30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²"},{"content":"æœ€è¿‘å¬è¯´VMware17.5.2ä¸ªäººç‰ˆå¯ä»¥å…è´¹ä½¿ç”¨äº†ï¼Œæ•…åœ¨Linuxä¸‹å®‰è£…ç”¨ç”¨ï¼Œé¡ºä¾¿è®°å½•ä¸€ä¸‹è¸©çš„å‘ã€‚\næˆ‘æ˜¯æƒ³åœ¨Linuxä¸Šæƒ³ç”¨Uniappï¼Œç”¨wineçš„ä½“éªŒä¸æ˜¯å¾ˆå¥½ï¼Œæ•…æ‰“ç®—ç”¨è™šæ‹Ÿæœºè·‘Windowsã€‚å®‰è£…å¥½VMware17.5.2åï¼Œé…ç½®å¥½windowsé•œåƒåï¼Œç‚¹å‡»å¯åŠ¨ï¼Œå´æŠ¥äº†è¿™æ ·çš„é”™ï¼š\nCould not open /dev/vmmon: ?????????. Please make sure that the kernel module `vmmon\u0026rsquo; is loaded.\næœäº†ä¸€ä¸‹å‘ç°æ˜¯åŸå› ä¸ºVMwareæ— æ³•è®¿é—®å…¶å¿…è¦çš„å†…æ ¸æ¨¡å—vmmonï¼š\næˆ‘é¦–å…ˆæ˜¯å°è¯•äº†æ‰‹åŠ¨å¯ç”¨VMwareæ¨¡å—ï¼Œç„¶åæ‰§è¡Œå‘½ä»¤å®‰è£…ç¼ºå¤±çš„æ¨¡å—\nsudo /etc/init.d/vmware start sudo vmware-modconfig --console --install-all ä½†æ˜¯è¿˜æ˜¯æ— æ•ˆï¼Œåœ¨æŸ¥çœ‹åˆ«äººçš„åšå®¢åï¼Œæˆ‘æ‰‹åŠ¨å»ç¼–è¯‘å®‰è£…ç¼ºå¤±çš„vmmonå’Œvmnetæ¨¡å—ï¼š\ngit clone https://github.com/mkubecek/vmware-host-modules cd vmware-host-modules git checkout workstation-17.5.1 sudo make sudo make install æ‰§è¡Œå®Œæˆåï¼Œè¿™ä¸¤ä¸ªæ¨¡å—å°†ä¼šå®‰è£…åˆ°/lib/modules/6.1.0-18-amd64/miscä¸‹\nkerolt î‚° /usr/lib/modules/6.1.0-18-amd64/misc î‚° $ ls -l æ€»è®¡ 7164 -rw-r--r-- 1 root root 3996784 5æœˆ27æ—¥ 18:48 vmmon.ko -rw-r--r-- 1 root root 3337384 5æœˆ27æ—¥ 18:48 vmnet.ko æœ¬ä»¥ä¸ºåˆ°ç°åœ¨å·²ç»ç»“æŸï¼Œç»“æœå†æ¬¡å¯åŠ¨VMwareï¼Œè¿˜æ˜¯ä¸ä¿¡ï¼Œäºæ˜¯æˆ‘æƒ³ç€å¯èƒ½æ˜¯å†…æ ¸æ¨¡å—æ²¡æœ‰åŠ è½½ï¼Œé‡‡ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹ï¼š\nlsmod | grep vmmon ä¸å‡ºæ„å¤–ï¼Œæ²¡æœ‰è¾“å‡ºï¼Œæ‰‹åŠ¨åŠ è½½æ¨¡å—ï¼š\nsudo modprobe vmmon # modprobe: ERROR: could not insert \u0026#39;vmmon\u0026#39;: Key was rejected by service æ ¹æ®è¯¥é”™è¯¯è¯¢é—®ChatGPTï¼Œå…¶ç»™å‡ºçš„ç­”å¤ä¸ºï¼šå¯ç”¨äº†å®‰å…¨å¯åŠ¨ï¼ˆSecure Bootï¼‰ï¼Œå¯¼è‡´ç³»ç»Ÿæ‹’ç»åŠ è½½æœªç­¾åæˆ–æœªæ­£ç¡®ç­¾åçš„å†…æ ¸æ¨¡å—ã€‚\né‡å¯è®¡ç®—æœºï¼Œè¿›å…¥ BIOS/UEFI è®¾ç½®ï¼Œå°†Secure Boot è®¾ç½®ä¸º Disabledï¼Œä¹‹åå†æ¬¡å¯åŠ¨VMwareæ—¶å°±æ²¡æœ‰é—®é¢˜äº†ï½\n","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/vmware17.5.2%E5%90%AF%E5%8A%A8%E8%B8%A9%E5%9D%91/","summary":"\u003cp\u003eæœ€è¿‘å¬è¯´VMware17.5.2ä¸ªäººç‰ˆå¯ä»¥å…è´¹ä½¿ç”¨äº†ï¼Œæ•…åœ¨Linuxä¸‹å®‰è£…ç”¨ç”¨ï¼Œé¡ºä¾¿è®°å½•ä¸€ä¸‹è¸©çš„å‘ã€‚\u003c/p\u003e","title":"VMware17.5.2å¯åŠ¨è¸©å‘"},{"content":"ä¸Šä¸€ç¯‡æ–‡ç« ï¼šè‚¡ç¥¨é—®é¢˜ä¸çŠ¶æ€æœºdp\næœ¬ç¯‡æ–‡ç« æ¶‰åŠé¢˜ç›®å¦‚ä¸‹ï¼š\n123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III 188. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV 309. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«å†·å†»æœŸ äº¤æ˜“Kæ¬¡é—®é¢˜ åœ¨ä¸Šç¯‡æ–‡ç« çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å…¶å®éœ€è¦åšçš„å°±æ˜¯åœ¨å¤„ç†å‡½æ•°ä¸ŠåŠ ä¸€ä¸ªå‚æ•°kä»£è¡¨è¿˜å¯ä»¥äº¤æ˜“å‡ æ¬¡ï¼Œå½“k \u0026lt; 0æ—¶å°±è¯´æ˜äº¤æ˜“æ¬¡æ•°è¾¾åˆ°ä¸Šé™\nclass Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; cache(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(k + 1, vector\u0026lt;int\u0026gt;(2, -1))); function\u0026lt;int(int, int, bool)\u0026gt; dfs = [\u0026amp;](int i, int k, bool hold) { if (k \u0026lt; 0) { return INT_MIN; } if (i \u0026lt; 0) { return hold ? INT_MIN : 0; } int\u0026amp; res = cache[i][k][hold]; if (res != -1) { return res; } if (hold) { // ç¬¬iå¤©æŒæœ‰ return res = max(dfs(i - 1, k, true), dfs(i - 1, k, false) - prices[i]); } // ç¬¬iå¤©æœªæŒæœ‰ return res = max(dfs(i - 1, k, false), dfs(i - 1, k - 1, true) + prices[i]); }; return dfs(n - 1, k, false); } }; å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¯¥é—®é¢˜çš„è®°å¿†åŒ–æœç´¢å®ç°ä¸­cacheæ•°ç»„åº”è¯¥ä¸ºä¸‰ç»´ï¼Œcache[i][k][hold]è¡¨ç¤ºç¬¬iå¤©ï¼Œå‰©ä½™äº¤æ˜“æ¬¡æ•°kæ¬¡ã€æ˜¯å¦æ‹¥æœ‰è‚¡ç¥¨çš„ç»“æœçš„ç¼“å­˜\nä½¿ç”¨è®°å¿†åŒ–æœç´¢æ˜¯æ— æ³•é€šè¿‡123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IIIçš„ï¼Œå› æ­¤å¯ä»¥å°†å…¶æ”¹æˆdpè§£å†³\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int k = 2; int n = prices.size(); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(k + 2, vector\u0026lt;int\u0026gt;(2, INT_MIN))); for (int j = 0; j \u0026lt; k + 2; j++) { dp[0][j][0] = 0; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= k + 1; j++) { dp[i + 1][j][0] = max(dp[i][j][0], dp[i][j - 1][1] + prices[i]); dp[i + 1][j][1] = max(dp[i][j][1], dp[i][j][0] - prices[i]); } } return dp[n][k + 1][0]; } }; å†·å†»æœŸé—®é¢˜ è¿™ä¸ªé—®é¢˜æœ‰ç‚¹ç±»ä¼¼ä¸æ‰“å®¶åŠ«èˆ\u0026mdash;ä¸èƒ½è¿ç»­å·ç›¸é‚»çš„æˆ¿å±‹ã€‚é‚£ä¹ˆåœ¨æœ¬é—®é¢˜ä¸­ï¼Œæ˜¯ä¸æ˜¯å°†æ¯”è¾ƒå‰ä¸€å¤©çš„ä»£ç æ”¹æˆæ¯”è¾ƒå‰å‰ä¸€å¤©çš„ä»£ç å°±è¡Œäº†ï¼Ÿå·®ä¸å¤šï¼ä½†æ˜¯åªæœ‰åœ¨ä¹°å…¥è‚¡ç¥¨æˆ–å–å‡ºè‚¡ç¥¨çš„æ—¶å€™éœ€è¦ä¿®æ”¹ï¼Œè¿™æ˜¯å› ä¸ºä¹°å…¥å–å‡ºæ‰ç®—ä¸€æ¬¡äº¤æ˜“ï¼Œæ‰€ä»¥åœ¨è¿™ä¸¤ä¸ªæ—¶é—´æ®µé€‰ä¸€ä¸ªè¿›è¡Œä¿®æ”¹å³å¯\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cache(n, vector(2, -1)); function\u0026lt;int(int, bool)\u0026gt; dfs = [\u0026amp;](int i, bool hold) { if (i \u0026lt; 0) { return hold ? INT_MIN : 0; } int\u0026amp; res = cache[i][hold]; if (res != -1) { return res; } if (hold) { return res = max(dfs(i - 1, true), dfs(i - 2, false) - prices[i]); } return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]); }; return dfs(n - 1, false); } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%AC%AC%E4%BA%8C%E6%B3%A2/","summary":"\u003cp\u003eä¸Šä¸€ç¯‡æ–‡ç« ï¼š\u003ca href=\"https://kerolt.github.io/2024/04/11/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BAdp/\"\u003eè‚¡ç¥¨é—®é¢˜ä¸çŠ¶æ€æœºdp\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eæœ¬ç¯‡æ–‡ç« æ¶‰åŠé¢˜ç›®å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/\"\u003e123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/\"\u003e188. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/\"\u003e309. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«å†·å†»æœŸ\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"è‚¡ç¥¨é—®é¢˜ç¬¬äºŒæ³¢"},{"content":" æœ¬ç¯‡æ–‡ç« æ€è·¯æ¥æºäº @bilibili/çµèŒ¶å±±è‰¾åºœ\né¢˜ç›®æè¿°ï¼šhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii\nç›¸å¯¹äºä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIï¼Œè¯¥é—®é¢˜å¯ä»¥å¤šæ¬¡ä¹°å…¥å’Œå–å‡ºè‚¡ç¥¨ä»¥è·å–æœ€å¤§åˆ©ç›Š\nå¯å‘æ€è·¯ ä»¥prices = [7,1,5,3,6,4]ä¸ºä¾‹ï¼Œç›´åˆ°æœ€åä¸€å¤©ï¼Œæˆ‘ä»¬èƒ½è·å–åˆ°çš„æœ€å¤§åˆ©æ¶¦æ˜¯ä»€ä¹ˆï¼Ÿ\næœ€åä¸€å¤©ï¼Œä¹Ÿå°±æ˜¯ç¬¬äº”å¤©çš„åˆ©æ¶¦ï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰ = ç¬¬0å¤©åˆ°ç¬¬5å¤©ç»“æŸçš„åˆ©æ¶¦ = ç¬¬0å¤©åˆ°ç¬¬å››å¤©ç»“æŸçš„åˆ©æ¶¦ + ç¬¬äº”å¤©çš„åˆ©æ¶¦\nå°†åˆ©æ¶¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š\nç¬¬äº”å¤©çš„åˆ©æ¶¦ ä»€ä¹ˆéƒ½ä¸åš ä¹°å…¥è‚¡ç¥¨ï¼ˆä» æœªæŒæœ‰è‚¡ç¥¨ -\u0026gt; æŒæœ‰è‚¡ç¥¨ï¼‰ å–å‡ºè‚¡ç¥¨ï¼ˆä» æŒæœ‰è‚¡ç¥¨ -\u0026gt; æœªæŒæœ‰è‚¡ç¥¨ï¼‰ ç¬¬é›¶å¤©åˆ°ç¬¬å››å¤©çš„åˆ©æ¶¦ ç”±æ­¤å¯ä»¥æ¸…æ™°çš„æ„Ÿå—åˆ°è¿™æ ·ä¸€ä¸ªå¤§é—®é¢˜å¯ä»¥åˆ†å‰²ä¸ºç›¸åŒçš„å­é—®é¢˜ï¼š\né—®é¢˜ï¼šç¬¬iå¤©ç»“æŸï¼ŒæŒæœ‰/æœªæŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ å­é—®é¢˜ï¼šç¬¬i - 1å¤©ç»“æŸï¼ŒæŒæœ‰/æœªæŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦\nçŠ¶æ€æœº ç®€å•çš„ç†è§£å°±æ˜¯çŠ¶æ€çš„è½¬æ¢ï¼Œå¦‚ä¸‹å›¾å°±æ˜¯æœ¬é¢˜çš„çŠ¶æ€æœº\né‚£ä¹ˆå¦‚ä½•å°†çŠ¶æ€æœºä¸æ€è·¯ç»“åˆèµ·æ¥å‘¢ï¼Ÿ\næˆ‘ä»¬å¯ä»¥è¿™ä¹ˆæƒ³ï¼š\nå‡è®¾f(i, false)ä»£è¡¨ç¬¬iå¤©ç»“æŸæ—¶æœªæ‹¥æœ‰è‚¡ç¥¨çš„åˆ©æ¶¦ï¼Œf(i, true)ä»£è¡¨ç¬¬iå¤©ç»“æŸæ—¶æ‹¥æœ‰è‚¡ç¥¨çš„åˆ©æ¶¦ ç¬¬iå¤©æœªæŒæœ‰è‚¡ç¥¨çš„æƒ…å†µä¸ºï¼šç¬¬i-1å¤©æœªæŒæœ‰è‚¡ç¥¨æˆ–è€…ç¬¬i-1å¤©æ‹¥æœ‰è‚¡ç¥¨ä½†æ˜¯ç¬¬iå¤©æ—¶å–å‡ºäº†è‚¡ç¥¨ã€‚è¿™æ—¶ç¬¬iå¤©æœªæŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ä¸ºf(i, false) = max(f(i - 1, false), f(i - 1, true) + prices[i]) ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æƒ…å†µæœªï¼šç¬¬i-1å¤©æŒæœ‰è‚¡ç¥¨æˆ–è€…ç¬¬i-1å¤©æœªæ‹¥æœ‰è‚¡ç¥¨ä½†æ˜¯ç¬¬iå¤©æ—¶ä¹°å…¥äº†è‚¡ç¥¨ã€‚è¿™æ—¶ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ä¸ºf(i, true) = max(f(i - 1, true), f(i - 1, false) - prices[i]) è®°å¿†åŒ–æœç´¢ ä½¿ç”¨ä¸Šé¢çš„æ€è·¯ï¼Œé‡‡ç”¨é€’å½’çš„æ–¹æ³•ï¼Œä¸éš¾å†™å‡ºä¸‹é¢çš„ç®—æ³•ï¼š\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); function\u0026lt;int(int, bool)\u0026gt; dfs = [\u0026amp;](int i , bool hold) { if (i \u0026lt; 0) { return hold ? INT_MIN : 0; } if (hold) { // ç¬¬iå¤©æŒæœ‰ return max(dfs(i - 1, true), dfs(i - 1, false) - prices[i]); } // ç¬¬iå¤©æœªæŒæœ‰ return max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]); }; return dfs(n - 1, false); } }; ä¸Šé¢è¿˜æœ‰å‡ ä¸ªé—®é¢˜\nä¸ºä»€ä¹ˆå½“iä¸åœ¨èŒƒå›´æ—¶return hold ? INT_MIN : 0;ï¼Ÿå½“iä¸åœ¨èŒƒå›´å†…ï¼Œé‚£ä¹ˆè¯´æ˜æ­¤æ—¶å°±ç®—æ‹¥æœ‰è‚¡ç¥¨ä¹Ÿæ˜¯éæ³•çš„ï¼Œé‚£ä¹ˆå…¶è¿”å›å€¼ä¸€å®šä¸èƒ½å½±å“åˆ°æ­£å¸¸çš„iå€¼ï¼Œè€Œç”¨äºæ¯”è¾ƒè¿”å›å€¼çš„å‡½æ•°ä¸ºmaxï¼Œé‚£ä¹ˆå°†è¯¥è¿”å›å€¼è®¾ç½®æˆINT_MAXå°±æ˜¯æœ€å¥½çš„é€‰æ‹©äº† ä¸ºä»€ä¹ˆæœ€ååªè¦è¿”å›dfs(n - 1, false)ï¼Ÿè¿™æ—¶å› ä¸ºæœ€åä¸€å¤©å–å‡ºå»ï¼ˆä¹Ÿå°±æ˜¯æœªæŒæœ‰è‚¡ç¥¨ï¼Œfalseï¼‰æ‰€æ‹¥æœ‰çš„åˆ©æ¶¦ä¸€å®šæ¯”æœ€åä¸€å¤©ä¸å–å‡ºå»ï¼ˆæŒæœ‰è‚¡ç¥¨ï¼Œtrueï¼‰æ‰€æ‹¥æœ‰çš„åˆ©æ¶¦é«˜ï¼Œå› æ­¤ä¹Ÿæ¯æ¬¡è¦è¿”å›max(dfs(n - 1, false), dfs(n - 1, true))äº† å¥½ï¼Œè¿™æ—¶ç‚¹å‡»æäº¤ï¼ä¼šå‘ç°è¶…æ—¶äº†ï¼è¿™æ—¶å› ä¸ºæˆ‘ä»¬åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­é‡å¤è®¡ç®—äº†å­é—®é¢˜ï¼Œé€ æˆäº†ä¸å¿…è¦çš„å¼€é”€\nå¦‚å›¾ï¼Œä»¥ä¸Šçº¢è‰²çš„éƒ¨åˆ†éƒ½æ˜¯é‡å¤çš„ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨è®¡ç®—çš„æ—¶å€™ä¿å­˜å®ƒä»¬ï¼Œè¿™å°±æ˜¯è®°å¿†åŒ–æœç´¢\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®°å¿†åŒ–æ•°ç»„cacheåˆå§‹åŒ–åº”è¯¥ä¸º-1è€Œä¸æ˜¯0,æ˜¯å› ä¸ºè®¡ç®—çš„åˆ©æ¶¦æœ‰å¯èƒ½æ˜¯0\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cache(n, vector\u0026lt;int\u0026gt;(2, -1)); function\u0026lt;int(int, bool)\u0026gt; dfs = [\u0026amp;](int i , bool hold) { if (i \u0026lt; 0) { return hold ? INT_MIN : 0; } int res = cache[i][hold]; if (res != -1) { return res; } if (hold) { // ç¬¬iå¤©æŒæœ‰ res = max(dfs(i - 1, true), dfs(i - 1, false) - prices[i]); cache[i][hold] = res; return res; } // ç¬¬iå¤©æœªæŒæœ‰ res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]); cache[i][hold] = res; return res; }; return dfs(n - 1, false); } }; é€’æ¨ä¸ºdp ç”±ä»¥ä¸Šçš„è®°å¿†åŒ–æœç´¢å’ŒçŠ¶æ€æœºæ€è·¯ï¼Œå°±ä¸éš¾å°†å…¶1ï¼š1ç¿»è¯‘ä¸ºé€’æ¨äº†\nä½†ç”±äºdp[i - 1][hold]ä¸­çš„i - 1å¯èƒ½ä¸ºä¸€ä¸ªè´Ÿæ•°ï¼Œæ•…æˆ‘ä»¬éœ€è¦åœ¨dpå‰æ·»åŠ ä¸€ä¸ªå“¨å…µä½ï¼Œä¸”iéƒ½å˜ä¸ºi + 1\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(2, 0)); dp[0][0] = 0; dp[0][1] = INT_MIN; for (int i = 0; i \u0026lt; n; i++) { dp[i + 1][0] = max(dp[i][0], dp[i][1] + prices[i]); dp[i + 1][1] = max(dp[i][1], dp[i][0] - prices[i]); } return dp[n][0]; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BAdp/","summary":"\u003cblockquote\u003e\n\u003cp\u003eæœ¬ç¯‡æ–‡ç« æ€è·¯æ¥æºäº @bilibili/\u003ca href=\"https://space.bilibili.com/206214\"\u003eçµèŒ¶å±±è‰¾åºœ\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eé¢˜ç›®æè¿°ï¼š\u003ca href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii\"\u003ehttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eç›¸å¯¹äºä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIï¼Œè¯¥é—®é¢˜å¯ä»¥å¤šæ¬¡ä¹°å…¥å’Œå–å‡ºè‚¡ç¥¨ä»¥è·å–æœ€å¤§åˆ©ç›Š\u003c/p\u003e","title":"è‚¡ç¥¨é—®é¢˜ä¸çŠ¶æ€æœºdp"},{"content":"å‰è¨€ é€šè¿‡ä¸€ä¸ªé¡¹ç›®æ¥å­¦ä¹ ä¸€ä¸‹å¦‚ä½•è®¾è®¡ä¸€ä¸ªå¤šæœåŠ¡çš„ç³»ç»Ÿã€‚åŒæ—¶ä¹Ÿèƒ½å­¦ä¹ Spring Cloud Gatewayã€Dubboã€APIç­¾åç­‰ä¸€äº›çŸ¥è¯†ã€‚\né¡¹ç›®æ¶æ„ ç”¨æˆ·å‰å° æ™®é€šç”¨æˆ· ä¾‹å¦‚ç®¡ç†å‘˜å‘å¸ƒäº†ä¸€ä¸ªæ–°çš„æ¥å£Aï¼Œå¦‚æœä¸€ä½å¼€å‘è€…å¹¶æ²¡æœ‰æ³¨å†Œä¸ºè¯¥å¹³å°çš„ç”¨æˆ·ï¼Œé‚£ä¹ˆå³ä¾¿è¿™ä½å¼€å‘è€…æ‹¿åˆ°äº†è¿™ä¸ªæ¥å£åœ°å€ï¼Œä¹Ÿæ˜¯ä¸å¯ä»¥ä½¿ç”¨æ¥å£Açš„ã€‚\nå½“ä»–æ³¨å†Œä¸ºå¹³å°ç”¨æˆ·åï¼Œåå°ä¼šç»™ä»–ç”ŸæˆAccessKeyå’ŒSecretKeyï¼ˆåæ–‡ç®€ç§°ä¸ºakå’Œskï¼‰ç”¨äºAPIç­¾åè®¤è¯ï¼Œè¿™æ—¶ï¼Œç”¨æˆ·å¸¦ç€è¿™ä¸¤ä¸ªkeyï¼Œå°±å¯é€šè¿‡å‰å°æä¾›çš„åœ¨çº¿æµ‹è¯•æˆ–è€…å®¢æˆ·ç«¯SDKæ¥è°ƒç”¨æƒ³è¦çš„æ¥å£äº†ã€‚\nç®¡ç†å‘˜ ç®¡ç†å‘˜èŒè´£å°±æ˜¯ç®¡ç†æ¥å£ï¼ŒåŒ…æ‹¬æ¥å£çš„ä¸Šçº¿ã€ä¸‹çº¿ã€æ·»åŠ ç­‰\nå®¢æˆ·ç«¯SDKï¼ˆapi-client-sdkï¼‰ è‹¥ç®¡ç†å‘˜å°†æ¥å£ä¸‹çº¿ï¼Œåˆ™è¯·æ±‚æ— æ•ˆ\né€šè¿‡AccessKeyå’ŒSecretKeyæ¥è¯·æ±‚api-interfaceæ¥å£æœåŠ¡ã€‚å…¶ä¸­akå’Œskåªæœ‰ç”¨æˆ·åœ¨å¹³å°æ³¨å†Œè´¦å·åæ‰ä¼šåˆ†ã€‚å½“ç„¶ï¼Œæ·»åŠ ç½‘å…³åï¼Œåº”è¯¥åœ¨api-interfaceå‰ä½¿ç”¨æ·»åŠ ä¸€å±‚ç½‘å…³æœåŠ¡æ¥é¿å…apiæ¥å£çš„ç›´æ¥æš´éœ²\nsdkä¸­çš„è¯·æ±‚æ–¹æ³•åº”è¯¥å’Œapi-interfaceä¸­æä¾›çš„æ¥å£ä¸€ä¸€å¯¹åº”ï¼Œä¹Ÿå°±æ˜¯ä¸¤è¾¹åº”è¯¥åŒæ­¥ä¿®æ”¹\nç½‘å…³ï¼ˆapi-gatewayï¼‰ ä½¿ç”¨Spring Cloud Gatewayæ¥å®Œæˆä¸€ä¸‹åŠŸèƒ½\nç»Ÿä¸€é‰´æƒè®¤è¯ï¼šåº”ç”¨ API ç­¾åè®¤è¯ç®—æ³•æ ¡éªŒç”¨æˆ·è¯·æ±‚çš„åˆæ³•æ€§ã€‚æ ¹æ®è¯·æ±‚æ‹¿åˆ°ç”¨æˆ·ä¿¡æ¯åä»æ•°æ®åº“ä¸­è·å–akã€skè¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœç›¸åŒåˆ™ä»£è¡¨ç”¨æˆ·è¯·æ±‚åˆæ³• å…¬å…±ä¸šåŠ¡é€»è¾‘ï¼šå¯¹æ¯ä¸ªæ¥å£çš„è°ƒç”¨è¿›è¡Œé›†ä¸­çš„ç»Ÿè®¡ ã€‚è¿™ç±»ä¼¼äºSpring MVCä¸­çš„æ‹¦æˆªå™¨å’ŒSpringä¸­çš„AOP è·¯ç”±è½¬å‘ï¼šå‰ç«¯å‘é€è¯·æ±‚åˆ° API ç½‘å…³ï¼Œé€šè¿‡ç½‘å…³è½¬å‘åˆ°å®é™…çš„ API æ¥å£ ã€‚è¿™æ ·å°±é¿å…äº†ç›´æ¥å°†å®Œæ•´çš„æ¥å£åœ°å€æš´éœ²å‡ºæ¥ æµé‡æŸ“è‰²ï¼šç»™ç»è¿‡ç½‘å…³çš„è¯·æ±‚åŠ ä¸Šç‰¹å®šçš„è¯·æ±‚å¤´å‚æ•°ï¼Œä¾¿äºè®©å®é™…çš„ API æœåŠ¡ç¡®å®šè¯·æ±‚æ¥æºåŠåˆæ³•æ€§ æ¥å£æœåŠ¡ï¼ˆapi-interfaceï¼‰ çœŸæ­£å®ç°å’Œæä¾›æ¥å£çš„åœ°æ–¹ï¼Œå¯ä»¥åªç¼–å†™controllerå±‚\næŠ½è±¡æ¥å£ï¼ˆapi-commonï¼‰ åœ¨ç½‘å…³å±‚ç”±äºè¦è¿›è¡ŒAPIé‰´æƒï¼Œè¿™é¿å…ä¸æ–™è¦æŸ¥è¯¢æ•°æ®åº“ï¼Œä½†æ˜¯ç½‘å…³æœåŠ¡é¡¹ç›®å¹¶æ²¡æœ‰ä½¿ç”¨MyBatis-Plusï¼Œä¸ºäº†é¿å…å†™é‡å¤çš„ä»£ç ï¼Œåˆ©ç”¨Dubboåˆ†å¸ƒå¼æ”¹é€ ï¼Œä½¿å¾—ç½‘å…³å±‚å¯ä»¥é€šè¿‡RPCæ¥è°ƒç”¨åç«¯æœåŠ¡çš„æ–¹æ³•\næœåŠ¡åå°ï¼ˆapi-backendï¼‰ æœ€æ ¸å¿ƒçš„ä¸šåŠ¡å±‚æœåŠ¡ï¼\nç”¨æˆ·æ³¨å†Œæ—¶ä¼šè‡ªåŠ¨ç”Ÿæˆå…¶akå’Œsk æ¥å£ä¿¡æ¯çš„ç®¡ç†ï¼Œå³æ™®é€šçš„å¢åˆ æ”¹æŸ¥ï¼Œå‘å¸ƒã€ä¸‹çº¿æ¥å£ æ¥å£è°ƒç”¨ç»Ÿè®¡ï¼ˆæ²¡é”™ï¼Œç½‘å…³æ˜¯é€šè¿‡rpcè°ƒç”¨è¿™é‡Œçš„æœåŠ¡ï¼‰ å½“å‰å°ç”¨æˆ·è¦è¿›è¡Œåœ¨çº¿æµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨åˆ°ç”¨æˆ·çš„akå’Œskï¼Œåªæœ‰è¿™æ ·æ‰èƒ½å¤Ÿæ¯”è¾ƒå®‰å…¨çš„è°ƒç”¨æ¥å£ï¼›è€Œå†é€šè¿‡å®¢æˆ·ç«¯SDKï¼Œå°±èƒ½æ¯”è¾ƒæ–¹ä¾¿åœ°å»è¯·æ±‚æ¥å£ ","permalink":"https://kerolt.github.io/posts/%E5%90%8E%E7%AB%AF/api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eé€šè¿‡ä¸€ä¸ªé¡¹ç›®æ¥å­¦ä¹ ä¸€ä¸‹å¦‚ä½•è®¾è®¡ä¸€ä¸ªå¤šæœåŠ¡çš„ç³»ç»Ÿã€‚åŒæ—¶ä¹Ÿèƒ½å­¦ä¹ Spring Cloud Gatewayã€Dubboã€APIç­¾åç­‰ä¸€äº›çŸ¥è¯†ã€‚\u003c/p\u003e\n\u003ch2 id=\"é¡¹ç›®æ¶æ„\"\u003eé¡¹ç›®æ¶æ„\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://gitee.com/kerolt/picture/raw/main/20241216-143608.png\"\u003e\u003c/p\u003e","title":"APIå¼€æ”¾å¹³å°"},{"content":"å‰è¨€ std::couté‡è½½äº†\u0026lt;\u0026lt;è¿ç®—ç¬¦ï¼Œè¿™ä½¿å¾—å†™ä¸€äº›å¾ˆçŸ­çš„ä»£ç æ—¶å¾ˆæ–¹ä¾¿ã€‚ä½†æ˜¯å¦‚æœåœ¨å¤šçº¿ç¨‹çš„æ¡ä»¶ä¸‹ï¼Œcoutå¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚\nä¸¾ä¾‹ ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬åˆ›å»º5ä¸ªçº¿ç¨‹\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void Test() { std::cout \u0026lt;\u0026lt; \u0026#34;msg1\u0026#34; \u0026lt;\u0026lt; \u0026#34; msg2\u0026#34; \u0026lt;\u0026lt; \u0026#34; msg3\u0026#34; \u0026lt;\u0026lt; \u0026#34; thread_id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; std::endl; } int main() { std::thread threads[5]; for (int i = 0; i \u0026lt; 5; i++) { threads[i] = std::thread(Test); } for (int i = 0; i \u0026lt; 5; i++) { threads[i].join(); } } å®é™…ä¸Šï¼Œçœ‹æ ·å­å¥½åƒæ§åˆ¶å°åº”è¯¥è¾“å‡º5è¡Œå†…å®¹ï¼Œä½†æ˜¯è¿è¡Œç»“æœå¯èƒ½æ˜¯è¿™æ ·çš„\nmsg1 msg2 msg3 thread_id = msg1 msg2 msg3 thread_id = 139926598575808139926606968512 msg1 msg2 msg3 thread_id = 139926590183104 msg1 msg2 msg3 thread_id = 139926455965376 msg1 msg2 msg3 thread_id = 139926581790400 è¿™æ˜¯å› ä¸ºcoutåœ¨ä½¿ç”¨æ—¶å¯èƒ½ä¼šå­˜åœ¨çº¿ç¨‹ä¹‹é—´çš„æ‰“å°ä¿¡æ¯ä¹±ä¸²çš„é—®é¢˜ï¼Œçœ‹ä¸€ä¸‹ç¼–è¯‘å™¨çœ¼ä¸­æˆ‘ä»¬è¿™æ®µç¨‹åºä¸­çš„coutæ˜¯ä»€ä¹ˆæ ·çš„ï¼š\nstd::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;msg1\u0026#34;), \u0026#34; msg2\u0026#34;), \u0026#34; msg3\u0026#34;), \u0026#34; thread_id = \u0026#34;), std::this_thread::get_id()).operator\u0026lt;\u0026lt;(std::endl); å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸æ˜¯é€šè¿‡å•ä¸ª std::operator\u0026lt;\u0026lt; è°ƒç”¨å®Œæˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ“ä½œå¹¶ä¸æ˜¯åŸå­çš„\nè§£å†³æ–¹æ³• ä½¿ç”¨std::formatï¼ˆC++20ï¼‰ ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼Œå¦‚follyï¼Œfmtlibç­‰ ä½¿ç”¨stringstream \u0026hellip;\u0026hellip; è¿™é‡Œä½¿ç”¨stringstreamåšä¸ªæ¼”ç¤ºã€‚å°†Testå‡½æ•°ä¿®æ”¹å¦‚ä¸‹ï¼š\nstd::stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;msg1\u0026#34; \u0026lt;\u0026lt; \u0026#34; msg2\u0026#34; \u0026lt;\u0026lt; \u0026#34; msg3\u0026#34; \u0026lt;\u0026lt; \u0026#34; thread_id = \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ss.str(); è¿™æ ·ï¼Œæ§åˆ¶å°çš„è¾“å‡ºå°±ä¸ä¼šä¹±ä¸²äº†ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/%E9%81%BF%E5%85%8Dcout%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%81%9A%E6%B3%95/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::cout\u003c/code\u003eé‡è½½äº†\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003eè¿ç®—ç¬¦ï¼Œè¿™ä½¿å¾—å†™ä¸€äº›å¾ˆçŸ­çš„ä»£ç æ—¶å¾ˆæ–¹ä¾¿ã€‚ä½†æ˜¯å¦‚æœåœ¨å¤šçº¿ç¨‹çš„æ¡ä»¶ä¸‹ï¼Œcoutå¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚\u003c/p\u003e","title":"é¿å…coutçº¿ç¨‹ä¸å®‰å…¨çš„ä¸€ä¸ªåšæ³•"},{"content":"ä¹‹å‰å¯¹äºç§»åŠ¨è¯­ä¹‰çš„ç†è§£å°±æ˜¯ä½¿ç”¨std::moveå°†ä¸€ä¸ªå¯¹è±¡æ‰€å æœ‰çš„èµ„æºçš„æ‰€æœ‰æƒè½¬ç§»ç»™å¦ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯åªè¦ä½¿ç”¨std::moveå°±è¶³å¤Ÿäº†å—ï¼Ÿè¿™æ˜¾ç„¶æ˜¯é”™è¯¯çš„ã€‚\nçœ‹ä¸€ä¸‹std::moveçš„æºç ï¼ˆg++12.2ï¼‰\n/** * @brief Convert a value to an rvalue. * @param __t A thing of arbitrary type. * @return The parameter cast to an rvalue-reference to allow moving it. */ template\u0026lt;typename _Tp\u0026gt; _GLIBCXX_NODISCARD constexpr typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; move(_Tp\u0026amp;\u0026amp; __t) noexcept { return static_cast\u0026lt;typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(__t); } å…¶å®moveçš„å®ç°å¹¶æ²¡æœ‰å¾ˆå¤æ‚ï¼Œç²—ç•¥ä¸€ç‚¹çš„ç†è§£å°±æ˜¯å°†ä¸€ä¸ªå·¦å€¼å¼ºåˆ¶è½¬æ¢ä¸ºå³å€¼ã€‚\nstd::move å¹¶ä¸ä¼šçœŸæ­£åœ°ç§»åŠ¨å¯¹è±¡ï¼ŒçœŸæ­£çš„ç§»åŠ¨æ“ä½œæ˜¯åœ¨ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼å‡½æ•°ç­‰å®Œæˆçš„ï¼Œstd::move åªæ˜¯å°†å‚æ•°è½¬æ¢ä¸ºå³å€¼å¼•ç”¨è€Œå·²ã€‚\nå†™ä¸€ä¸ªç®€å•çš„ä¾‹å­å¦‚ä¸‹ï¼š\n#include \u0026lt;fmt/core.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; struct A { A(std::string str) : data(str) {} A(const A\u0026amp;) { puts(\u0026#34;copy\u0026#34;); } A(A\u0026amp;\u0026amp;) { puts(\u0026#34;move\u0026#34;); } std::string data = \u0026#34;default\u0026#34;; }; int main() { A a(\u0026#34;hello\u0026#34;); A a2(std::move(a)); fmt::print(\u0026#34;a: {}, a2: {}\\n\u0026#34;, a.data, a2.data); } çœ‹æ ·å­æˆ‘ä»¬ä½¿ç”¨std::moveåa2çš„dataæ•°æ®åº”è¯¥ä¸ºâ€œhelloâ€ï¼Œä½†æ˜¯è¿è¡Œç»“æœä¸º\nmove a: hello, a2: default è™½ç„¶ä½¿ç”¨moveåŒ¹é…åˆ°äº†Açš„ç§»åŠ¨æ„é€ å‡½æ•°ï¼Œä½†æ˜¯åœ¨ä¸Šæ–‡æåˆ°è¿‡ï¼Œstd::moveä»…ä»…åªæ˜¯ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢ï¼Œå¹¶æ²¡æœ‰å®ç°çœŸæ­£çš„ç§»åŠ¨ï¼ä½†è¦æ˜¯æˆ‘ä»¬ä¸å†™Aä¸­çš„ç§»åŠ¨æ„é€ å‡½æ•°æˆ–æ˜¯å°†å…¶è®¾ç½®æˆdefaultï¼š\nstruct A { A(std::string str) : data(str) {} A(const A\u0026amp;) { puts(\u0026#34;copy\u0026#34;); } A(A\u0026amp;\u0026amp;) = default; std::string data = \u0026#34;default\u0026#34;; }; è¿™æ ·ï¼Œè¿è¡Œç»“æœä¸º\na: , a2: hello è¿™æ˜¯å› ä¸ºå½“æˆ‘ä»¬ä¸æ˜¾å¼æŒ‡å®šç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆæˆ–æ˜¯æ‹·è´æ„é€ å‡½æ•°ã€ç§»åŠ¨oræ‹·è´è¿ç®—ç¬¦ï¼‰ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆï¼Œè²Œä¼¼ä¹Ÿä¸€å¹¶å®ç°äº†æ•°æ®çš„ç§»åŠ¨ï¼ˆï¼Ÿè¿™æˆ‘ä¹Ÿè¿˜ä¸æ¸…æ¥šï¼‰\næˆ‘ä»¬é€šå¸¸ä½¿ç”¨std::moveèƒ½å¤Ÿå®ç°æ ‡å‡†åº“ä¸­ä¸€äº›èµ„æºçš„è½¬ç§»ï¼Œæ˜¯å› ä¸ºæ ‡å‡†åº“ä¸­å·²ç»å®ç°äº†è¿™äº›èµ„æºç±»çš„ç§»åŠ¨æ„é€ å‡½æ•°orç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/%E7%BA%A0%E6%AD%A3%E4%B8%80%E4%B8%8B%E5%AF%B9cpp%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E9%94%99%E8%AF%AF%E7%90%86%E8%A7%A3/","summary":"\u003cp\u003eä¹‹å‰å¯¹äºç§»åŠ¨è¯­ä¹‰çš„ç†è§£å°±æ˜¯ä½¿ç”¨std::moveå°†ä¸€ä¸ªå¯¹è±¡æ‰€å æœ‰çš„èµ„æºçš„æ‰€æœ‰æƒè½¬ç§»ç»™å¦ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯åªè¦ä½¿ç”¨std::moveå°±è¶³å¤Ÿäº†å—ï¼Ÿè¿™æ˜¾ç„¶æ˜¯é”™è¯¯çš„ã€‚\u003c/p\u003e","title":"çº æ­£ä¸€ä¸‹å¯¹cppç§»åŠ¨è¯­ä¹‰çš„é”™è¯¯ç†è§£"},{"content":"æƒ³å†™è¿™ç¯‡åšå®¢çš„åŸå› æ˜¯åœ¨åˆ·åŠ›æ‰£çš„ 347. å‰ K ä¸ªé«˜é¢‘å…ƒç´  ä¸€é¢˜æ—¶ï¼Œéœ€è¦ä½¿ç”¨åˆ°ä¼˜å…ˆé˜Ÿåˆ—priority_queueï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š\ntemplate\u0026lt; class T, class Container = std::vector\u0026lt;T\u0026gt;, class Compare = std::less\u0026lt;typename Container::value_type\u0026gt; \u0026gt; class priority_queue; ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå¯ä»¥è‡ªå®šä¹‰çš„æ¯”è¾ƒç±»å‹ï¼Œå…¶å¿…é¡»æ»¡è¶³äºŒå…ƒè°“è¯ï¼Œé€šå¸¸å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä¸¤ç§æ–¹æ³•ï¼š\nä½¿ç”¨è‡ªå®šä¹‰çš„å‡½æ•°å¯¹è±¡ lambdaè¡¨è¾¾å¼ ä½¿ç”¨std::greateræˆ–std::lessï¼ˆè¿™é‡Œå°±ä¸ä»‹ç»è¿™ç§æ–¹æ³•äº†ï¼‰ ä»¥é¢˜ 347. å‰ K ä¸ªé«˜é¢‘å…ƒç´  ä¸ºä¾‹ï¼Œæˆ‘ä»¬è¦å»ºç«‹ä¸€ä¸ªå°æ ¹å †ï¼Œé‚£ä¹ˆä»£ç å¦‚ä¸‹ï¼š\n// æ–¹æ³•ä¸€ using PII = pair\u0026lt;int, int\u0026gt;; // æ¯”è¾ƒç±»ï¼Œé‡è½½äº†æ‹¬å·è¿ç®—ç¬¦ struct Comp { bool operator()(PII\u0026amp; p1, PII\u0026amp; p2) { return p1.second \u0026gt; p2.second; } }; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, Comp\u0026gt; pq; å½“ç„¶ï¼Œå¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨lambdaè¡¨è¾¾å¼ï¼Œå¦‚ä¸‹ï¼š\n// æ–¹æ³•äºŒ using PII = pair\u0026lt;int, int\u0026gt;; auto comp = [](PII\u0026amp; p1, PII\u0026amp; p2) { return p1.second \u0026gt; p2.second; }; // æ³¨æ„è¿™é‡Œéœ€è¦ä½¿ç”¨decltype priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, decltype(comp)\u0026gt; pq; ä½†å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ–¹æ³•äºŒéœ€è¦åœ¨C++20ä¸‹æ‰å¯ä½¿ç”¨ã€‚è¿™æ˜¯å› ä¸ºpriority_queueçš„ç¬¬ä¸‰ä¸ªæ¨¡æ¿å½¢å‚éœ€è¦çš„äºŒå…ƒè°“è¯è¦æ±‚å¯å¤åˆ¶æ„é€ ã€‚\nlambdaè¡¨è¾¾å¼å³æ„é€ é—­åŒ…ï¼ˆèƒ½å¤Ÿæ•è·ä½œç”¨åŸŸä¸­çš„å˜é‡çš„æ— åå‡½æ•°å¯¹è±¡ï¼‰ã€‚è€Œåœ¨C++20ä¹‹å‰ï¼Œé—­åŒ…ç±»å‹éå¯é»˜è®¤æ„é€ ï¼Œé—­åŒ…ç±»å‹æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°ã€‚C++20åŠä¹‹åï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šæ•è·ï¼Œé‚£ä¹ˆé—­åŒ…ç±»å‹æ‹¥æœ‰é¢„ç½®çš„é»˜è®¤æ„é€ å‡½æ•°ã€‚\nè€Œåœ¨ç›®å‰ï¼ŒåŠ›æ‰£ä¸­C++ç¼–è¯‘å™¨ä½¿ç”¨çš„æ˜¯clang17ï¼Œæ”¯æŒC++20ï¼Œæ•…ä½¿ç”¨lambdaè¡¨è¾¾å¼æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚\n","permalink":"https://kerolt.github.io/posts/c++/c++%E4%B8%ADlambda%E4%B8%8Epriority_queue%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003eæƒ³å†™è¿™ç¯‡åšå®¢çš„åŸå› æ˜¯åœ¨åˆ·åŠ›æ‰£çš„ \u003ca href=\"https://leetcode.cn/problems/top-k-frequent-elements/\"\u003e347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ \u003c/a\u003e ä¸€é¢˜æ—¶ï¼Œéœ€è¦ä½¿ç”¨åˆ°ä¼˜å…ˆé˜Ÿåˆ—\u003ccode\u003epriority_queue\u003c/code\u003eï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etemplate\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eContainer\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCompare\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eless\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"k\"\u003etypename\u003c/span\u003e \u003cspan class=\"n\"\u003eContainer\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003evalue_type\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003epriority_queue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå¯ä»¥è‡ªå®šä¹‰çš„æ¯”è¾ƒç±»å‹ï¼Œå…¶å¿…é¡»æ»¡è¶³\u003ca href=\"https://zh.cppreference.com/w/cpp/named_req/BinaryPredicate\"\u003eäºŒå…ƒè°“è¯\u003c/a\u003eï¼Œé€šå¸¸å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä¸¤ç§æ–¹æ³•ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eä½¿ç”¨è‡ªå®šä¹‰çš„å‡½æ•°å¯¹è±¡\u003c/li\u003e\n\u003cli\u003elambdaè¡¨è¾¾å¼\u003c/li\u003e\n\u003cli\u003eä½¿ç”¨\u003ccode\u003estd::greater\u003c/code\u003eæˆ–\u003ccode\u003estd::less\u003c/code\u003eï¼ˆè¿™é‡Œå°±ä¸ä»‹ç»è¿™ç§æ–¹æ³•äº†ï¼‰\u003c/li\u003e\n\u003c/ol\u003e","title":"C++ä¸­lambdaä¸priority_queueä¸€èµ·ä½¿ç”¨"},{"content":"ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬åœ¨C++ç¨‹åºä¸­è¦ä½¿ç”¨mysqlçš„åº“ï¼Œæœ€ç®€å•çš„å°±æ˜¯\ng++ server.cpp -o server -lmysqlclient ä½†è¦æ˜¯åœ¨å¤§ä¸€ç‚¹çš„é¡¹ç›®ä¸­ï¼Œåœ¨æ•°ä¸æ¸…çš„æºæ–‡ä»¶ä¸‹ä½¿ç”¨g++å‘½ä»¤æ¥å®Œæˆï¼Œæ€•æ˜¯ä¸å¤ªç°å®ã€‚\né€šå¸¸ä½¿ç”¨çš„å·¥å…·ä¸ºCMakeï¼Œç”¨å…¶æ¥æ„å»ºé¡¹ç›®ï¼Œä½†å®ƒåˆæ²¡æœ‰åŒ…ç®¡ç†åŠŸèƒ½ï¼Œå¯¹äºæˆ‘ä»¬æƒ³è¦ä½¿ç”¨çš„åº“ï¼Œéœ€è¦åœ¨ CMakeLists.txt ä¸­å¼•å…¥ã€‚\nå¼•ç”¨çš„æ–¹å¼æˆ‘è¿™é‡Œé€‰æ‹© find_pakage ï¼ˆå…¶æ¦‚è¿°å’Œä½¿ç”¨æ–¹æ³•è¿™é‡Œå°±ä¸è¿‡å¤šèµ˜è¿°äº†ï¼‰\nset(CMAKE_MODULE_PATH /usr/share/cmake/Modules) find_package(MySQL REQUIRED) add_executable(server ${src_list}) if(MYSQL_FOUND) target_link_libraries(server ${MYSQL_LIBRARIES}) else(MYSQL_FOUND) message(FATAL_ERROR \u0026#34;MySQL library not found\u0026#34;) endif(CURL_FOUND) å¯¹ä¸Šé¢çš„ä»£ç åšä¸€ä¸‹è§£é‡Šï¼š\né¦–å…ˆè®¾ç½®ä¸€ä¸‹cmake moduleçš„è·¯å¾„ï¼Œå…¶å®å°±æ˜¯å­˜æ”¾.cmakeæ–‡ä»¶çš„ä½ç½®ã€‚æœ‰æ—¶å€™çœ‹ä¸€äº›é¡¹ç›®ï¼Œä¼šå‘ç°å…¶æ ¹ç›®å½•ä¸‹ä¼šæœ‰ä¸€ä¸ªcmakeç›®å½•ï¼Œè¯¶ï¼Œæ²¡é”™ï¼Œå°±å’Œè¿™ä¸ªä¸€æ · ä½¿ç”¨find_packageæ¥å¼•å…¥ä¾èµ–åº“ æ·»åŠ å¯æ‰§è¡Œç¨‹åºserver å¦‚æœä½¿ç”¨find_packageæ‰¾åˆ°äº†MySQLåº“ï¼Œåˆ™å°†å…¶é“¾æ¥åˆ°serverä¸Šï¼Œå¦åˆ™ç»ˆæ­¢æ„å»º å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨CMAKE_MODULE_PATHç›®å½•ä¸‹ï¼Œå¿…é¡»æœ‰Find\u0026lt;LibaryName\u0026gt;.cmake æ¨¡å—ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œå³ä¸º FindMySQL.cmakeï¼Œè¯¥æ–‡ä»¶å¯åœ¨ç½‘ä¸Šæ‰¾åˆ°ã€‚\n","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/cmake%E4%B8%AD%E4%BD%BF%E7%94%A8find_pakage%E6%9D%A5%E4%BD%BF%E7%94%A8mysql/","summary":"\u003cp\u003eä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬åœ¨C++ç¨‹åºä¸­è¦ä½¿ç”¨mysqlçš„åº“ï¼Œæœ€ç®€å•çš„å°±æ˜¯\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eg++ server.cpp -o server -lmysqlclient\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eä½†è¦æ˜¯åœ¨å¤§ä¸€ç‚¹çš„é¡¹ç›®ä¸­ï¼Œåœ¨æ•°ä¸æ¸…çš„æºæ–‡ä»¶ä¸‹ä½¿ç”¨g++å‘½ä»¤æ¥å®Œæˆï¼Œæ€•æ˜¯ä¸å¤ªç°å®ã€‚\u003c/p\u003e","title":"CMakeä¸­ä½¿ç”¨find_pakageæ¥ä½¿ç”¨MySQL"},{"content":"è®°å½•å­¦ä¹  CMake ä¸­ç¢°åˆ°çš„ä¸€äº›é—®é¢˜å’Œç¬”è®°\npsï¼šCMake ç›¸æ¯” xmake æ¥è¯´ç¡®å®å¤ªç¹çï¼Œä½†è¿˜æ˜¯å¾—å­¦ä¹ ğŸ­\nç°ä»£ CMake çš„å‘½ä»¤è¡Œæ„å»º åœ¨â€œå¤ä»£â€CMake ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦æ„å»ºé¡¹ç›®è¦è¿™æ ·ï¼š\nmkdir build cd build cmake .. make å¤ªå•°å—¦äº†ï¼Œæœ€åä¸€æ­¥å¯èƒ½è¿˜ç”¨çš„ä¸æ˜¯ make å‘½ä»¤ã€‚ä¸è¿‡åœ¨ç°ä»£ CMake ä¸­ï¼Œæä¾›äº†æ›´ä¸ºæ–¹ä¾¿çš„ -B å’Œ \u0026ndash;buildï¼Œå¦‚ä¸‹ï¼š\ncmake -B build # ç”¨äºç”Ÿæˆæ„å»ºç›®å½•ã€‚-B å‚æ•°åé¢è·Ÿçš„æ˜¯ä¸€ä¸ªç›®å½•åï¼Œè¿™é‡ŒæŒ‡å®šä¸º build cmake --build build # ç”¨äºåœ¨å·²ç»ç”Ÿæˆçš„æ„å»ºç›®å½•ä¸­æ„å»ºé¡¹ç›® è¿™æ ·çœå»äº†åˆ›å»º build ç›®å½•ç­‰ç¹ççš„æ“ä½œï¼Œè¿˜ç»Ÿä¸€äº†ä¸åŒå¹³å°ä¸Šçš„æ„å»ºå‘½ä»¤ã€‚\nå¦‚æœç¢°åˆ°äº†æœ‰å…³ build ç¼“å­˜çš„ç›¸å…³é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ rm åˆ é™¤ build ç›®å½•ï¼Œæˆ–è€…ä½¿ç”¨ cmake --build build --clean-first æ¥åœ¨æ„å»ºä¹‹å‰å…ˆæ¸…ç†æ„å»ºç›®å½•ã€‚\næ·»åŠ æºæ–‡ä»¶çš„å‡ ç§æ–¹æ³• å‡è®¾å½“å‰é¡¹ç›®æ–‡ä»¶ç›®å½•å¦‚ä¸‹ï¼š\n. â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ include â”‚ â””â”€â”€ add.h â””â”€â”€ src â”œâ”€â”€ add.cpp â””â”€â”€ main.cpp å³å½“å‰é¡¹ç›®çš„æºæ–‡ä»¶ä¸º src ç›®å½•ä¸‹çš„ cpp æ–‡ä»¶ï¼Œåœ¨é¡¶å±‚çš„ CMakeLists.txt ä¸­æ·»åŠ æºæ–‡ä»¶ç›®æ ‡ï¼š\n# æ–¹æ³•ä¸€ file(GLOB SOURCE_FILES \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\u0026#34;) # æ–¹æ³•äºŒ file(GLOB_RECURSE SOURCE_FILES CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/*.cpp) # æ–¹æ³•ä¸‰ aux_source_directory(${PROJECT_SOURCE_DIR}/src SOURCE_FILES) # æ·»åŠ ä¸‹é¢è¿™ä¸€å¥å³ç”¨ä¸Šè¿°æºæ–‡ä»¶ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶appï¼ˆä¹Ÿå¯ä½¿ç”¨add_libraryç”Ÿæˆåº“æ–‡ä»¶ç­‰ï¼‰ add_executable(app ${SOURCE_FILES}) å¯ä»¥çœ‹åˆ°ï¼Œæ–¹æ³•ä¸€å’Œæ–¹æ³•äºŒè™½ç„¶éƒ½æ˜¯ä½¿ç”¨ file æŒ‡ä»¤ï¼Œä½†å†…å®¹å´ç¨æœ‰åŒºåˆ«ï¼š\néƒ½æ˜¯æŒ‰ç…§é€šé…ç¬¦æ‰¹é‡åŒ¹é…æ–‡ä»¶ï¼ŒGLOB å’Œ GLOB_RECURSE çš„åŒºåˆ«åœ¨äºåè€…å…è®¸ * é€’å½’ç›®å½•å»åŒ¹é… å¯¹äºé€‰é¡¹ CONFIGURE_DEPENDSï¼Œå¦‚æœä¸æ·»åŠ ï¼Œåˆ™åœ¨ src/ä¸‹æ·»åŠ æ–°æ–‡ä»¶ï¼Œç”±äº cmake ç¼“å­˜çš„åŸå› ï¼ŒSOURCE_FILES å˜é‡å¹¶ä¸ä¼šæ›´æ–°ï¼Œéœ€è¦é‡æ–°æ‰§è¡Œ cmake -B build è®¾ç½®å¯æ‰§è¡Œæ–‡ä»¶çš„è¾“å‡ºä½ç½® set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) ","permalink":"https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/cmakecmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003eè®°å½•å­¦ä¹  CMake ä¸­ç¢°åˆ°çš„ä¸€äº›é—®é¢˜å’Œç¬”è®°\u003c/p\u003e\n\u003cp\u003epsï¼šCMake ç›¸æ¯” xmake æ¥è¯´ç¡®å®å¤ªç¹çï¼Œä½†è¿˜æ˜¯å¾—å­¦ä¹ ğŸ­\u003c/p\u003e","title":"ã€CMakeã€‘CMakeä½¿ç”¨ç¬”è®°"},{"content":"ä¸‹è½½æºç  é“¾æ¥ï¼šhttps://github.com/chenshuo/muduo/releases/tag/v2.0.2\nç¼–è¯‘å®‰è£… è§£å‹åï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•ä¸­æ›´æ”¹ CMakeLists.txt æ–‡ä»¶\nå¦‚å›¾ï¼Œå°† option å±æ€§æ³¨é‡Šæ‰ï¼ˆè¿™æ˜¯muduoçš„ä¾‹å­çš„ç¼–è¯‘é€‰é¡¹ï¼Œå¦‚æœå¼€å¯å°†å¢åŠ ç¼–è¯‘æ—¶é—´ï¼‰\nä¹‹åï¼Œæ‰§è¡Œ\n./build.sh ./build.sh install å¦‚æœæ²¡æœ‰å‡ºé”™çš„è¯ï¼Œåœ¨ä¸muduo-v2.0.2åŒç›®å½•ä¸‹å°†ç”Ÿæˆä¸€ä¸ª build ç›®å½•ï¼Œå…¶ä¸­æœ‰\nrelease-install-cpp11 â”œâ”€â”€ include â”‚Â â””â”€â”€ muduo â”‚Â â”œâ”€â”€ base â”‚Â â””â”€â”€ net â”‚Â â”œâ”€â”€ http â”‚Â â””â”€â”€ inspect â””â”€â”€ lib å°†includeç›®å½•å’Œlibç›®å½•ä¸‹çš„å†…å®¹å¤åˆ¶åˆ°ç³»ç»Ÿè·¯å¾„ä¸‹ï¼š\nmv include/muduo /usr/local/include mv lib/* /usr/local/lib okï¼Œç°åœ¨å°±å¯ä»¥ä½¿ç”¨muduoåº“äº†\næµ‹è¯•ä½¿ç”¨ æµ‹è¯•ä»£ç å¯ä»¥å‚è€ƒåšå®¢ https://www.cnblogs.com/conefirst/articles/15224039.html\n","permalink":"https://kerolt.github.io/posts/c++/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"\u003ch2 id=\"ä¸‹è½½æºç \"\u003eä¸‹è½½æºç \u003c/h2\u003e\n\u003cp\u003eé“¾æ¥ï¼š\u003ca href=\"https://github.com/chenshuo/muduo/releases/tag/v2.0.2\"\u003ehttps://github.com/chenshuo/muduo/releases/tag/v2.0.2\u003c/a\u003e\u003c/p\u003e","title":"muduoç½‘ç»œåº“çš„å®‰è£…"},{"content":"å‰è¨€ åœ¨Vue3é¡¹ç›®ä¸­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä¸Šä¼ å›¾ç‰‡ä¸€èˆ¬å¯ä»¥åˆ©ç”¨element-uiä¸­çš„el-uploadï¼Œä¸ºäº†é¿å…ä»£ç çš„é‡å¤ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±å°è£…ä¸€ä¸ªå›¾ç‰‡ä¸Šä¼ ç»„ä»¶ã€‚\nå…¶ä¸­ï¼Œä¸»è¦å®ç°æ€æƒ³ä¸ºå‰ç«¯åˆ©ç”¨el-uploadç»„ä»¶é€‰æ‹©ä¸Šä¼ çš„å›¾ç‰‡ï¼Œå¹¶åˆ©ç”¨å…¶http-requestå±æ€§æ¥è‡ªå®šä¹‰å‡½æ•°æ¥å®ç°æ–‡ä»¶ä¸Šä¼ è¯·æ±‚ï¼šè¯¥è¯·æ±‚å‡½æ•°ä½¿ç”¨ä¸ƒç‰›äº‘çš„å¯¹è±¡å­˜å‚¨ï¼Œåœ¨é€šè¿‡åç«¯å¾—åˆ°çš„ä¸Šä¼ å‡­è¯tokenåæ¥å®ç°æ–‡ä»¶ä¸Šä¼ ã€‚\nåç«¯ä»£ç  ä½¿ç”¨expressæ¡†æ¶ï¼Œè·å–ä¸ƒç‰›äº‘ä¸Šä¼ å‡­è¯å¹¶å“åº”ç»™å‰ç«¯\né¡¹ç›®ç»“æ„ - routes |- token.js |- index.js - app.js - config.js - package.json å®‰è£…ä¸ƒç‰›äº‘çš„SDKï¼š npm i qiniu è·å–ä¸Šä¼ å‡­è¯ ç¼–å†™è·å–ä¸Šä¼ å‡­è¯çš„ç›¸å…³ä»£ç ï¼š\n/* config.js */ â€‹ const qiniu = require(\u0026#39;qiniu\u0026#39;) â€‹ // åˆ›å»ºä¸Šä¼ å‡­è¯ const accessKey = \u0026#39;*****\u0026#39; // è¿™é‡Œå¡«å†™ä¸ƒç‰›äº‘çš„accessKey const secretKey = \u0026#39;*****\u0026#39;// è¿™é‡Œå¡«å†™ä¸ƒç‰›äº‘çš„secretKey const mac = new qiniu.auth.digest.Mac(accessKey, secretKey) const options = { scope: \u0026#39;*****\u0026#39;, // è¿™é‡Œå¡«å†™ä¸ƒç‰›äº‘ç©ºé—´åç§° expires: 60 * 60 * 24 * 7 // è¿™é‡Œæ˜¯å‡­è¯çš„æœ‰æ•ˆæ—¶é—´ï¼Œé»˜è®¤æ˜¯ä¸€å°æ—¶ } const putPolicy = new qiniu.rs.PutPolicy(options) const uploadToken = putPolicy.uploadToken(mac) â€‹ module.exports = { uploadToken } é…ç½®è·¯ç”± token.js\nconst tokenRouter = require(\u0026#39;express\u0026#39;).Router() const qnconfig = require(\u0026#39;../config\u0026#39;) // å¼•å…¥ä¸ƒç‰›äº‘é…ç½® â€‹ tokenRouter.get(\u0026#39;/qiniu\u0026#39;, (req, res, next) =\u0026gt; { res.status(200).send(qnconfig.uploadToken) }) â€‹ module.exports = tokenRouter index.js\nconst token = require(\u0026#39;./token\u0026#39;) â€‹ module.exports = routes = (app) =\u0026gt; { app.use(\u0026#39;/token\u0026#39;, token) // å¯ä»¥é€šè¿‡/token/qiniuçš„æ–¹å¼è·å–ä¸Šä¼ å‡­è¯ } é¡¹ç›®å¯åŠ¨ const express = require(\u0026#39;express\u0026#39;) const bodyparse = require(\u0026#39;body-parser\u0026#39;) const routers = require(\u0026#39;./route\u0026#39;) â€‹ // åˆ›å»ºæœåŠ¡ const app = express() // è§£ææ•°æ® app.use(bodyparse.json()) â€‹ // è·¯ç”± routes(app) â€‹ // ç›‘å¬3000ç«¯å£ app.listen(3000, () =\u0026gt; { console.log(\u0026#39;this server are running on localhost:3000!\u0026#39;) }) ä½¿ç”¨å‘½ä»¤node app.jså¯åŠ¨é¡¹ç›®ï¼Œè¿™æ—¶è®¿é—®http://localhost:3000/token/qiniuå³å¯è·å–ä¸Šä¼ å‡­è¯äº†ã€‚\nå‰ç«¯ä»£ç  é…ç½®è·¨åŸŸ ç”±äºå‰åç«¯é¡¹ç›®è¿è¡Œåœ¨ä¸åŒçš„ç«¯å£ï¼Œå› æ­¤éœ€è¦è§£å†³è·¨åŸŸé—®é¢˜ï¼Œè¿™é‡Œåœ¨vite.config.jsä¸­è§£å†³å¦‚ä¸‹ï¼š\nserver: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^/api/, \u0026#39;\u0026#39;) } } } çˆ¶ç»„ä»¶ä½¿ç”¨ æˆ‘ä»¬å¸Œæœ›å­ç»„ä»¶ä¸Šä¼ å›¾ç‰‡å¾—åˆ°ä¸€ä¸²urlåçˆ¶ç»„ä»¶èƒ½æ¥å—åˆ°ï¼Œå¹¶ä¸”åœ¨å±•ç¤ºä¸Šä¼ å›¾ç‰‡æ—¶å…¶å°ºå¯¸åº”èƒ½æŒ‡å®šæˆ–è€…æœ‰é»˜è®¤å€¼ã€‚\n\u0026lt;template\u0026gt; \u0026lt;Upload :url=\u0026#34;imageUrl\u0026#34; @upload=\u0026#34;changeUrl\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; â€‹ \u0026lt;script setup\u0026gt; import Upload from \u0026#39;@/components/Upload.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const imageUrl = ref(\u0026#39;\u0026#39;) â€‹ const changeUrl = (url) =\u0026gt; { imageUrl.value = url } \u0026lt;/script\u0026gt; å°è£…ç»„ä»¶Upload.vue è¿™é‡Œåªæ˜¯ç®€å•ä½¿ç”¨axiosï¼Œæ²¡æœ‰å¯¹å…¶è¿›è¡Œå°è£…ã€‚\n\u0026lt;template\u0026gt; \u0026lt;!- action=\u0026#34;https://upload-z2.qiniup.com\u0026#34;ï¼šæ¯ä¸ªåœ°åŒºè®¿é—®åŸŸåä¸åŒï¼Œå…·ä½“å¯é€šè¿‡ https://developer.qiniu.com/kodo/1671/region-endpoint-fq æŸ¥çœ‹ -\u0026gt;\t\u0026lt;el-upload class=\u0026#34;avatar-uploader\u0026#34; action=\u0026#34;https://upload-z2.qiniup.com\u0026#34; :show-file-list=\u0026#34;false\u0026#34; :http-request=\u0026#34;up2qiniu\u0026#34; :before-upload=\u0026#34;beforeUpload\u0026#34; \u0026gt; \u0026lt;img v-if=\u0026#34;props.url\u0026#34; :src=\u0026#34;props.url\u0026#34; class=\u0026#34;avatar\u0026#34; :style=\u0026#34;\u0026#39;width: \u0026#39; + props.width + \u0026#39;px;\u0026#39; + \u0026#39;height: \u0026#39; + props.height + \u0026#39;px;\u0026#39;\u0026#34; /\u0026gt; \u0026lt;el-icon v-else class=\u0026#34;avatar-uploader-icon\u0026#34; :style=\u0026#34;\u0026#39;width: \u0026#39; + props.width + \u0026#39;px;\u0026#39; + \u0026#39;height: \u0026#39; + props.height + \u0026#39;px;\u0026#39;\u0026#34; \u0026gt;\u0026lt;Plus /\u0026gt;\u0026lt;/el-icon\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import { getQiniuToken } from \u0026#39;../api/token\u0026#39; import axios from \u0026#39;axios\u0026#39; import { ElMessage } from \u0026#39;element-plus\u0026#39; const qiniuaddr = \u0026#39;rlr92qkze.hn-bkt.clouddn.com\u0026#39; // è¿™é‡Œæ˜¯ä¸ƒç‰›äº‘å­˜å‚¨å¯¹è±¡ä¸­çš„CDNåŸŸå const imageUrl = ref(\u0026#39;\u0026#39;) // çˆ¶ç»„ä»¶ä¼ å€¼æ—¶ï¼Œé¡»æœ‰å›¾ç‰‡çš„urlï¼›å…¶æ¬¡å¯é€‰æ‹©å›¾ç‰‡çš„å®½é«˜ï¼ˆé»˜è®¤éƒ½ä¸º180ï¼‰ const props = defineProps({ url: String, width: { type: Number, default: 180 }, height: { type: Number, default: 180 } }) const emit = defineEmits([\u0026#39;upload\u0026#39;]) const beforeUpload = (rawFile) =\u0026gt; { if (rawFile.type !== \u0026#39;image/jpg\u0026#39; \u0026amp;\u0026amp; rawFile.type !== \u0026#39;image/png\u0026#39;) { ElMessage.error(\u0026#39;å›¾ç‰‡æ ¼å¼åº”è¯¥æ˜¯pngæˆ–jpg\u0026#39;) return false } else if (rawFile.size / 1024 / 1024 \u0026gt; 2) { ElMessage.error(\u0026#39;å›¾ç‰‡å¤§å°åº”è¯¥å°äº2MB\u0026#39;) return false } return true } /** * ä¸Šä¼ å›¾ç‰‡è‡³ä¸ƒç‰›äº‘ * @param {*} req */ const up2qiniu = (req) =\u0026gt; { const config = { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;multipart/form-data\u0026#39; } } const fileType = req.file.type === \u0026#39;image/png\u0026#39; ? \u0026#39;png\u0026#39; : \u0026#39;jpg\u0026#39; // é‡å‘½åè¦ä¸Šä¼ çš„æ–‡ä»¶ const keyname = \u0026#39;blog\u0026#39; + new Date().getTime() + \u0026#39;.\u0026#39; + fileType axios.get(\u0026#39;/api/token/qiniu\u0026#39;).then(res =\u0026gt; { const formdata = new FormData() formdata.append(\u0026#39;file\u0026#39;, req.file) formdata.append(\u0026#39;token\u0026#39;, res.data) formdata.append(\u0026#39;key\u0026#39;, keyname) // è·å–åˆ°å‡­è¯ä¹‹åå†å°†æ–‡ä»¶ä¸Šä¼ åˆ°ä¸ƒç‰›äº‘ç©ºé—´ axios.post(\u0026#39;https://upload-z2.qiniup.com\u0026#39;, formdata, config).then((res) =\u0026gt; { imageUrl.value = \u0026#39;http://\u0026#39; + qiniuaddr + \u0026#39;/\u0026#39; + res.data.key emit(\u0026#39;upload\u0026#39;, imageUrl.value) // å‘çˆ¶ç»„ä»¶ä¼ é€’å›¾ç‰‡çš„url }) }) } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; .avatar-uploader .avatar { width: 360px; height: 180px; display: block; } .avatar-uploader :deep(.el-upload) { border: 1px dashed var(--el-border-color); border-radius: 6px; cursor: pointer; position: relative; overflow: hidden; transition: var(--el-transition-duration-fast); } .avatar-uploader :deep(.el-upload:hover) { border-color: var(--el-color-primary); } .el-icon.avatar-uploader-icon { font-size: 28px; color: #8c939d; width: 360px; height: 180px; text-align: center; } \u0026lt;/style\u0026gt; ","permalink":"https://kerolt.github.io/posts/%E5%89%8D%E7%AB%AF/vue3%E5%B0%81%E8%A3%85el-upload/","summary":"\u003ch2 id=\"å‰è¨€\"\u003eå‰è¨€\u003c/h2\u003e\n\u003cp\u003eåœ¨Vue3é¡¹ç›®ä¸­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä¸Šä¼ å›¾ç‰‡ä¸€èˆ¬å¯ä»¥åˆ©ç”¨element-uiä¸­çš„\u003ccode\u003eel-upload\u003c/code\u003eï¼Œä¸ºäº†é¿å…ä»£ç çš„é‡å¤ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±å°è£…ä¸€ä¸ªå›¾ç‰‡ä¸Šä¼ ç»„ä»¶ã€‚\u003c/p\u003e\n\u003cp\u003eå…¶ä¸­ï¼Œä¸»è¦å®ç°æ€æƒ³ä¸ºå‰ç«¯åˆ©ç”¨el-uploadç»„ä»¶é€‰æ‹©ä¸Šä¼ çš„å›¾ç‰‡ï¼Œå¹¶åˆ©ç”¨å…¶\u003ccode\u003ehttp-request\u003c/code\u003eå±æ€§æ¥è‡ªå®šä¹‰å‡½æ•°æ¥å®ç°æ–‡ä»¶ä¸Šä¼ è¯·æ±‚ï¼šè¯¥è¯·æ±‚å‡½æ•°ä½¿ç”¨ä¸ƒç‰›äº‘çš„å¯¹è±¡å­˜å‚¨ï¼Œåœ¨é€šè¿‡åç«¯å¾—åˆ°çš„ä¸Šä¼ å‡­è¯tokenåæ¥å®ç°æ–‡ä»¶ä¸Šä¼ ã€‚\u003c/p\u003e","title":"Vue3å°è£…el-upload"},{"content":" https://leetcode.cn/problems/palindrome-linked-list/\nï¼ˆ1ï¼‰å°†é“¾è¡¨è½¬åŒ–ä¸ºæ•°ç»„è¿›è¡Œæ¯”è¾ƒ æ¯”è¾ƒå‘†æ¿çš„åšæ³•ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)â€‹ã€‚\nclass Solution { public: bool isPalindrome(ListNode* head) { vector\u0026lt;int\u0026gt; arr; ListNode* p = head; while (p) { arr.push_back(p-\u0026gt;val); p = p-\u0026gt;next; } int n = arr.size(); for (int i = 0, j = n - 1; i \u0026lt; j; i++, j--) { if (arr[i] != arr[j]) return false; } return true; } }; ï¼ˆ2ï¼‰é€’å½’ é“¾è¡¨ä¹Ÿå…·æœ‰é€’å½’æ€§è´¨ï¼ŒäºŒå‰æ ‘ä¹Ÿä¸è¿‡æ˜¯é“¾è¡¨çš„è¡ç”Ÿã€‚\nåˆ©ç”¨ååºéå†çš„æ€æƒ³ï¼š\nå…ˆä¿å­˜å¤´ç»“ç‚¹ï¼ˆleftï¼Œå…¨å±€å˜é‡ï¼‰ï¼Œç„¶åé€’å½’è‡³æœ€åï¼ˆæœ€æ·±ï¼‰çš„ç»“ç‚¹ï¼ˆrightï¼‰ï¼Œç„¶åæ¯”è¾ƒleftâ€‹å’Œrightâ€‹çš„å€¼ï¼›å¦‚æœç›¸ç­‰ï¼Œç”±é€’å½’æ ˆè¿”å›ä¸Šä¸€å±‚ï¼ˆä¹Ÿå³rightå‘å·¦èµ°ï¼‰ï¼Œå†æ“ä½œleftå‘å³èµ°ï¼Œè¿™æ ·å°±å®ç°äº†leftå’Œrightçš„åŒå‘å¥”èµ´ã€‚\nclass Solution { private: ListNode* left_ = nullptr; bool Traverse(ListNode* right) { if (!right) return true; bool res = Traverse(right-\u0026gt;next); res = res \u0026amp;\u0026amp; (left_-\u0026gt;val == right-\u0026gt;val); left_ = left_-\u0026gt;next; return res; } public: bool isPalindrome(ListNode* head) { left_ = head; return Traverse(head-\u0026gt;next); } }; ï¼ˆ3ï¼‰ä¼˜åŒ–é€’å½’ åˆ©ç”¨æ–¹æ³•äºŒï¼Œçœ‹ä¼¼æ˜¯æ²¡æœ‰ä½¿ç”¨åˆ°é¢å¤–ç©ºé—´äº†ï¼Œä½†å®é™…ä¸Šè¿˜æœ‰é€’å½’æ‰€å¸¦æ¥çš„å‡½æ•°è°ƒç”¨æ ˆçš„å¼€é”€ï¼Œå…¶ç©ºé—´å¤æ‚åº¦ä¹Ÿä¸ºO(n)â€‹ã€‚\nå› æ­¤å¯ä»¥åˆ©ç”¨åŒæŒ‡é’ˆçš„æ€æƒ³ï¼Œæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹åï¼Œå°†å…¶åé¢çš„ç»“ç‚¹åè½¬ã€‚\nusing ListNodePtr = ListNode*; class Solution { private: ListNode* Reverse(ListNode* head) { ListNodePtr cur = head, pre = nullptr; while (cur) { ListNodePtr ne = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = ne; } return pre; } public: bool isPalindrome(ListNode* head) { ListNodePtr fast = head, slow = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } if (fast) slow = slow-\u0026gt;next; ListNodePtr left = head; ListNodePtr right = Reverse(slow); while (right) { if (left-\u0026gt;val != right-\u0026gt;val) return false; left = left-\u0026gt;next; right = right-\u0026gt;next; } return true; } }; ","permalink":"https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","summary":"https://leetcode.cn/problems/palindrome-linked-list/\nï¼ˆ1ï¼‰å°†é“¾è¡¨è½¬åŒ–ä¸ºæ•°ç»„è¿›è¡Œæ¯”è¾ƒ æ¯”è¾ƒå‘†æ¿çš„åšæ³•ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)â€‹ã€‚\nclass Solution { public: bool isPalindrome(ListNode* head) { vector\u0026lt;int\u0026gt; arr; ListNode* p = head; while (p) { arr.push_back(p-\u0026gt;val); p = p-\u0026gt;next; } int n = arr.size(); for (int i = 0, j = n - 1; i \u0026lt; j; i++, j--) { if (arr[i] != arr[j]) return false; } return true; } }; ï¼ˆ2ï¼‰é€’å½’ é“¾è¡¨ä¹Ÿå…·æœ‰é€’å½’æ€§è´¨ï¼ŒäºŒå‰æ ‘ä¹Ÿä¸è¿‡æ˜¯é“¾è¡¨çš„è¡ç”Ÿã€‚\nåˆ©ç”¨ååºéå†çš„æ€æƒ³ï¼š\nå…ˆä¿å­˜å¤´ç»“ç‚¹ï¼ˆleftï¼Œå…¨å±€å˜é‡ï¼‰ï¼Œç„¶åé€’å½’è‡³æœ€åï¼ˆæœ€æ·±ï¼‰çš„ç»“ç‚¹ï¼ˆrightï¼‰ï¼Œç„¶åæ¯”è¾ƒleftâ€‹å’Œrightâ€‹çš„å€¼ï¼›å¦‚æœç›¸ç­‰ï¼Œç”±é€’å½’æ ˆè¿”å›ä¸Šä¸€å±‚ï¼ˆä¹Ÿå³rightå‘å·¦èµ°ï¼‰ï¼Œå†æ“ä½œleftå‘å³èµ°ï¼Œè¿™æ ·å°±å®ç°äº†leftå’Œrightçš„åŒå‘å¥”èµ´ã€‚\nclass Solution { private: ListNode* left_ = nullptr; bool Traverse(ListNode* right) { if (!","title":"ã€é“¾è¡¨ã€‘åˆ¤æ–­å›æ–‡é“¾è¡¨"},{"content":"Hi there ğŸ‘‹, I am Kerolt! ğŸ˜ ä½ å¥½ï¼Œæˆ‘æ˜¯Keroltï¼å–œæ¬¢å­¦ä¹ ç‚¹è®¡ç®—æœºåº•å±‚ã€Webç­‰æŠ€æœ¯ï¼Œæ­¤å¤–ï¼Œæˆ‘ä¹Ÿçƒ­çˆ±äºç¾½æ¯›çƒğŸ¸å’Œç§‘å¹»ä½œå“ã€‚\nğŸ’¬ Brainstorm with me over tech, career, badminton and science fiction ğŸ“« How to reach me: kerolt@qq.com What I love ç¾½æ¯›çƒğŸ¸ è·‘æ­¥ğŸƒ å¥èº« ç§‘å¹» åŠ¨æ¼«ï¼šå·¨äººã€EVAã€æ¼‚æµå°‘å¹´â€¦ ","permalink":"https://kerolt.github.io/about/","summary":"about","title":"å…³äºæˆ‘"}]