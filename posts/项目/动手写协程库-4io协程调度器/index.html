<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【动手写协程库 4】IO协程调度器 | Kerolt's Blog</title><meta name=keywords content="Coroutine,CPlusPlus"><meta name=description content="
【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
IOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp

之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。
sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.bac160dbfb451d3b958c7b16ede7310831652f1c7b9abec95d519b00de4cd6a5.css integrity="sha256-usFg2/tFHTuVjHsW7ecxCDFlLxx7mr7JXVGbAN5M1qU=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【动手写协程库 4】IO协程调度器"><meta property="og:description" content=" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
IOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp
之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。
sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-29T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-29T00:00:00+00:00"><meta property="article:tag" content="Coroutine"><meta property="article:tag" content="CPlusPlus"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【动手写协程库 4】IO协程调度器"><meta name=twitter:description content="
【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
IOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp

之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。
sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【动手写协程库 4】IO协程调度器","item":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【动手写协程库 4】IO协程调度器","name":"【动手写协程库 4】IO协程调度器","description":" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。\nIOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp\n之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。\nsylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。\n","keywords":["Coroutine","CPlusPlus"],"articleBody":" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。\nIOManager类中具体定义实现可以在这里查看：Github: src/iomanager.cpp\n之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。\nsylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。\nIOManager API IOManager的API如下：\n#ifndef IOMANAGER_H_ #define IOMANAGER_H_ #include #include #include #include #include #include #include #include \"coroutine.h\" #include \"scheduler.h\" #include \"timer.h\" // 事件：无、读、写 enum Event { NONE = 0x0, READ = EPOLLIN, WRITE = EPOLLOUT, }; // IO协程调度 class IOManager : public Scheduler, public TimerManager { public: IOManager(size_t threads = 1, bool use_caller = true, const std::string\u0026 name = \"IOManager\"); ~IOManager(); bool AddEvent(int fd, Event event, std::function\u003cvoid()\u003e cb = nullptr); bool DelEvent(int fd, Event event); bool CancelEvent(int fd, Event event); bool CancelAllEvent(int fd); static IOManager* GetIOManager(); protected: void Idle() override; void Tickle() override; void OnTimerInsertAtFront() override; bool IsStop() override; void ResizeContexts(size_t size); private: // socket fd 上下文 struct FdContext { struct EventContext { Scheduler* scheduler = nullptr; Coroutine::Ptr coroutine; std::function\u003cvoid()\u003e callback; }; // 根据类型获取对应的上下文 EventContext\u0026 GetEventContext(Event\u0026 e); void ResetEventContext(EventContext\u0026 ectx); void TriggerEvent(Event e); EventContext read_ctx, write_ctx; int fd; Event events = Event::NONE; std::mutex mutex; }; private: int epfd_; int tickle_fd_[2]; std::atomic_size_t pending_evt_cnt_; std::mutex mutex_; std::shared_mutex rw_mutex_; // 利用fd作为下标来获取对应的FdContext*，也可以使用哈希表代替 std::vector\u003cFdContext*\u003e fd_contexts_; }; #endif /* IOMANAGER_H_ */ Scheduler::Run() 我们可以先回顾一下Scheduler::Run()这个函数：\nvoid Scheduler::Run() { LOG \u003c\u003c \"Scheduler running...\\n\"; SetHookFlag(true); SetThisAsScheduler(); // 如果当前线程不是调度器所在线程，设置调度的协程为当前线程运行的协程 if (std::this_thread::get_id() != sched_id_) { sched_coroutine = Coroutine::GetNowCoroutine().get(); } Coroutine::Ptr idle_co = std::make_shared\u003cCoroutine\u003e([this] { this-\u003eIdle(); }); Coroutine::Ptr callback_co; SchedulerTask task; while (true) { task.Reset(); bool tickle = false; { std::lock_guard lock(mutex_); auto iter = tasks_.begin(); while (iter != tasks_.end()) { // 当前遍历的task已经分配了线程去执行且这个线程不是当前线程，则不用管 if (iter-\u003ethread_id_ \u0026\u0026 *iter-\u003ethread_id_ != std::this_thread::get_id()) { ++iter; tickle = true; continue; } if (iter-\u003ecoroutine_ \u0026\u0026 iter-\u003ecoroutine_-\u003eGetState() != Coroutine::READY) { LOG \u003c\u003c \"Coroutine task's state should be READY!\\n\"; assert(false); } task = *iter; tasks_.erase(iter++); active_threads_++; break; } // 有任务可以去执行，需要tickle一下 tickle |= (iter != tasks_.end()); } if (tickle) { Tickle(); } // 子协程执行完毕后yield会回到Run()中 // 注意，每次运行了一个task后需要Reset一下 if (task.coroutine_) { // 任务类型为协程 task.coroutine_-\u003eResume(); active_threads_--; task.Reset(); } else if (task.callback_) { // 任务类型为回调函数，将其包装为协程 if (callback_co) { callback_co-\u003eReset(task.callback_); } else { callback_co = std::make_shared\u003cCoroutine\u003e(task.callback_); } callback_co-\u003eResume(); active_threads_--; callback_co.reset(); task.Reset(); } else { // 无任务，任务队列为空 if (idle_co-\u003eGetState() == Coroutine::FINISH) { LOG \u003c\u003c \"Idle coroutine finish\\n\"; break; } idle_threads_++; idle_co-\u003eResume(); // Idle最后Yeild时回到这里 idle_threads_--; } } LOG \u003c\u003c \"Scheduler Run() exit\\n\"; } 这个函数就是每个线程会启动的协程调度函数，负责管理和执行任务队列中的任务，包括协程和回调函数两种类型的任务，如果任务队列为空，则执行Idle协程。\n在Scheduler::Idle()函数中，仅仅只是做了一个简单的处理：调度器没有停止就让出当前正在执行的协程，我们要做的增强后的IOManager需要重写Idle函数，让它不断等待事件、处理事件、然后再次等待事件的循环过程，它在没有其他协程运行时保持系统的活跃度，并在有事件发生时进行相应的处理。\n重写Idle函数 在IOManager中，我们就需要重写Idle函数，我们需要它是一个不断等待事件、处理事件、然后再次等待事件的循环过程，它在没有其他协程运行时保持系统的活跃度，并在有事件发生时进行相应的处理：\n我们会先找到最近一个定时器的超时时间，并将其与自定义最长超时时间（源码中是5s）进行比较取最小者作为epoll_wait的超时时间 将超时的定时器的回调函数加入调度器 处理epoll_wait送来的事件 将当前线程运行的协程暂停（也就是暂停Idle协程），并将执行权交给调度协程（Scheduler::Run()） 从1.又开始重复执行 具体操作可看代码：\nvoid IOManager::Idle() { LOG \u003c\u003c \"idle coroutine start up\\n\"; const int MAX_EVENTS = 256; const int MAX_TIMEOUT = 5000; epoll_event events[MAX_EVENTS]{}; while (true) { // LOG \u003c\u003c \"in idle now\\n\"; if (IsStop()) { LOG \u003c\u003c GetName() \u003c\u003c \"idle stop now\\n\"; break; } uint64_t next_timeout = GetNextTimerInterval(); int triggered_events; do { // 如果时间堆中有超时的定时器，则比较这个超时定时器的下一次触发的时间与MAX_TIMEOUT（5s），选取最小值作为超时时间 next_timeout = next_timeout != ~0ull ? std::min(static_cast\u003cint\u003e(next_timeout), MAX_TIMEOUT) : MAX_TIMEOUT; // 没有事件到来时会阻塞在epoll_wait上，除非到了超时时间 triggered_events = epoll_wait(epfd_, events, MAX_EVENTS, static_cast\u003cint\u003e(next_timeout)); if (triggered_events \u003c 0 \u0026\u0026 errno == EINTR) { continue; } else { break; } } while (true); // 用while(true)的目的是确保在出现特定错误情况时能够重新尝试执行 epoll_wait // 将超时的定时器的回调函数加入调度器 // 这些回调函数的作用可能是关闭连接等操作 std::vector\u003cstd::function\u003cvoid()\u003e\u003e cbs = GetExpiredCbList(); for (auto\u0026 cb : cbs) { Sched(cb); } // 处理事件 for (int i = 0; i \u003c triggered_events; i++) { epoll_event\u0026 event = events[i]; // 是一个用于通知协程调度的事件 // epoll中监听了用于通知的管道读端fd，当有数据到时即会触发 if (event.data.fd == tickle_fd_[0]) { char buf[256]{}; // 将管道内的数据读完 while (read(tickle_fd_[0], buf, sizeof(buf)) \u003e 0) ; continue; } // FdContext* fd_ctx = (FdContext*) event.data.ptr; FdContext* fd_ctx = static_cast\u003cFdContext*\u003e(event.data.ptr); std::lock_guard lock(fd_ctx-\u003emutex); // 发生错误时，如果原来的文件描述符上下文（fd_ctx）中有可读或可写事件标志被设置，那么现在将重新触发这些事件 if (event.events \u0026 (EPOLLERR | EPOLLHUP)) { event.events |= (EPOLLIN | EPOLLOUT) \u0026 fd_ctx-\u003eevents; } // 获取fd_ctx对应的事件 int real_event = Event::NONE; if (event.events \u0026 EPOLLIN) { real_event |= Event::READ; } if (event.events \u0026 EPOLLOUT) { real_event |= Event::WRITE; } if ((fd_ctx-\u003eevents \u0026 real_event) == Event::NONE) { continue; } // 如果还有剩余事件，则修改；否则将其从epoll中删除 // 注意获取rest_events时不是使用的event.events \u0026 ~real_event，因为是要去除fd_ctx-\u003efd中本次触发的事件 int rest_events = fd_ctx-\u003eevents \u0026 ~real_event; int op = rest_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL; event.events = EPOLLET | rest_events; if (epoll_ctl(epfd_, op, fd_ctx-\u003efd, \u0026event) \u003c 0) { LOG_ERROR \u003c\u003c strerror(errno) \u003c\u003c \"\\n\"; continue; } if (real_event \u0026 Event::READ) { fd_ctx-\u003eTriggerEvent(Event::READ); --pending_evt_cnt_; } if (real_event \u0026 Event::WRITE) { fd_ctx-\u003eTriggerEvent(Event::WRITE); --pending_evt_cnt_; } } // 将当前线程运行的协程暂停（也就是暂停Idle协程），并将执行权交给调度协程 Coroutine::Ptr co_ptr = Coroutine::GetNowCoroutine(); auto co = co_ptr.get(); co_ptr.reset(); co-\u003eYield(); } } 添加事件 IOManager除了重写Idle函数这个重要点外，还有个重要点就是为指定文件描述符添加事件。\nIOManager内部有一个[FdContext](#IOManger API)结构体用来封装socket fd的上下文（需要绑定的回调函数，对应的事件、协程），并使用一个vector保存这些FdContext。\n我们在添加fd的事件时，需要将其加入vector中，并且需要通过epoll_ctl注册fd的对应事件。\nbool IOManager::AddEvent(int fd, Event event, std::function\u003cvoid()\u003e cb) { FdContext* fd_ctx = nullptr; { std::shared_lock rw_lock(rw_mutex_); if (fd_contexts_.size() \u003e fd) { fd_ctx = fd_contexts_[fd]; rw_lock.unlock(); } else { rw_lock.unlock(); std::unique_lock rw_lock2(rw_mutex_); ResizeContexts(fd * 1.5); fd_ctx = fd_contexts_[fd]; } } std::lock_guard lock(mutex_); if (fd_ctx-\u003eevents \u0026 event) { LOG_ERROR \u003c\u003c \"A fd can't add same event\\n\"; return false; } int op = fd_ctx-\u003eevents ? EPOLL_CTL_MOD : EPOLL_CTL_ADD; epoll_event ep_evt{}; ep_evt.events = static_cast\u003cint\u003e(fd_ctx-\u003eevents) | EPOLLET | event; ep_evt.data.ptr = fd_ctx; // 在Idle()中将使用fd对应的这个ep_evt int ret = epoll_ctl(epfd_, op, fd, \u0026ep_evt); if (ret) { LOG_ERROR \u003c\u003c \"epoll_ctl \" \u003c\u003c strerror(errno); return false; } ++pending_evt_cnt_; // 设置fd对应事件的EventContext fd_ctx-\u003eevents = static_cast\u003cEvent\u003e(fd_ctx-\u003eevents | event); // 使用event_ctx相当于使用fd_ctx-\u003eread_ctx or fd_ctx-\u003ewrite_ctx（注意是auto\u0026而不是auto） auto\u0026 event_ctx = fd_ctx-\u003eGetEventContext(event); assert(!event_ctx.scheduler \u0026\u0026 !event_ctx.callback \u0026\u0026 !event_ctx.coroutine); event_ctx.scheduler = Scheduler::GetScheduler(); if (cb) { event_ctx.callback = cb; } else { // 设置fd相关事件触发时使用的协程为当前 event_ctx.coroutine = Coroutine::GetNowCoroutine(); assert(event_ctx.coroutine-\u003eGetState() == Coroutine::RUNNING); } return true; } ","wordCount":"782","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-29T00:00:00Z","dateModified":"2024-09-29T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【动手写协程库 4】IO协程调度器</h1><div class=post-meta><span title='2024-09-29 00:00:00 +0000 UTC'>2024-09-29</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;782 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags><li><a href=https://kerolt.github.io/tags/coroutine/>Coroutine</a></li><li><a href=https://kerolt.github.io/tags/cplusplus/>CPlusPlus</a></li></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#iomanager-api aria-label="IOManager API">IOManager API</a></li><li><a href=#schedulerrun aria-label=Scheduler::Run()>Scheduler::Run()</a></li><li><a href=#%e9%87%8d%e5%86%99idle%e5%87%bd%e6%95%b0 aria-label=重写Idle函数>重写Idle函数</a></li><li><a href=#%e6%b7%bb%e5%8a%a0%e4%ba%8b%e4%bb%b6 aria-label=添加事件>添加事件</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了<a href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952">从零开始重写sylar C++高性能分布式服务器框架</a>和代码随想录中的<a href=https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F>文档</a>。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。</p><p><code>IOManager</code>类中具体定义实现可以在这里查看：<a href=https://github.com/kerolt/coroutine-lib/blob/master/src/iomanager.cpp>Github: src/iomanager.cpp</a></p></blockquote><p>之前实现的协程调度器的功能其实非常简单，当添加任务后调度器只是单纯的从任务队列中取出任务交给协程去执行。sylar的协程库的关注对象是网络IO，如果采用这么简单的调度就根本没有用到协程的精髓。</p><p>sylar的IO协程调度解决了之前调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。</p><h2 id=iomanager-api>IOManager API<a hidden class=anchor aria-hidden=true href=#iomanager-api>#</a></h2><p><code>IOManager</code>的API如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#099>#ifndef IOMANAGER_H_
</span></span></span><span style=display:flex><span><span style=color:#099>#define IOMANAGER_H_
</span></span></span><span style=display:flex><span><span style=color:#099></span>
</span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;cstddef&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;sys/epoll.h&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099></span>
</span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;atomic&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;functional&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;mutex&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;shared_mutex&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&lt;vector&gt;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099></span>
</span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&#34;coroutine.h&#34;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&#34;scheduler.h&#34;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099>#include</span> <span style=color:#099>&#34;timer.h&#34;</span><span style=color:#099>
</span></span></span><span style=display:flex><span><span style=color:#099></span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// 事件：无、读、写
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>enum</span> <span style=color:#0a8;font-weight:700>Event</span> {
</span></span><span style=display:flex><span>    NONE <span style=color:#555>=</span> <span style=color:#f60>0x0</span>,
</span></span><span style=display:flex><span>    READ <span style=color:#555>=</span> EPOLLIN,
</span></span><span style=display:flex><span>    WRITE <span style=color:#555>=</span> EPOLLOUT,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// IO协程调度
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>IOManager</span> <span style=color:#555>:</span> <span style=color:#069;font-weight:700>public</span> Scheduler, <span style=color:#069;font-weight:700>public</span> TimerManager {
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>public</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>    IOManager(size_t threads <span style=color:#555>=</span> <span style=color:#f60>1</span>, <span style=color:#078;font-weight:700>bool</span> use_caller <span style=color:#555>=</span> <span style=color:#366>true</span>, <span style=color:#069;font-weight:700>const</span> std<span style=color:#555>::</span>string<span style=color:#555>&amp;</span> name <span style=color:#555>=</span> <span style=color:#c30>&#34;IOManager&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#555>~</span>IOManager();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>AddEvent</span>(<span style=color:#078;font-weight:700>int</span> fd, Event event, std<span style=color:#555>::</span>function<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>void</span>()<span style=color:#555>&gt;</span> cb <span style=color:#555>=</span> <span style=color:#069;font-weight:700>nullptr</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>DelEvent</span>(<span style=color:#078;font-weight:700>int</span> fd, Event event);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>CancelEvent</span>(<span style=color:#078;font-weight:700>int</span> fd, Event event);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>CancelAllEvent</span>(<span style=color:#078;font-weight:700>int</span> fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>static</span> IOManager<span style=color:#555>*</span> <span style=color:#c0f>GetIOManager</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>protected</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>void</span> Idle() <span style=color:#069;font-weight:700>override</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>Tickle</span>() <span style=color:#069;font-weight:700>override</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>OnTimerInsertAtFront</span>() <span style=color:#069;font-weight:700>override</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>IsStop</span>() <span style=color:#069;font-weight:700>override</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>ResizeContexts</span>(size_t size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>private</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// socket fd 上下文
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>FdContext</span> {
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>EventContext</span> {
</span></span><span style=display:flex><span>            Scheduler<span style=color:#555>*</span> scheduler <span style=color:#555>=</span> <span style=color:#069;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>            Coroutine<span style=color:#555>::</span>Ptr coroutine;
</span></span><span style=display:flex><span>            std<span style=color:#555>::</span>function<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>void</span>()<span style=color:#555>&gt;</span> callback;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 根据类型获取对应的上下文
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        EventContext<span style=color:#555>&amp;</span> GetEventContext(Event<span style=color:#555>&amp;</span> e);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>ResetEventContext</span>(EventContext<span style=color:#555>&amp;</span> ectx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>TriggerEvent</span>(Event e);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EventContext read_ctx, write_ctx;
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>int</span> fd;
</span></span><span style=display:flex><span>        Event events <span style=color:#555>=</span> Event<span style=color:#555>::</span>NONE;
</span></span><span style=display:flex><span>        std<span style=color:#555>::</span>mutex mutex;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>private</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> epfd_;
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> tickle_fd_[<span style=color:#f60>2</span>];
</span></span><span style=display:flex><span>    std<span style=color:#555>::</span>atomic_size_t pending_evt_cnt_;
</span></span><span style=display:flex><span>    std<span style=color:#555>::</span>mutex mutex_;
</span></span><span style=display:flex><span>    std<span style=color:#555>::</span>shared_mutex rw_mutex_;
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// 利用fd作为下标来获取对应的FdContext*，也可以使用哈希表代替
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    std<span style=color:#555>::</span>vector<span style=color:#555>&lt;</span>FdContext<span style=color:#555>*&gt;</span> fd_contexts_;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#099>#endif </span><span style=color:#09f;font-style:italic>/* IOMANAGER_H_ */</span><span style=color:#099>
</span></span></span></code></pre></div><h2 id=schedulerrun>Scheduler::Run()<a hidden class=anchor aria-hidden=true href=#schedulerrun>#</a></h2><p>我们可以先回顾一下<code>Scheduler::Run()</code>这个函数：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> Scheduler<span style=color:#555>::</span>Run() {
</span></span><span style=display:flex><span>    LOG <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;Scheduler running...</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>    SetHookFlag(<span style=color:#366>true</span>);
</span></span><span style=display:flex><span>    SetThisAsScheduler();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// 如果当前线程不是调度器所在线程，设置调度的协程为当前线程运行的协程
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>if</span> (std<span style=color:#555>::</span>this_thread<span style=color:#555>::</span>get_id() <span style=color:#555>!=</span> sched_id_) {
</span></span><span style=display:flex><span>        sched_coroutine <span style=color:#555>=</span> Coroutine<span style=color:#555>::</span>GetNowCoroutine().get();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Coroutine<span style=color:#555>::</span>Ptr idle_co <span style=color:#555>=</span> std<span style=color:#555>::</span>make_shared<span style=color:#555>&lt;</span>Coroutine<span style=color:#555>&gt;</span>([<span style=color:#069;font-weight:700>this</span>] { <span style=color:#069;font-weight:700>this</span><span style=color:#555>-&gt;</span>Idle(); });
</span></span><span style=display:flex><span>    Coroutine<span style=color:#555>::</span>Ptr callback_co;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SchedulerTask task;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>while</span> (<span style=color:#366>true</span>) {
</span></span><span style=display:flex><span>        task.Reset();
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>bool</span> tickle <span style=color:#555>=</span> <span style=color:#366>false</span>;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#555>::</span>lock_guard lock(mutex_);
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>auto</span> iter <span style=color:#555>=</span> tasks_.begin();
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>while</span> (iter <span style=color:#555>!=</span> tasks_.end()) {
</span></span><span style=display:flex><span>                <span style=color:#09f;font-style:italic>// 当前遍历的task已经分配了线程去执行且这个线程不是当前线程，则不用管
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                <span style=color:#069;font-weight:700>if</span> (iter<span style=color:#555>-&gt;</span>thread_id_ <span style=color:#555>&amp;&amp;</span> <span style=color:#555>*</span>iter<span style=color:#555>-&gt;</span>thread_id_ <span style=color:#555>!=</span> std<span style=color:#555>::</span>this_thread<span style=color:#555>::</span>get_id()) {
</span></span><span style=display:flex><span>                    <span style=color:#555>++</span>iter;
</span></span><span style=display:flex><span>                    tickle <span style=color:#555>=</span> <span style=color:#366>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>if</span> (iter<span style=color:#555>-&gt;</span>coroutine_ <span style=color:#555>&amp;&amp;</span> iter<span style=color:#555>-&gt;</span>coroutine_<span style=color:#555>-&gt;</span>GetState() <span style=color:#555>!=</span> Coroutine<span style=color:#555>::</span>READY) {
</span></span><span style=display:flex><span>                    LOG <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;Coroutine task&#39;s state should be READY!</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>                    assert(<span style=color:#366>false</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                task <span style=color:#555>=</span> <span style=color:#555>*</span>iter;
</span></span><span style=display:flex><span>                tasks_.erase(iter<span style=color:#555>++</span>);
</span></span><span style=display:flex><span>                active_threads_<span style=color:#555>++</span>;
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 有任务可以去执行，需要tickle一下
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            tickle <span style=color:#555>|=</span> (iter <span style=color:#555>!=</span> tasks_.end());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>if</span> (tickle) {
</span></span><span style=display:flex><span>            Tickle();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 子协程执行完毕后yield会回到Run()中
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        <span style=color:#09f;font-style:italic>// 注意，每次运行了一个task后需要Reset一下
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        <span style=color:#069;font-weight:700>if</span> (task.coroutine_) {
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 任务类型为协程
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            task.coroutine_<span style=color:#555>-&gt;</span>Resume();
</span></span><span style=display:flex><span>            active_threads_<span style=color:#555>--</span>;
</span></span><span style=display:flex><span>            task.Reset();
</span></span><span style=display:flex><span>        } <span style=color:#069;font-weight:700>else</span> <span style=color:#c0f>if</span> (task.callback_) {
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 任务类型为回调函数，将其包装为协程
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#069;font-weight:700>if</span> (callback_co) {
</span></span><span style=display:flex><span>                callback_co<span style=color:#555>-&gt;</span>Reset(task.callback_);
</span></span><span style=display:flex><span>            } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>                callback_co <span style=color:#555>=</span> std<span style=color:#555>::</span>make_shared<span style=color:#555>&lt;</span>Coroutine<span style=color:#555>&gt;</span>(task.callback_);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            callback_co<span style=color:#555>-&gt;</span>Resume();
</span></span><span style=display:flex><span>            active_threads_<span style=color:#555>--</span>;
</span></span><span style=display:flex><span>            callback_co.reset();
</span></span><span style=display:flex><span>            task.Reset();
</span></span><span style=display:flex><span>        } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 无任务，任务队列为空
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#069;font-weight:700>if</span> (idle_co<span style=color:#555>-&gt;</span>GetState() <span style=color:#555>==</span> Coroutine<span style=color:#555>::</span>FINISH) {
</span></span><span style=display:flex><span>                LOG <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;Idle coroutine finish</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            idle_threads_<span style=color:#555>++</span>;
</span></span><span style=display:flex><span>            idle_co<span style=color:#555>-&gt;</span>Resume(); <span style=color:#09f;font-style:italic>// Idle最后Yeild时回到这里
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            idle_threads_<span style=color:#555>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    LOG <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;Scheduler Run() exit</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数就是每个线程会启动的协程调度函数，负责管理和执行任务队列中的任务，包括协程和回调函数两种类型的任务，如果任务队列为空，则执行Idle协程。</p><p>在<code>Scheduler::Idle()</code>函数中，仅仅只是做了一个简单的处理：调度器没有停止就让出当前正在执行的协程，我们要做的增强后的IOManager需要重写Idle函数，让它不断等待事件、处理事件、然后再次等待事件的循环过程，它在没有其他协程运行时保持系统的活跃度，并在有事件发生时进行相应的处理。</p><h2 id=重写idle函数>重写Idle函数<a hidden class=anchor aria-hidden=true href=#重写idle函数>#</a></h2><p>在<code>IOManager</code>中，我们就需要重写Idle函数，我们需要它是一个不断等待事件、处理事件、然后再次等待事件的循环过程，它在没有其他协程运行时保持系统的活跃度，并在有事件发生时进行相应的处理：</p><ol><li>我们会先找到最近一个定时器的超时时间，并将其与自定义最长超时时间（源码中是5s）进行比较取最小者作为<code>epoll_wait</code>的超时时间</li><li>将超时的定时器的回调函数加入调度器</li><li>处理<code>epoll_wait</code>送来的事件</li><li>将当前线程运行的协程暂停（也就是暂停Idle协程），并将执行权交给调度协程（<code>Scheduler::Run()</code>）</li><li>从1.又开始重复执行</li></ol><p>具体操作可看代码：</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> IOManager<span style=color:#555>::</span>Idle() {
</span></span><span style=display:flex><span>    LOG <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;idle coroutine start up</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>int</span> MAX_EVENTS <span style=color:#555>=</span> <span style=color:#f60>256</span>;
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>int</span> MAX_TIMEOUT <span style=color:#555>=</span> <span style=color:#f60>5000</span>;
</span></span><span style=display:flex><span>    epoll_event events[MAX_EVENTS]{};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>while</span> (<span style=color:#366>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// LOG &lt;&lt; &#34;in idle now\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        <span style=color:#069;font-weight:700>if</span> (IsStop()) {
</span></span><span style=display:flex><span>            LOG <span style=color:#555>&lt;&lt;</span> GetName() <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;idle stop now</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>uint64_t</span> next_timeout <span style=color:#555>=</span> GetNextTimerInterval();
</span></span><span style=display:flex><span>        <span style=color:#078;font-weight:700>int</span> triggered_events;
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 如果时间堆中有超时的定时器，则比较这个超时定时器的下一次触发的时间与MAX_TIMEOUT（5s），选取最小值作为超时时间
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            next_timeout <span style=color:#555>=</span> next_timeout <span style=color:#555>!=</span> <span style=color:#555>~</span><span style=color:#f60>0ull</span> <span style=color:#555>?</span> std<span style=color:#555>::</span>min(<span style=color:#069;font-weight:700>static_cast</span><span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>int</span><span style=color:#555>&gt;</span>(next_timeout), MAX_TIMEOUT) <span style=color:#555>:</span> MAX_TIMEOUT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 没有事件到来时会阻塞在epoll_wait上，除非到了超时时间
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            triggered_events <span style=color:#555>=</span> epoll_wait(epfd_, events, MAX_EVENTS, <span style=color:#069;font-weight:700>static_cast</span><span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>int</span><span style=color:#555>&gt;</span>(next_timeout));
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (triggered_events <span style=color:#555>&lt;</span> <span style=color:#f60>0</span> <span style=color:#555>&amp;&amp;</span> errno <span style=color:#555>==</span> EINTR) {
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>            } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#069;font-weight:700>while</span> (<span style=color:#366>true</span>); <span style=color:#09f;font-style:italic>// 用while(true)的目的是确保在出现特定错误情况时能够重新尝试执行 epoll_wait
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 将超时的定时器的回调函数加入调度器
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        <span style=color:#09f;font-style:italic>// 这些回调函数的作用可能是关闭连接等操作
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        std<span style=color:#555>::</span>vector<span style=color:#555>&lt;</span>std<span style=color:#555>::</span>function<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>void</span>()<span style=color:#555>&gt;&gt;</span> cbs <span style=color:#555>=</span> GetExpiredCbList();
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>for</span> (<span style=color:#069;font-weight:700>auto</span><span style=color:#555>&amp;</span> <span style=color:#99f>cb</span> : cbs) {
</span></span><span style=display:flex><span>            Sched(cb);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 处理事件
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        <span style=color:#069;font-weight:700>for</span> (<span style=color:#078;font-weight:700>int</span> i <span style=color:#555>=</span> <span style=color:#f60>0</span>; i <span style=color:#555>&lt;</span> triggered_events; i<span style=color:#555>++</span>) {
</span></span><span style=display:flex><span>            epoll_event<span style=color:#555>&amp;</span> event <span style=color:#555>=</span> events[i];
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 是一个用于通知协程调度的事件
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#09f;font-style:italic>// epoll中监听了用于通知的管道读端fd，当有数据到时即会触发
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#069;font-weight:700>if</span> (event.data.fd <span style=color:#555>==</span> tickle_fd_[<span style=color:#f60>0</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#078;font-weight:700>char</span> buf[<span style=color:#f60>256</span>]{};
</span></span><span style=display:flex><span>                <span style=color:#09f;font-style:italic>// 将管道内的数据读完
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                <span style=color:#069;font-weight:700>while</span> (read(tickle_fd_[<span style=color:#f60>0</span>], buf, <span style=color:#069;font-weight:700>sizeof</span>(buf)) <span style=color:#555>&gt;</span> <span style=color:#f60>0</span>)
</span></span><span style=display:flex><span>                    ;
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// FdContext* fd_ctx = (FdContext*) event.data.ptr;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            FdContext<span style=color:#555>*</span> fd_ctx <span style=color:#555>=</span> <span style=color:#069;font-weight:700>static_cast</span><span style=color:#555>&lt;</span>FdContext<span style=color:#555>*&gt;</span>(event.data.ptr);
</span></span><span style=display:flex><span>            std<span style=color:#555>::</span>lock_guard lock(fd_ctx<span style=color:#555>-&gt;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 发生错误时，如果原来的文件描述符上下文（fd_ctx）中有可读或可写事件标志被设置，那么现在将重新触发这些事件
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#069;font-weight:700>if</span> (event.events <span style=color:#555>&amp;</span> (EPOLLERR <span style=color:#555>|</span> EPOLLHUP)) {
</span></span><span style=display:flex><span>                event.events <span style=color:#555>|=</span> (EPOLLIN <span style=color:#555>|</span> EPOLLOUT) <span style=color:#555>&amp;</span> fd_ctx<span style=color:#555>-&gt;</span>events;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 获取fd_ctx对应的事件
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#078;font-weight:700>int</span> real_event <span style=color:#555>=</span> Event<span style=color:#555>::</span>NONE;
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (event.events <span style=color:#555>&amp;</span> EPOLLIN) {
</span></span><span style=display:flex><span>                real_event <span style=color:#555>|=</span> Event<span style=color:#555>::</span>READ;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (event.events <span style=color:#555>&amp;</span> EPOLLOUT) {
</span></span><span style=display:flex><span>                real_event <span style=color:#555>|=</span> Event<span style=color:#555>::</span>WRITE;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> ((fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>&amp;</span> real_event) <span style=color:#555>==</span> Event<span style=color:#555>::</span>NONE) {
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// 如果还有剩余事件，则修改；否则将其从epoll中删除
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#09f;font-style:italic>// 注意获取rest_events时不是使用的event.events &amp; ~real_event，因为是要去除fd_ctx-&gt;fd中本次触发的事件
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            <span style=color:#078;font-weight:700>int</span> rest_events <span style=color:#555>=</span> fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>&amp;</span> <span style=color:#555>~</span>real_event;
</span></span><span style=display:flex><span>            <span style=color:#078;font-weight:700>int</span> op <span style=color:#555>=</span> rest_events <span style=color:#555>?</span> <span style=color:#99f>EPOLL_CTL_MOD</span> : EPOLL_CTL_DEL;
</span></span><span style=display:flex><span>            event.events <span style=color:#555>=</span> EPOLLET <span style=color:#555>|</span> rest_events;
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (epoll_ctl(epfd_, op, fd_ctx<span style=color:#555>-&gt;</span>fd, <span style=color:#555>&amp;</span>event) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>                LOG_ERROR <span style=color:#555>&lt;&lt;</span> strerror(errno) <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>                <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (real_event <span style=color:#555>&amp;</span> Event<span style=color:#555>::</span>READ) {
</span></span><span style=display:flex><span>                fd_ctx<span style=color:#555>-&gt;</span>TriggerEvent(Event<span style=color:#555>::</span>READ);
</span></span><span style=display:flex><span>                <span style=color:#555>--</span>pending_evt_cnt_;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> (real_event <span style=color:#555>&amp;</span> Event<span style=color:#555>::</span>WRITE) {
</span></span><span style=display:flex><span>                fd_ctx<span style=color:#555>-&gt;</span>TriggerEvent(Event<span style=color:#555>::</span>WRITE);
</span></span><span style=display:flex><span>                <span style=color:#555>--</span>pending_evt_cnt_;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 将当前线程运行的协程暂停（也就是暂停Idle协程），并将执行权交给调度协程
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        Coroutine<span style=color:#555>::</span>Ptr co_ptr <span style=color:#555>=</span> Coroutine<span style=color:#555>::</span>GetNowCoroutine();
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>auto</span> co <span style=color:#555>=</span> co_ptr.get();
</span></span><span style=display:flex><span>        co_ptr.reset();
</span></span><span style=display:flex><span>        co<span style=color:#555>-&gt;</span>Yield();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=添加事件>添加事件<a hidden class=anchor aria-hidden=true href=#添加事件>#</a></h2><p>IOManager除了重写Idle函数这个重要点外，还有个重要点就是为指定文件描述符添加事件。</p><p>IOManager内部有一个[<code>FdContext</code>](#IOManger API)结构体用来封装socket fd的上下文（需要绑定的回调函数，对应的事件、协程），并使用一个vector保存这些FdContext。</p><p>我们在添加fd的事件时，需要将其加入vector中，并且需要通过<code>epoll_ctl</code>注册fd的对应事件。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#078;font-weight:700>bool</span> IOManager<span style=color:#555>::</span>AddEvent(<span style=color:#078;font-weight:700>int</span> fd, Event event, std<span style=color:#555>::</span>function<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>void</span>()<span style=color:#555>&gt;</span> cb) {
</span></span><span style=display:flex><span>    FdContext<span style=color:#555>*</span> fd_ctx <span style=color:#555>=</span> <span style=color:#069;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#555>::</span>shared_lock rw_lock(rw_mutex_);
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>if</span> (fd_contexts_.size() <span style=color:#555>&gt;</span> fd) {
</span></span><span style=display:flex><span>            fd_ctx <span style=color:#555>=</span> fd_contexts_[fd];
</span></span><span style=display:flex><span>            rw_lock.unlock();
</span></span><span style=display:flex><span>        } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>            rw_lock.unlock();
</span></span><span style=display:flex><span>            std<span style=color:#555>::</span>unique_lock rw_lock2(rw_mutex_);
</span></span><span style=display:flex><span>            ResizeContexts(fd <span style=color:#555>*</span> <span style=color:#f60>1.5</span>);
</span></span><span style=display:flex><span>            fd_ctx <span style=color:#555>=</span> fd_contexts_[fd];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#555>::</span>lock_guard lock(mutex_);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>&amp;</span> event) {
</span></span><span style=display:flex><span>        LOG_ERROR <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;A fd can&#39;t add same event</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>return</span> <span style=color:#366>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> op <span style=color:#555>=</span> fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>?</span> <span style=color:#99f>EPOLL_CTL_MOD</span> : EPOLL_CTL_ADD;
</span></span><span style=display:flex><span>    epoll_event ep_evt{};
</span></span><span style=display:flex><span>    ep_evt.events <span style=color:#555>=</span> <span style=color:#069;font-weight:700>static_cast</span><span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>int</span><span style=color:#555>&gt;</span>(fd_ctx<span style=color:#555>-&gt;</span>events) <span style=color:#555>|</span> EPOLLET <span style=color:#555>|</span> event;
</span></span><span style=display:flex><span>    ep_evt.data.ptr <span style=color:#555>=</span> fd_ctx; <span style=color:#09f;font-style:italic>// 在Idle()中将使用fd对应的这个ep_evt
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> ret <span style=color:#555>=</span> epoll_ctl(epfd_, op, fd, <span style=color:#555>&amp;</span>ep_evt);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (ret) {
</span></span><span style=display:flex><span>        LOG_ERROR <span style=color:#555>&lt;&lt;</span> <span style=color:#c30>&#34;epoll_ctl &#34;</span> <span style=color:#555>&lt;&lt;</span> strerror(errno);
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>return</span> <span style=color:#366>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#555>++</span>pending_evt_cnt_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// 设置fd对应事件的EventContext
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>=</span> <span style=color:#069;font-weight:700>static_cast</span><span style=color:#555>&lt;</span>Event<span style=color:#555>&gt;</span>(fd_ctx<span style=color:#555>-&gt;</span>events <span style=color:#555>|</span> event);
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// 使用event_ctx相当于使用fd_ctx-&gt;read_ctx or fd_ctx-&gt;write_ctx（注意是auto&amp;而不是auto）
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>auto</span><span style=color:#555>&amp;</span> event_ctx <span style=color:#555>=</span> fd_ctx<span style=color:#555>-&gt;</span>GetEventContext(event);
</span></span><span style=display:flex><span>    assert(<span style=color:#555>!</span>event_ctx.scheduler <span style=color:#555>&amp;&amp;</span> <span style=color:#555>!</span>event_ctx.callback <span style=color:#555>&amp;&amp;</span> <span style=color:#555>!</span>event_ctx.coroutine);
</span></span><span style=display:flex><span>    event_ctx.scheduler <span style=color:#555>=</span> Scheduler<span style=color:#555>::</span>GetScheduler();
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (cb) {
</span></span><span style=display:flex><span>        event_ctx.callback <span style=color:#555>=</span> cb;
</span></span><span style=display:flex><span>    } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 设置fd相关事件触发时使用的协程为当前
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        event_ctx.coroutine <span style=color:#555>=</span> Coroutine<span style=color:#555>::</span>GetNowCoroutine();
</span></span><span style=display:flex><span>        assert(event_ctx.coroutine<span style=color:#555>-&gt;</span>GetState() <span style=color:#555>==</span> Coroutine<span style=color:#555>::</span>RUNNING);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#366>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/><span class=title>« Prev</span><br><span>【动手写协程库 5】常用IO函数的HOOK功能</span>
</a><a class=next href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-3%E5%AE%9A%E6%97%B6%E5%99%A8/><span class=title>Next »</span><br><span>【动手写协程库 3】定时器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>