<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【动手写协程库 5】常用IO函数的HOOK功能 | Kerolt's Blog</title>
<meta name=keywords content="Coroutine,CPlusPlus"><meta name=description content="
【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
hook函数的具体定义实现可以在这里查看：Github: src/hook.cpp

该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。
hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3ed056d55a11aedd2746623ca13ff4227e48b5c45361c89521f36b5fe84f3771.css integrity="sha256-PtBW1VoRrt0nRmI8oT/0In5ItcRTYciVIfNrX+hPN3E=" rel="preload stylesheet" as=style><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.jpeg><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【动手写协程库 5】常用IO函数的HOOK功能"><meta property="og:description" content=" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
hook函数的具体定义实现可以在这里查看：Github: src/hook.cpp
该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。
hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-30T00:00:00+00:00"><meta property="article:tag" content="Coroutine"><meta property="article:tag" content="CPlusPlus"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【动手写协程库 5】常用IO函数的HOOK功能"><meta name=twitter:description content="
【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。
hook函数的具体定义实现可以在这里查看：Github: src/hook.cpp

该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。
hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【动手写协程库 5】常用IO函数的HOOK功能","item":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【动手写协程库 5】常用IO函数的HOOK功能","name":"【动手写协程库 5】常用IO函数的HOOK功能","description":" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。\nhook函数的具体定义实现可以在这里查看：Github: src/hook.cpp\n该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。\nhook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。\n","keywords":["Coroutine","CPlusPlus"],"articleBody":" 【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了从零开始重写sylar C++高性能分布式服务器框架和代码随想录中的文档。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。\nhook函数的具体定义实现可以在这里查看：Github: src/hook.cpp\n该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。\nhook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。\n需要Hook的几类函数 在sylar的设计中，只针对socket fd进行hook（因为我们更关心的是网络IO），也就是如果我们操作的不是socket fd，那么就会使用原来的API。\nsylar对如下三类函数进行了hook：\nsleep延时系列接口：包括sleep/usleep/nanosleep。对于这些接口的hook，只需要给IO协程调度器注册一个定时事件，在定时事件触发后再继续执行当前协程即可。当前协程在注册完定时事件后即可yield让出执行权 socket IO系列接口：包括read/write/recv/send…等，connect及accept也可以归到这类接口中。这类接口的hook首先需要判断操作的fd是否是socket fd，以及用户是否显式地对该fd设置过非阻塞模式，如果不是socket fd或是用户显式设置过非阻塞模式，那么就不需要hook了，直接调用操作系统的IO接口即可。如果需要hook，那么首先在IO协程调度器上注册对应的读写事件，等事件发生后再继续执行当前协程。当前协程在注册完IO事件即可yield让出执行权。 socket/fcntl/ioctl/close等接口：这类接口主要处理的是边缘情况，比如分配fd上下文，处理超时及用户显式设置非阻塞问题。 Hook的实现 我们hook的所有函数，都要与原来的API的行为保持一致（使用这些hook api的时候就好像使用的原来的api）。例如原来的API的返回值通常用0表示成功，-1表示失败\n在 Sylar 中，Hook 的实现通常涉及以下几个关键方面：\n一、函数指针替换\n保存原始函数指针：首先，需要保存被 Hook 函数的原始实现的函数指针。这可以通过在程序启动时或者在首次需要 Hook 的时候，获取原始函数的地址并存储起来。例如，可以定义一个与被 Hook 函数具有相同签名的函数指针变量，并将其初始化为指向原始函数的地址。 替换函数指针：然后，将被 Hook 函数的入口地址替换为自定义的 Hook 函数的地址。这样，当程序调用被 Hook 函数时，实际上会执行 Hook 函数。 二、参数传递和返回值处理\n参数传递：在 Hook 函数中，需要接收与被 Hook 函数相同的参数。这可以通过将参数直接传递给 Hook 函数，或者使用一些技术（如函数调用栈的分析）来获取参数的值。如果被 Hook 函数是 int func(int a, char* b)，那么 Hook 函数也应该具有相同的参数列表 int hook_func(int a, char* b)。 返回值处理：Hook 函数需要根据需要处理被 Hook 函数的返回值。可以选择直接返回被 Hook 函数的原始返回值，或者根据特定的逻辑修改返回值后再返回。 三、条件判断和控制\nHook 启用 / 禁用：通常会提供一种机制来启用或禁用 Hook 功能。这可以通过一个全局变量、配置文件或者运行时参数来控制。我们可以在代码中定义一个布尔变量，如 bool hook_enable，当它为真时启用 Hook 功能，为假时直接调用原始函数而不执行 Hook 函数。 特定条件下的 Hook：可以根据特定的条件来决定是否执行 Hook 函数。例如，可以检查参数的值、函数的调用者、当前的运行环境等条件，只有在满足特定条件时才执行 Hook 函数。 FdManager 我们会通过FdContext类（注意与IOManager中的FdContext进行区分）来保存fd的一些状态，例如fd是否关闭了，是否设置为非阻塞，其读写事件超时时间是多少等。\nsleep API 对sleep，usleep，nanosleep三个函数进行hook操作，其逻辑一致：sleep类函数会阻塞当前线程，那么我们的改造方法就是用一个定时器来代替sleep的休眠阻塞，获取当前运行的协程，然后通过IOManager添加一个定时器，规定时间后再将这个协程加入调度，之后yield这个协程。\nsocket API socket：当使用socket创建套接字fd时，我们需要将它加入到FdManager中。 connect：对于原始的connect，它是一个阻塞调用，直到连接成功或发生错误，如果网络延迟较高或目标主机不可达，可能会导致程序长时间挂起。我们需要将其改造为与异步或非阻塞操作结合。对应的实现方法就是通过设置一个超时时间，到时间后取消文件描述符的写事件。为socket fd添加写事件后，如果添加成功，则yield当前协程，并取消定时器 setsockopt：对于optname为SO_RCVTIMEO和SO_RCVTIMEO的情况，我们需要设置sockfd对应的超时时间。 socket IO API accept、read、readv、recv、recvfrom、recvmsg、write、writev、send、sendto、sendmsg这些函数所要作的hook操作都很类似，不同的地方无非就是读写事件的不同，其处理逻辑和connect相似，所以利用了模板来减少冗余代码。\nother API 还有类似close、ioctl、fcntl的函数，由于我们在之前hook api时处理了文件描述符，因此在这些函数中我们需要对文件描述符进行清理或其他操作。\n","wordCount":"108","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-30T00:00:00Z","dateModified":"2024-09-30T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-5%E5%B8%B8%E7%94%A8io%E5%87%BD%E6%95%B0%E7%9A%84hook%E5%8A%9F%E8%83%BD/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.jpeg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【动手写协程库 5】常用IO函数的HOOK功能</h1><div class=post-meta><span title='2024-09-30 00:00:00 +0000 UTC'>2024-09-30</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;108 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags><li><a href=https://kerolt.github.io/tags/coroutine/>Coroutine</a></li><li><a href=https://kerolt.github.io/tags/cplusplus/>CPlusPlus</a></li></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9c%80%e8%a6%81hook%e7%9a%84%e5%87%a0%e7%b1%bb%e5%87%bd%e6%95%b0 aria-label=需要Hook的几类函数>需要Hook的几类函数</a></li><li><a href=#hook%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=Hook的实现>Hook的实现</a></li><li><a href=#fdmanager aria-label=FdManager>FdManager</a></li><li><a href=#sleep-api aria-label="sleep API">sleep API</a></li><li><a href=#socket-api aria-label="socket API">socket API</a></li><li><a href=#socket-io-api aria-label="socket IO API">socket IO API</a></li><li><a href=#other-api aria-label="other API">other API</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>【动手写协程库】系列笔记是学习sylar的协程库时的记录，参考了<a href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952">从零开始重写sylar C++高性能分布式服务器框架</a>和代码随想录中的<a href=https://www.programmercarl.com/other/project_coroutine.html#%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F>文档</a>。文章并不是对所有代码的详细解释，而是为了自己理解一些片段所做的笔记。</p><p>hook函数的具体定义实现可以在这里查看：<a href=https://github.com/kerolt/coroutine-lib/blob/master/src/hook.cpp>Github: src/hook.cpp</a></p></blockquote><p>该协程库框架的目标并不是做成类似goroutine那样，而是希望能够通过协程来提高IO处理的效率。因此，对于每个文件描述符fd，我们都希望它有一个读写IO的超时时间。</p><p>hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都<strong>转成异步</strong>，以提高性能。</p><h2 id=需要hook的几类函数>需要Hook的几类函数<a hidden class=anchor aria-hidden=true href=#需要hook的几类函数>#</a></h2><p>在sylar的设计中，只针对socket fd进行hook（因为我们更关心的是网络IO），也就是如果我们操作的不是socket fd，那么就会使用原来的API。</p><p>sylar对如下三类函数进行了hook：</p><ol><li><strong>sleep延时系列接口</strong>：包括sleep/usleep/nanosleep。对于这些接口的hook，只需要给IO协程调度器注册一个定时事件，在定时事件触发后再继续执行当前协程即可。当前协程在注册完定时事件后即可yield让出执行权</li><li><strong>socket IO系列接口</strong>：包括read/write/recv/send&mldr;等，connect及accept也可以归到这类接口中。这类接口的hook首先需要判断操作的fd是否是socket fd，以及用户是否显式地对该fd设置过非阻塞模式，如果不是socket fd或是用户显式设置过非阻塞模式，那么就不需要hook了，直接调用操作系统的IO接口即可。如果需要hook，那么首先在IO协程调度器上注册对应的读写事件，等事件发生后再继续执行当前协程。当前协程在注册完IO事件即可yield让出执行权。</li><li><strong>socket/fcntl/ioctl/close等接口</strong>：这类接口主要处理的是边缘情况，比如分配fd上下文，处理超时及用户显式设置非阻塞问题。</li></ol><h2 id=hook的实现>Hook的实现<a hidden class=anchor aria-hidden=true href=#hook的实现>#</a></h2><blockquote><p>我们hook的所有函数，都要与原来的API的行为保持一致（使用这些hook api的时候就好像使用的原来的api）。例如原来的API的返回值通常用0表示成功，-1表示失败</p></blockquote><p>在 Sylar 中，Hook 的实现通常涉及以下几个关键方面：</p><p><strong>一、函数指针替换</strong></p><ol><li>保存原始函数指针：首先，需要保存被 Hook 函数的原始实现的函数指针。这可以通过在程序启动时或者在首次需要 Hook 的时候，获取原始函数的地址并存储起来。例如，可以定义一个与被 Hook 函数具有相同签名的函数指针变量，并将其初始化为指向原始函数的地址。</li><li>替换函数指针：然后，将被 Hook 函数的入口地址替换为自定义的 Hook 函数的地址。这样，当程序调用被 Hook 函数时，实际上会执行 Hook 函数。</li></ol><p><strong>二、参数传递和返回值处理</strong></p><ol><li>参数传递：在 Hook 函数中，需要接收与被 Hook 函数相同的参数。这可以通过将参数直接传递给 Hook 函数，或者使用一些技术（如函数调用栈的分析）来获取参数的值。如果被 Hook 函数是 <code>int func(int a, char* b)</code>，那么 Hook 函数也应该具有相同的参数列表 <code>int hook_func(int a, char* b)</code>。</li><li>返回值处理：Hook 函数需要根据需要处理被 Hook 函数的返回值。可以选择直接返回被 Hook 函数的原始返回值，或者根据特定的逻辑修改返回值后再返回。</li></ol><p><strong>三、条件判断和控制</strong></p><ol><li>Hook 启用 / 禁用：通常会提供一种机制来启用或禁用 Hook 功能。这可以通过一个全局变量、配置文件或者运行时参数来控制。我们可以在代码中定义一个布尔变量，如 <code>bool hook_enable</code>，当它为真时启用 Hook 功能，为假时直接调用原始函数而不执行 Hook 函数。</li><li>特定条件下的 Hook：可以根据特定的条件来决定是否执行 Hook 函数。例如，可以检查参数的值、函数的调用者、当前的运行环境等条件，只有在满足特定条件时才执行 Hook 函数。</li></ol><h2 id=fdmanager>FdManager<a hidden class=anchor aria-hidden=true href=#fdmanager>#</a></h2><p>我们会通过<code>FdContext</code>类（注意与IOManager中的FdContext进行区分）来保存fd的一些状态，例如fd是否关闭了，是否设置为非阻塞，其读写事件超时时间是多少等。</p><h2 id=sleep-api>sleep API<a hidden class=anchor aria-hidden=true href=#sleep-api>#</a></h2><p>对<code>sleep</code>，<code>usleep</code>，<code>nanosleep</code>三个函数进行hook操作，其逻辑一致：sleep类函数会阻塞当前线程，那么我们的改造方法就是用一个定时器来代替sleep的休眠阻塞，获取当前运行的协程，然后通过IOManager添加一个定时器，规定时间后再将这个协程加入调度，之后yield这个协程。</p><h2 id=socket-api>socket API<a hidden class=anchor aria-hidden=true href=#socket-api>#</a></h2><ul><li>socket：当使用socket创建套接字fd时，我们需要将它加入到FdManager中。</li><li>connect：对于原始的<code>connect</code>，它是一个阻塞调用，直到连接成功或发生错误，如果网络延迟较高或目标主机不可达，可能会导致程序长时间挂起。我们需要将其改造为与异步或非阻塞操作结合。对应的实现方法就是通过设置一个超时时间，到时间后取消文件描述符的写事件。为socket fd添加写事件后，如果添加成功，则yield当前协程，并取消定时器</li><li>setsockopt：对于<code>optname</code>为<code>SO_RCVTIMEO</code>和<code>SO_RCVTIMEO</code>的情况，我们需要设置sockfd对应的超时时间。</li></ul><h2 id=socket-io-api>socket IO API<a hidden class=anchor aria-hidden=true href=#socket-io-api>#</a></h2><p>accept、read、readv、recv、recvfrom、recvmsg、write、writev、send、sendto、sendmsg这些函数所要作的hook操作都很类似，不同的地方无非就是读写事件的不同，其处理逻辑和connect相似，所以利用了模板来减少冗余代码。</p><h2 id=other-api>other API<a hidden class=anchor aria-hidden=true href=#other-api>#</a></h2><p>还有类似close、ioctl、fcntl的函数，由于我们在之前hook api时处理了文件描述符，因此在这些函数中我们需要对文件描述符进行清理或其他操作。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project0-c++-primer-%E5%B0%8F%E7%BB%93/><span class=title>« Prev</span><br><span>【CMU15-445 Fall2023】Project0 C++ Primer 小结</span>
</a><a class=next href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%89%8B%E5%86%99%E5%8D%8F%E7%A8%8B%E5%BA%93-4io%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/><span class=title>Next »</span><br><span>【动手写协程库 4】IO协程调度器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>