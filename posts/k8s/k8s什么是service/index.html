<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【k8s】什么是Service | Kerolt's Blog</title><meta name=keywords content><meta name=description content="在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：

✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。

为什么需要 Service？
在 Kubernetes 中：

Pod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变
如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败
我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化

Service 的核心功能为：

  
      
          功能
          说明
      
  
  
      
          服务发现
          通过 Service 名称（在集群内 DNS 可解析）访问后端应用
      
      
          负载均衡
          自动将请求分发到后端多个 Pod 实例
      
      
          解耦访问与实现
          用户访问 Service，无需关心后端是哪些 Pod、IP 是多少
      
      
          支持多种暴露方式
          可在集群内访问、节点上暴露、或对外暴露公网访问
      
  

Service 如何工作？

创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app）
Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP）
kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡
当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod

Service 的 4 种类型
1️⃣ ClusterIP（默认）

只在集群内部可访问
为 Service 分配一个集群内虚拟 IP
适用于微服务之间互相调用

spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: my-app
2️⃣ NodePort

在每个节点上开放一个端口（默认 30000-32767）
外部用户可通过 http://<NodeIP>:<NodePort> 访问服务
适合开发、测试或没有 LoadBalancer 的环境

spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30007  # 可选，不填则自动分配
  selector:
    app: my-app
3️⃣ LoadBalancer

适用于云平台（AWS、GCP、Azure、阿里云等）
云平台会自动创建一个外部负载均衡器，并分配公网 IP
用户通过公网 IP 访问服务
最适合生产环境对外暴露服务

spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: my-app

在 Minikube 或本地环境，可以使用 minikube service <service-name> 来模拟 LoadBalancer。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.5b90ca56d432f576bba1f6ce202271509c48bea7e64b7db7b3018ea0ce698db2.css integrity="sha256-W5DKVtQy9Xa7ofbOICJxUJxIvqfmS323swGOoM5pjbI=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【k8s】什么是Service"><meta property="og:description" content="在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：
✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。
为什么需要 Service？ 在 Kubernetes 中：
Pod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变 如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败 我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化 Service 的核心功能为：
功能 说明 服务发现 通过 Service 名称（在集群内 DNS 可解析）访问后端应用 负载均衡 自动将请求分发到后端多个 Pod 实例 解耦访问与实现 用户访问 Service，无需关心后端是哪些 Pod、IP 是多少 支持多种暴露方式 可在集群内访问、节点上暴露、或对外暴露公网访问 Service 如何工作？ 创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app） Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP） kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡 当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod Service 的 4 种类型 1️⃣ ClusterIP（默认） 只在集群内部可访问 为 Service 分配一个集群内虚拟 IP 适用于微服务之间互相调用 spec: type: ClusterIP ports: - port: 80 targetPort: 8080 selector: app: my-app 2️⃣ NodePort 在每个节点上开放一个端口（默认 30000-32767） 外部用户可通过 http://<NodeIP>:<NodePort> 访问服务 适合开发、测试或没有 LoadBalancer 的环境 spec: type: NodePort ports: - port: 80 targetPort: 8080 nodePort: 30007 # 可选，不填则自动分配 selector: app: my-app 3️⃣ LoadBalancer 适用于云平台（AWS、GCP、Azure、阿里云等） 云平台会自动创建一个外部负载均衡器，并分配公网 IP 用户通过公网 IP 访问服务 最适合生产环境对外暴露服务 spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: my-app 在 Minikube 或本地环境，可以使用 minikube service <service-name> 来模拟 LoadBalancer。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-07T00:00:00+00:00"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【k8s】什么是Service"><meta name=twitter:description content="在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：

✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。

为什么需要 Service？
在 Kubernetes 中：

Pod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变
如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败
我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化

Service 的核心功能为：

  
      
          功能
          说明
      
  
  
      
          服务发现
          通过 Service 名称（在集群内 DNS 可解析）访问后端应用
      
      
          负载均衡
          自动将请求分发到后端多个 Pod 实例
      
      
          解耦访问与实现
          用户访问 Service，无需关心后端是哪些 Pod、IP 是多少
      
      
          支持多种暴露方式
          可在集群内访问、节点上暴露、或对外暴露公网访问
      
  

Service 如何工作？

创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app）
Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP）
kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡
当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod

Service 的 4 种类型
1️⃣ ClusterIP（默认）

只在集群内部可访问
为 Service 分配一个集群内虚拟 IP
适用于微服务之间互相调用

spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: my-app
2️⃣ NodePort

在每个节点上开放一个端口（默认 30000-32767）
外部用户可通过 http://<NodeIP>:<NodePort> 访问服务
适合开发、测试或没有 LoadBalancer 的环境

spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30007  # 可选，不填则自动分配
  selector:
    app: my-app
3️⃣ LoadBalancer

适用于云平台（AWS、GCP、Azure、阿里云等）
云平台会自动创建一个外部负载均衡器，并分配公网 IP
用户通过公网 IP 访问服务
最适合生产环境对外暴露服务

spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: my-app

在 Minikube 或本地环境，可以使用 minikube service <service-name> 来模拟 LoadBalancer。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【k8s】什么是Service","item":"https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【k8s】什么是Service","name":"【k8s】什么是Service","description":"在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：\n✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。\n为什么需要 Service？ 在 Kubernetes 中：\nPod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变 如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败 我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化 Service 的核心功能为：\n功能 说明 服务发现 通过 Service 名称（在集群内 DNS 可解析）访问后端应用 负载均衡 自动将请求分发到后端多个 Pod 实例 解耦访问与实现 用户访问 Service，无需关心后端是哪些 Pod、IP 是多少 支持多种暴露方式 可在集群内访问、节点上暴露、或对外暴露公网访问 Service 如何工作？ 创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app） Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP） kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡 当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod Service 的 4 种类型 1️⃣ ClusterIP（默认） 只在集群内部可访问 为 Service 分配一个集群内虚拟 IP 适用于微服务之间互相调用 spec: type: ClusterIP ports: - port: 80 targetPort: 8080 selector: app: my-app 2️⃣ NodePort 在每个节点上开放一个端口（默认 30000-32767） 外部用户可通过 http://\u0026lt;NodeIP\u0026gt;:\u0026lt;NodePort\u0026gt; 访问服务 适合开发、测试或没有 LoadBalancer 的环境 spec: type: NodePort ports: - port: 80 targetPort: 8080 nodePort: 30007 # 可选，不填则自动分配 selector: app: my-app 3️⃣ LoadBalancer 适用于云平台（AWS、GCP、Azure、阿里云等） 云平台会自动创建一个外部负载均衡器，并分配公网 IP 用户通过公网 IP 访问服务 最适合生产环境对外暴露服务 spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: my-app 在 Minikube 或本地环境，可以使用 minikube service \u0026lt;service-name\u0026gt; 来模拟 LoadBalancer。\n","keywords":[],"articleBody":"在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：\n✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。\n为什么需要 Service？ 在 Kubernetes 中：\nPod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变 如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败 我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化 Service 的核心功能为：\n功能 说明 服务发现 通过 Service 名称（在集群内 DNS 可解析）访问后端应用 负载均衡 自动将请求分发到后端多个 Pod 实例 解耦访问与实现 用户访问 Service，无需关心后端是哪些 Pod、IP 是多少 支持多种暴露方式 可在集群内访问、节点上暴露、或对外暴露公网访问 Service 如何工作？ 创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app） Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP） kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡 当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod Service 的 4 种类型 1️⃣ ClusterIP（默认） 只在集群内部可访问 为 Service 分配一个集群内虚拟 IP 适用于微服务之间互相调用 spec: type: ClusterIP ports: - port: 80 targetPort: 8080 selector: app: my-app 2️⃣ NodePort 在每个节点上开放一个端口（默认 30000-32767） 外部用户可通过 http://: 访问服务 适合开发、测试或没有 LoadBalancer 的环境 spec: type: NodePort ports: - port: 80 targetPort: 8080 nodePort: 30007 # 可选，不填则自动分配 selector: app: my-app 3️⃣ LoadBalancer 适用于云平台（AWS、GCP、Azure、阿里云等） 云平台会自动创建一个外部负载均衡器，并分配公网 IP 用户通过公网 IP 访问服务 最适合生产环境对外暴露服务 spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: my-app 在 Minikube 或本地环境，可以使用 minikube service 来模拟 LoadBalancer。\n4️⃣ ExternalName 不指向 Pod，而是通过 CNAME 指向一个外部域名 用于将集群内服务名称映射到外部服务（如数据库、第三方 API） spec: type: ExternalName externalName: my.database.example.com 举个例子 假设部署了一个 Web 应用：\nkubectl create deployment my-nginx --image=nginx 默认它没有对外暴露，只能通过 kubectl port-forward 临时访问。\n创建一个 Service 让它可被访问：\nkubectl expose deployment my-nginx --port=80 --target-port=8080 --type=NodePort 或写 YAML：\napiVersion: v1 kind: Service metadata: name: my-nginx-service spec: type: NodePort ports: - port: 80 # Service 暴露的端口 targetPort: 80 # Pod 容器监听的端口（nginx 默认 80） selector: app: my-nginx # 匹配 Deployment 的 label 然后：\nkubectl get svc # 输出示例： # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # my-nginx-service NodePort 10.96.123.123 80:30007/TCP 10s 访问 http://\u003c你的节点IP\u003e:30007 就能看到 Nginx 页面\nService 与 DNS Kubernetes 集群内置 CoreDNS，Service 会自动注册 DNS 记录：\n在集群内，你可以通过 ..svc.cluster.local 访问服务 同命名空间下，直接用 即可 例如：\n# 在集群内 Pod 中执行： curl http://my-nginx-service Service 与 Deployment/Pod 的关系 用户 → Service (稳定入口) → 负载均衡 → 多个 Pod（动态、IP 会变） ↑ 由 Deployment 管理 Deployment 管理 Pod 生命周期（滚动更新、扩缩容） Service 管理网络访问（服务发现 + 负载均衡） 二者配合，实现高可用、弹性、稳定的应用架构 ","wordCount":"292","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-09-07T00:00:00Z","dateModified":"2025-09-07T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【k8s】什么是Service</h1><div class=post-meta><span title='2025-09-07 00:00:00 +0000 UTC'>2025-09-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;292 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-service aria-label="为什么需要 Service？">为什么需要 Service？</a></li><li><a href=#service-%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c aria-label="Service 如何工作？">Service 如何工作？</a></li><li><a href=#service-%e7%9a%84-4-%e7%a7%8d%e7%b1%bb%e5%9e%8b aria-label="Service 的 4 种类型">Service 的 4 种类型</a><ul><li><a href=#1-clusterip%e9%bb%98%e8%ae%a4 aria-label="1️⃣ ClusterIP（默认）">1️⃣ <code>ClusterIP</code>（默认）</a></li><li><a href=#2-nodeport aria-label="2️⃣ NodePort">2️⃣ <code>NodePort</code></a></li><li><a href=#3-loadbalancer aria-label="3️⃣ LoadBalancer">3️⃣ <code>LoadBalancer</code></a></li><li><a href=#4-externalname aria-label="4️⃣ ExternalName">4️⃣ <code>ExternalName</code></a></li></ul></li><li><a href=#%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90 aria-label=举个例子>举个例子</a></li><li><a href=#service-%e4%b8%8e-dns aria-label="Service 与 DNS">Service 与 DNS</a></li><li><a href=#service-%e4%b8%8e-deploymentpod-%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="Service 与 Deployment/Pod 的关系">Service 与 Deployment/Pod 的关系</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在 Kubernetes（K8s）中，<strong>Service（服务）</strong> 是一个非常核心、关键的抽象概念。它的主要作用是：</p><blockquote><p>✅ <strong>为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。</strong></p></blockquote><hr><h2 id=为什么需要-service>为什么需要 Service？<a hidden class=anchor aria-hidden=true href=#为什么需要-service>#</a></h2><p>在 Kubernetes 中：</p><ul><li>Pod 是<strong>临时的、动态的</strong> —— 它们随时可能被调度、重启、扩缩容，IP 会变</li><li>如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败</li><li>我们需要一个<strong>稳定的访问端点（Service）</strong>，无论后端 Pod 如何变化</li></ul><p>Service 的核心功能为：</p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><strong>服务发现</strong></td><td>通过 Service 名称（在集群内 DNS 可解析）访问后端应用</td></tr><tr><td><strong>负载均衡</strong></td><td>自动将请求分发到后端多个 Pod 实例</td></tr><tr><td><strong>解耦访问与实现</strong></td><td>用户访问 Service，无需关心后端是哪些 Pod、IP 是多少</td></tr><tr><td><strong>支持多种暴露方式</strong></td><td>可在集群内访问、节点上暴露、或对外暴露公网访问</td></tr></tbody></table><h2 id=service-如何工作>Service 如何工作？<a hidden class=anchor aria-hidden=true href=#service-如何工作>#</a></h2><ol><li>创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 <code>app: my-app</code>）</li><li>Kubernetes 为 Service 分配一个<strong>集群内唯一的虚拟 IP（ClusterIP）</strong></li><li>kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡</li><li>当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod</li></ol><h2 id=service-的-4-种类型>Service 的 4 种类型<a hidden class=anchor aria-hidden=true href=#service-的-4-种类型>#</a></h2><h3 id=1-clusterip默认>1️⃣ <code>ClusterIP</code>（默认）<a hidden class=anchor aria-hidden=true href=#1-clusterip默认>#</a></h3><ul><li>只在<strong>集群内部</strong>可访问</li><li>为 Service 分配一个集群内虚拟 IP</li><li>适用于微服务之间互相调用</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span></code></pre></div><h3 id=2-nodeport>2️⃣ <code>NodePort</code><a hidden class=anchor aria-hidden=true href=#2-nodeport>#</a></h3><ul><li>在<strong>每个节点</strong>上开放一个端口（默认 30000-32767）</li><li>外部用户可通过 <code>http://&lt;NodeIP>:&lt;NodePort></code> 访问服务</li><li>适合开发、测试或没有 LoadBalancer 的环境</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>NodePort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>nodePort</span><span class=p>:</span><span class=w> </span><span class=m>30007</span><span class=w>  </span><span class=c># 可选，不填则自动分配</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span></code></pre></div><h3 id=3-loadbalancer>3️⃣ <code>LoadBalancer</code><a hidden class=anchor aria-hidden=true href=#3-loadbalancer>#</a></h3><ul><li>适用于<strong>云平台</strong>（AWS、GCP、Azure、阿里云等）</li><li>云平台会自动创建一个<strong>外部负载均衡器</strong>，并分配公网 IP</li><li>用户通过公网 IP 访问服务</li><li>最适合生产环境对外暴露服务</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>LoadBalancer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>在 Minikube 或本地环境，可以使用 <code>minikube service &lt;service-name></code> 来模拟 LoadBalancer。</p></blockquote><h3 id=4-externalname>4️⃣ <code>ExternalName</code><a hidden class=anchor aria-hidden=true href=#4-externalname>#</a></h3><ul><li>不指向 Pod，而是<strong>通过 CNAME 指向一个外部域名</strong></li><li>用于将集群内服务名称映射到外部服务（如数据库、第三方 API）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ExternalName</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>externalName</span><span class=p>:</span><span class=w> </span><span class=l>my.database.example.com</span><span class=w>
</span></span></span></code></pre></div><h2 id=举个例子>举个例子<a hidden class=anchor aria-hidden=true href=#举个例子>#</a></h2><p>假设部署了一个 Web 应用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl create deployment my-nginx --image<span class=o>=</span>nginx
</span></span></code></pre></div><p>默认它没有对外暴露，只能通过 <code>kubectl port-forward</code> 临时访问。</p><p>创建一个 Service 让它可被访问：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl expose deployment my-nginx --port<span class=o>=</span><span class=m>80</span> --target-port<span class=o>=</span><span class=m>8080</span> --type<span class=o>=</span>NodePort
</span></span></code></pre></div><p>或写 YAML：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-nginx-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>NodePort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>        </span><span class=c># Service 暴露的端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>  </span><span class=c># Pod 容器监听的端口（nginx 默认 80）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-nginx    </span><span class=w> </span><span class=c># 匹配 Deployment 的 label</span><span class=w>
</span></span></span></code></pre></div><p>然后：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get svc
</span></span><span class=line><span class=cl><span class=c1># 输出示例：</span>
</span></span><span class=line><span class=cl><span class=c1># NAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span>
</span></span><span class=line><span class=cl><span class=c1># my-nginx-service   NodePort   10.96.123.123   &lt;none&gt;        80:30007/TCP   10s</span>
</span></span></code></pre></div><p>访问 <code>http://&lt;你的节点IP>:30007</code> 就能看到 Nginx 页面</p><h2 id=service-与-dns>Service 与 DNS<a hidden class=anchor aria-hidden=true href=#service-与-dns>#</a></h2><p>Kubernetes 集群内置 CoreDNS，Service 会自动注册 DNS 记录：</p><ul><li>在集群内，你可以通过 <code>&lt;service-name>.&lt;namespace>.svc.cluster.local</code> 访问服务</li><li>同命名空间下，直接用 <code>&lt;service-name></code> 即可</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在集群内 Pod 中执行：</span>
</span></span><span class=line><span class=cl>curl http://my-nginx-service
</span></span></code></pre></div><h2 id=service-与-deploymentpod-的关系>Service 与 Deployment/Pod 的关系<a hidden class=anchor aria-hidden=true href=#service-与-deploymentpod-的关系>#</a></h2><pre tabindex=0><code>用户 → Service (稳定入口) → 负载均衡 → 多个 Pod（动态、IP 会变）
                          ↑
                      由 Deployment 管理
</code></pre><ul><li>Deployment 管理 Pod 生命周期（滚动更新、扩缩容）</li><li>Service 管理网络访问（服务发现 + 负载均衡）</li><li>二者配合，实现<strong>高可用、弹性、稳定</strong>的应用架构</li></ul></div><footer class=post-footer><nav class=paginav><a class=next href=https://kerolt.github.io/posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/windows11%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%85%B3%E9%97%AD%E6%89%A9%E5%B1%95/><span class=title>Next »</span><br><span>Windows11右键菜单关闭扩展</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>