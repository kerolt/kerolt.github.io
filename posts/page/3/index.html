<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Kerolt's Blog</title><meta name=keywords content><meta name=description content="Posts - Kerolt's Blog"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.ef9ab3c5a056d4b92179b140aee474d5f961270bacb25621ebcfd8a244feac6a.css integrity="sha256-75qzxaBW1LkhebFAruR01flhJwusslYh68/YokT+rGo=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=stylesheet href=css/extended/custom.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>什么是云原生（自我解惑）</h2></header><div class=entry-content><p>云原生​​是一套以​​微服务、容器、动态编排（如 Kubernetes）、DevOps​​为核心，旨在构建和运行​​弹性、可靠、敏捷​​的云化应用的最佳实践集合。
理解它的关键在于思维的转变：​​从把云当作一台更便宜的虚拟主机，转变为把云当作一个可无限扩展、按需取用的计算能力平台，并以此为前提来设计和构建应用。​
什么是云原生？ ​​云原生​​ 是一种构建和运行应用程序的全新方法论，它充分利用了云计算的优势。
简单来说，​​云原生 = 云 + 原生​​。
​​云​​：指的是应用程序运行在云环境中，而不仅仅是托管在云服务器上。 ​​原生​​：意味着应用程序从设计、开发、部署到运维的整个生命周期，都是​​专门为云环境而设计和构建的​​，是“云上的原住民”。 它不是某一种具体的技术，而是一套​​技术体系、方法论和最佳实践的集合​​，其核心目标是构建和运行​​弹性扩展、韧性可靠、易于管理、可观测、松耦合的现代化应用​​。
如何通俗地理解云原生 我们可以用一个生动的比喻来理解：
​​传统应用 vs. 云原生应用​​
想象一下，你要运送货物。
​​传统应用（像“巨石应用”）​​：就像把所有的货物都塞进一个巨大的、不可分割的木箱里。这个木箱非常沉重，需要一辆巨大的卡车（一台强大的服务器）来运输。如果想扩大运力，你必须换一辆更大的卡车（升级服务器，​​纵向扩展​​），这个过程很慢，而且一旦卡车抛锚，所有货物都会受损。
​​对应现实​​：一个庞大的、所有功能都紧密耦合在一起的传统软件（如一个庞大的 ERP 系统），部署和维护都非常笨重。 ​​云原生应用（像“乐高应用”）​​：就像把货物分装在许多标准化的小集装箱（​​微服务​​）里。每个集装箱都可以被单独搬运、检查、替换。你可以根据需要轻松地增加或减少集装箱的数量（​​弹性伸缩​​），并且用许多辆小卡车（廉价的普通服务器）组成车队来运输。即使有几辆小卡车坏掉，也只会影响部分货物，整个运输系统不会瘫痪。
​​对应现实​​：一个应用被拆分成许多小的、独立的服务（如用户服务、订单服务、支付服务），它们可以独立开发、部署和扩展。 云原生的四大核心要素 要支撑上述的“乐高式”应用，需要一套强大的技术框架。云原生主要由以下四大核心技术要素构成：
​​微服务​​
​​是什么​​：将大型单体应用拆分为一组小的、松耦合的、可独立部署和升级的服务。 ​​好处​​：每个服务可以由不同的团队用不同的技术栈开发，更新速度快，容错性高。 ​​容器化​​
​​是什么​​：最代表性的技术是 ​​Docker​​。它将应用程序及其所有依赖项（库、环境配置等）打包成一个标准化的、轻量级的、可移植的“容器镜像”。这个容器在任何地方（开发、测试、生产环境）的运行效果都是一致的。 ​​好处​​：解决了“在我这运行得好好的，到你那就出问题”的环境一致性问题，是应用的标准交付件。 ​​动态编排​​
​​是什么​​：最代表性的技术是 ​​Kubernetes​​。当你有成千上万个容器需要管理时，Kubernetes 就像一位​​超级调度员和管家​​。它负责自动部署容器、故障恢复（容器挂了自动重启）、弹性伸缩（流量大了自动增加容器数量）、负载均衡等。 ​​好处​​：实现了应用的自动化和智能化运维，是云原生的操作系统。 ​​DevOps 和持续交付​​
​​是什么​​：​​DevOps​​ 是一种文化理念和实践，它打通了开发（Development）和运维（Operations）团队，通过高度自动化工具链（如 CI/CD），实现软件的频繁、可靠、快速的交付。 ​​好处​​：使得从代码提交到应用上线的过程可以完全自动化，极大地加快了迭代速度。 ​​简单总结一下四者的关系​​：
我们用 ​​DevOps​​ 的文化和 ​​CI/CD​​ 的工具，来自动化地开发、构建和测试​​微服务​​，并将其打包成​​容器​​，最后交给 ​​Kubernetes​​ 这个编排系统去动态地管理和运行。
为什么需要云原生？它的优势是什么？ 采用云原生架构能带来巨大的商业和技术价值：
​​弹性与可扩展性​​：应用可以根据流量压力自动缩扩容，轻松应对“双十一”等高峰场景，同时节省空闲时的资源成本。 ​​高韧性与故障隔离​​：单个服务的故障不会导致整个系统崩溃，系统具备自愈能力。 ​​快速迭代与交付​​：微服务和 DevOps 使得新功能可以独立、频繁、安全地发布，大大加快了市场响应速度。 ​​资源利用率高​​：容器非常轻量，可以在同一台机器上密集部署，节省硬件成本。 ​​可移植性​​：容器化的应用可以运行在任何云平台（公有云、私有云、混合云）上，避免被单一云厂商锁定。 云环境和托管在云服务器上有什么区别 特性 托管在云服务器上（租用办公室） 构建在云环境上（打造智能企业） ​​核心思想​​ ​​“换地方”​​ ​​“换活法”​​ ​​比喻​​ 你租用了一间云厂商的​​办公室（云服务器）​​，然后把自家机房里的​​旧家具、旧电脑（传统应用）​​ 原封不动地搬了进去。运维方式完全没变。 你利用云厂商提供的​​全套智能办公解决方案（云服务）​​：按需使用的会议室（计算资源）、自动化的物流系统（CI/CD）、可随意拼拆的工位（容器）、智能调度系统（Kubernetes）来​​重新组建一个高效、灵活的现代化公司（云原生应用）​​。 ​​弹性伸缩​​ ​​手动、缓慢​​。需要更多资源时，需要人工干预去升级服务器配置（​​纵向扩展​​），这通常需要停机。 ​​自动、即时​​。应用可根据流量压力，自动增加或减少计算资源（​​横向扩展​​），过程无缝，按实际使用量计费。 ​​韧性/可靠性​​ ​​依赖单机​​。如果托管你应用的这台云服务器宕机，你的服务就中断了，直到你手动将其恢复或迁移到另一台服务器。 ​​内置高可用​​。应用被设计为分布式、多实例运行。即使底层一台或多台服务器宕机，编排系统会自动在健康的服务器上重启应用实例，用户无感知。 ​​资源管理​​ ​​以服务器为中心​​。你需要关心每台服务器的 CPU、内存、磁盘使用率，并进行运维。 ​​以应用为中心​​。你只需声明“我的应用需要 2 核 4G”，云平台会自动调度和分配资源，你不再需要关心应用具体跑在哪台物理机上。 ​​成本模式​​ ​​为资源预留付费​​。你租了一台云服务器，无论你是否满负荷使用它，你都需要为它整个月的配置付费。 ​​为资源消耗付费​​。你只为应用程序实际消耗的 CPU 秒、内存 MB、网络流量付费。利用率极高，成本显著优化。 ​​技术栈​​ 传统架构，如：​​单体应用​​ + ​​服务器​​ + ​​SSH 运维​​。 云原生架构，如：​​微服务​​ + ​​容器​​ + ​​Kubernetes​​ + ​​DevOps​​。 ​​与云的关系​​ ​​租赁关系​​。你只是租用它的基础空间和硬件。 ​​共生关系​​。你的应用深度使用了云提供的数据库、消息队列、AI、大数据等​​托管服务​​，与应用紧密集成。</p></div><footer class=entry-footer><span title='2025-09-17 00:00:00 +0000 UTC'>发布于2025-09-17</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 什么是云原生（自我解惑）" href=https://kerolt.github.io/posts/k8s/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F%E8%87%AA%E6%88%91%E8%A7%A3%E6%83%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【k8s】什么是Service</h2></header><div class=entry-content><p>在 Kubernetes（K8s）中，Service（服务） 是一个非常核心、关键的抽象概念。它的主要作用是：
✅ 为一组 Pod 提供稳定的网络访问入口（IP + Port），实现服务发现和负载均衡。
为什么需要 Service？ 在 Kubernetes 中：
Pod 是临时的、动态的 —— 它们随时可能被调度、重启、扩缩容，IP 会变 如果其他应用或用户直接访问 Pod IP，一旦 Pod 重建，连接就会失败 我们需要一个稳定的访问端点（Service），无论后端 Pod 如何变化 Service 的核心功能为：
功能 说明 服务发现 通过 Service 名称（在集群内 DNS 可解析）访问后端应用 负载均衡 自动将请求分发到后端多个 Pod 实例 解耦访问与实现 用户访问 Service，无需关心后端是哪些 Pod、IP 是多少 支持多种暴露方式 可在集群内访问、节点上暴露、或对外暴露公网访问 Service 如何工作？ 创建一个 Service，并指定“选择器（selector）”来匹配一组 Pod（如 app: my-app） Kubernetes 为 Service 分配一个集群内唯一的虚拟 IP（ClusterIP） kube-proxy 组件在每个节点上设置 iptables/IPVS 规则，实现流量转发和负载均衡 当请求发送到 Service 的 IP:Port，流量会被自动转发到后端健康的 Pod Service 的 4 种类型 1️⃣ ClusterIP（默认） 只在集群内部可访问 为 Service 分配一个集群内虚拟 IP 适用于微服务之间互相调用 spec: type: ClusterIP ports: - port: 80 targetPort: 8080 selector: app: my-app 2️⃣ NodePort 在每个节点上开放一个端口（默认 30000-32767） 外部用户可通过 http://&lt;NodeIP>:&lt;NodePort> 访问服务 适合开发、测试或没有 LoadBalancer 的环境 spec: type: NodePort ports: - port: 80 targetPort: 8080 nodePort: 30007 # 可选，不填则自动分配 selector: app: my-app 3️⃣ LoadBalancer 适用于云平台（AWS、GCP、Azure、阿里云等） 云平台会自动创建一个外部负载均衡器，并分配公网 IP 用户通过公网 IP 访问服务 最适合生产环境对外暴露服务 spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: my-app 在 Minikube 或本地环境，可以使用 minikube service &lt;service-name> 来模拟 LoadBalancer。
...</p></div><footer class=entry-footer><span title='2025-09-07 00:00:00 +0000 UTC'>发布于2025-09-07</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【k8s】什么是Service" href=https://kerolt.github.io/posts/k8s/k8s%E4%BB%80%E4%B9%88%E6%98%AFservice/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【问题记录】ddns-go与IPv6网络配置</h2></header><div class=entry-content><p>在完成 Rustdesk 自建服务器 的搭建后，我又想到：由于实验室服务器的公网 IPv6 地址 并非永久不变，直接使用 IP 进行远程连接（如 SSH 或 Rustdesk）并不现实，如何确保远程访问的稳定性和便利性呢。为了解决这一痛点，我决定利用 动态域名解析（DDNS） 技术，配合 ddns-go 和 阿里云 DNS 服务，将服务器的动态 IP 地址实时绑定到一个易于记忆的域名上。
本文将记录我在配置过程中遇到的四个主要问题及其解决方案。
问题 1：IPv6 临时地址导致域名解析不稳定 在启用 ddns-go 服务后，我发现尽管程序运行正常，但我的域名解析记录却频繁失效。经过排查，我意识到罪魁祸首是 IPv6 临时地址（Temporary Address）。这是一种为了增强用户隐私而设计的特性，系统会定期生成新的、临时的 IPv6 地址用于出站连接。当服务器的地址发生变化时，DDNS 服务来不及同步更新，就会导致域名无法解析到正确的 IP 地址。
解决方案：禁用 IPv6 临时地址 要解决这个问题，最直接的方法就是从系统层面禁用 IPv6 临时地址功能，强制使用稳定的、非临时的地址。
编辑 sysctl 配置文件： 使用 vim 或其他编辑器打开 sysctl.conf 文件，该文件用于在系统启动时配置内核参数。 sudo vim /etc/sysctl.conf 添加配置项： 在文件末尾添加以下两行，分别用于全局禁用和默认禁用所有网络接口的 IPv6 临时地址功能。 # 禁用 IPv6 临时地址 net.ipv6.conf.all.use_tempaddr = 0 net.ipv6.conf.enp4s0.use_tempaddr = 0 注意：如果只想针对特定网卡（例如 enp4s0）进行配置，可以添加 net.ipv6.conf.enp4s0.use_tempaddr = 0。你可以通过 ip a 命令查看你机器的网卡名称。
...</p></div><footer class=entry-footer><span title='2025-08-29 00:00:00 +0000 UTC'>发布于2025-08-29</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【问题记录】ddns-go与IPv6网络配置" href=https://kerolt.github.io/posts/net/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95ddns-go%E4%B8%8Eipv6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rustdesk自建服务器</h2></header><div class=entry-content><p>对于现在常见的远程控制软件，例如 ToDesk、向日葵，其免费版本总有诸多限制（帧率低、分辨率低、控制时间有限制），而 RustDesk 的公共服务器现在在国内也不可用，因此我就想到了 RustDesk 的自建服务器。现在我们实验室有几台空闲的电脑，并且这些电脑都有 IPv6，这就省去了我购买云服务器的花费，可以实现零成本搭建远程服务😁
安装 RustDesk Server 我使用 https://github.com/sshpc/rustdesktool 这里的脚本来一键安装，安装完后，RustDesk Server 的默认安装目录为：
/usr/local/rustdesk-sever 开放端口 我们需要放行防火墙 TCP & UDP 端口 21115-21119，其中
21115 是 hbbs 用作 NAT 类型测试 21116/UDP 是 hbbs 用作 ID 注册与心跳服务 21116/TCP 是 hbbs 用作 TCP 打洞与连接服务 21117 是 hbbr 用作中继服务 # 允许 TCP 端口 sudo ufw allow 21115:21119/tcp # 允许 UDP 端口 sudo ufw allow 21115:21119/udp sudo ufw enable 然后执行
sudo ufw status 如果有如下类似输出，表明端口已经放行并且防火墙正在运行。
状态：活动 至 动作 来自 -- -- -- 21115:21119/tcp ALLOW Anywhere 21115:21119/udp ALLOW Anywhere 21115:21119/tcp (v6) ALLOW Anywhere (v6) 21115:21119/udp (v6) ALLOW Anywhere (v6) 启动服务 在我们用脚本一键安装后，服务安装目录为：
...</p></div><footer class=entry-footer><span title='2025-08-25 00:00:00 +0000 UTC'>发布于2025-08-25</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to Rustdesk自建服务器" href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/rustdesk%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C&amp;C++类型双关转换</h2></header><div class=entry-content><p>#include &lt;iostream> auto ASSERT(bool flag, const char* msg) { if (!flag) { std::cerr &lt;&lt; msg &lt;&lt; std::endl; } } // READ: 枚举类型 &lt;https://zh.cppreference.com/w/cpp/language/enum> // `enum` 是 C 的兼容类型，本质上其对应类型的常量。 // 在 `enum` 中定义标识符等价于定义 constexpr 常量， // 这些标识符不需要前缀，可以直接引用。 // 因此 `enum` 定义会污染命名空间。 enum ColorEnum : unsigned char { COLOR_RED = 31, COLOR_GREEN, COLOR_YELLOW, COLOR_BLUE, }; // 有作用域枚举型是 C++ 引入的类型安全枚举。 // 其内部标识符需要带前缀引用，如 `Color::Red`。 // 作用域枚举型可以避免命名空间污染，并提供类型安全保证。 enum class Color : int { Red = COLOR_RED, Green, Yellow, Blue, }; ColorEnum convert_by_pun(Color c) { // READ: &lt;https://zh.cppreference.com/w/cpp/language/union> // `union` 表示在同一内存位置存储的不同类型的值。 // 其常见用法是实现类型双关转换，即将一种类型的值转换为另一种无关类型的值。 // 但这种写法实际上仅在 C 语言良定义，在 C++ 中是未定义行为。 // 这是比较少见的 C++ 不与 C 保持兼容的特性。 // READ: 类型双关 &lt;https://tttapa.github.io/Pages/Programming/Cpp/Practices/type-punning.html> union TypePun { ColorEnum e; Color c; }; TypePun pun; pun.c = c; return pun.e; } int main(int argc, char **argv) { ASSERT(convert_by_pun(Color::Red) == COLOR_RED, "Type punning conversion"); ASSERT(convert_by_pun(Color::Green) == COLOR_GREEN, "Type punning conversion"); ASSERT(convert_by_pun(Color::Yellow) == COLOR_YELLOW, "Type punning conversion"); ASSERT(convert_by_pun(Color::Blue) == COLOR_BLUE, "Type punning conversion"); return 0; }</p></div><footer class=entry-footer><span title='2025-08-21 00:00:00 +0000 UTC'>发布于2025-08-21</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C&C++类型双关转换" href=https://kerolt.github.io/posts/c++/cc++%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3%E8%BD%AC%E6%8D%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git中文件换行符都使用LF</h2></header><div class=entry-content><p>有时候我们会在多个平台上编辑文件、代码，此时我们希望所有文件，包括你在 Windows 上编辑的文件（Windows 采用的是 CRLF），都使用 LF 换行符，那么可以修改 .gitattributes 文件来强制执行这个规则：
# 强制所有文件使用 LF 换行符 * text eol=lf # 避免对二进制文件进行换行符转换 *.png binary *.jpg binary *.pdf binary 在保存提交 .gitattributes 后，可能因为之前在 Windows 上编辑的文件可能已经变成了 CRLF 换行符，这时需要需要将它们转换回 LF（这里可以使用 VSCode）。
接着可以执行以下命令，让 Git 重新处理工作目录中的文件并按照新的规则来转换：
git rm --cached -r . git reset --hard * text eol=lf：这条规则告诉 Git，将仓库中的所有文件都视为文本文件，并且强制它们使用 LF 作为行结束符。当你从仓库检出文件时，Git 会将其转换为 CRLF（在 Windows 上），但当你提交时，它会确保所有文件都以 LF 格式存储在仓库中。
git rm --cached -r . 和 git reset --hard：这些命令会强制 Git 重新将你的工作目录与仓库同步，并在此过程中应用 .gitattributes 文件中设置的换行符规则，从而确保所有文件都符合 LF 规范。</p></div><footer class=entry-footer><span title='2025-08-21 00:00:00 +0000 UTC'>发布于2025-08-21</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to Git中文件换行符都使用LF" href=https://kerolt.github.io/posts/git/git%E4%B8%AD%E6%96%87%E4%BB%B6%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%83%BD%E4%BD%BF%E7%94%A8lf/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于内存对齐、位域的思考</h2></header><div class=entry-content><p>什么是内存对齐？为什么需要它？ 内存对齐（Memory Alignment）是计算机系统中数据在内存中存储的一种规则：​​数据在内存中的起始地址必须是其自身大小的整数倍​​。例如，一个 4 字节的整型变量（int），其起始地址必须是 4 的倍数（如地址 0x0000、0x0004、0x0008 等）。
而需要内存对齐主要基于以下三个原因：
​​硬件访问效率​​： CPU 通过内存总线从内存读取数据时，通常以固定大小的“块”为单位（例如 4 字节或 8 字节）。如果数据对齐，CPU 一次读取操作即可获取完整数据。 ​​非对齐示例​​：假设一个 int 变量（4 字节）存储在地址 0x0001（非 4 的倍数），CPU 需要分两次读取：先读取 0x0000-0x0003（包含前 3 字节），再读取 0x0004-0x0007（包含最后 1 字节），最后拼接数据。这会显著降低性能。 ​​硬件兼容性​​： 部分架构（如 ARM、MIPS）的 CPU 无法直接访问非对齐内存。尝试访问时会导致硬件异常（如“总线错误”）。对齐保证了代码的跨平台兼容性。 ​​缓存效率优化​​： 现代 CPU 使用缓存行（Cache Line，通常 64 字节）预加载数据。对齐的数据更可能完整地位于单个缓存行中。若数据跨缓存行存储，会引发两次缓存访问，降低效率。 alignas 和 alignof c++11 以后引入两个关键字 alignas 与 alignof。
alignas 用于显式设置变量、类成员或类型的内存对齐要求；而 alignof 用于获取类型或变量的内存对齐要求。例如：
struct Test1 {}; struct alignas(4) Test2 {}; static_assert(sizeof(Test1) == 1); static_assert(sizeof(Test2) == 4); static_assert(alignof(Test1) == 1); static_assert(alignof(Test2) == 4); alignas 支持三种语法形式：
alignas(expression)：expression 必须是计算结果为零的整数常量表达式，或者是对齐或扩展对齐的有效值（2 的倍数）。 alignas(type-id)：等效于 alignas(alignof(type-id)) alignas(pack...)：等效于应用于同一声明的多个 alignas 说明符，参数包的每个成员对应一个说明符，可以是类型参数包或常量参数包 Note 注意：若指定的对齐值小于编译器默认对齐要求，部分编译器可能忽略该设置。
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0000 UTC'>发布于2025-07-22</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 关于内存对齐、位域的思考" href=https://kerolt.github.io/posts/c++/%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BD%8D%E5%9F%9F%E7%9A%84%E6%80%9D%E8%80%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>eBPF Map中的数据成员类型的宏定义</h2></header><div class=entry-content><p>__uint, __type, __array, __ulong 这些宏主要用于 eBPF Map 的定义 中，帮助 LLVM 编译器和 BPF CO-RE (Compile Once – Run Everywhere) 理解和提取 eBPF Map 的元数据信息。它们通常与 BPF_MAP_DEF 或 struct 配合使用，在 eBPF 程序中用于告诉内核如何创建 BPF map。
常用的几个宏 1. __uint(name, val) #define __uint(name, val) int (*name)[val] 用途：定义一个名为 name 的字段，其值是一个大小为 val 的整数数组指针。
__uint(max_entries, 1024); 等价于：
int (*max_entries)[1024]; 作用：
用于在 eBPF Map 的定义中指定 max_entries 这一属性（即 map 的最大容量）。这种“类型欺骗”的方式让 clang 编译器能保留这些信息在 ELF 文件的 BTF（BPF Type Format）部分里，从而被 bpftool、libbpf 提取并传给内核。
2. __type(name, val) #define __type(name, val) typeof(val) *name 用途：定义一个名为 name 的字段，其类型是 val 的指针。
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0000 UTC'>发布于2025-07-07</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to eBPF Map中的数据成员类型的宏定义" href=https://kerolt.github.io/posts/ebpf/ebpf-map%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CO-RE机制与vmlinux.h</h2></header><div class=entry-content><p>通过解耦编译时依赖和运行时重定位，实现 BPF 程序对内核版本与配置差异的自动适配。vmlinux.h 之所以无需严格匹配你的内核配置或版本，关键在于以下机制：
BTF（BPF Type Format）提供统一类型描述 vmlinux.h 本质是内核 BTF 的 C 语言翻译：它由 bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h 命令生成，完整包含内核所有数据结构的类型定义（如结构体、枚举）。 独立于具体配置：BTF 记录了内核的最终内存布局（包括因配置选项如 CONFIG_COMPAT 导致的字段偏移变化）。因此，编译时使用的 vmlinux.h 只需是某一有效内核的 BTF 快照，无需与目标内核完全一致。 生成 vmlinux.h bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h Clang 编译时记录“重定位元信息” 当使用 Clang（≥10）编译 BPF 程序时，对内核结构的访问（如 task_struct->pid）会被转换为 CO-RE 重定位项。这些项记录： 访问的字段名（如 pid） 类型路径（如 struct task_struct） 预期偏移/大小等。 此过程依赖 vmlinux.h 提供类型合法性检查，但不绑定具体偏移。 libbpf 运行时动态重定位 加载 BPF 程序时，libbpf 执行关键两步： 查询目标内核的 BTF（/sys/kernel/btf/vmlinux），获取实际结构布局； 比对编译时的重定位项，修正字段偏移、处理字段增减（如通过 bpf_core_field_exists() 判断成员是否存在）。 例如：若目标内核的 struct user_arg_ptr 因 CONFIG_COMPAT=y 新增 is_compat 字段，libbpf 会自动调整 native 字段的访问偏移。 CO-RE 辅助函数实现条件兼容 BPF 代码可通过以下函数动态适应内核差异： bpf_core_read(dst, src)：替代直接指针访问，按运行时偏移安全读取字段； BPF_CORE_READ(src, field)：处理嵌套结构； bpf_core_field_exists(field)：条件执行兼容逻辑（如选择参数索引）。 这些函数在编译时生成重定位项，在运行时由 libbpf 解析为正确操作。 实际限制与注意事项 限制 说明 目标内核需开启 BTF 必须配置 CONFIG_DEBUG_INFO_BTF=y（多数发行版已默认开启）。 旧内核无 BTF 支持 若无 BTF，需手动提供等效的 BTF 文件（如通过 BTFHub）。 宏与函数签名变化 BTF 不记录宏或函数参数列表变化，需通过 #ifdef 或运行时检测处理。 BPF CO-RE 将类型描述（vmlinux.h）、编译时元信息（Clang 重定位项）、运行时适配器（libbpf）三者分离，使 vmlinux.h 仅需作为“合法类型模板”，而非精确内存布局参考。最终由 libbpf 借助目标内核的 BTF 完成字段偏移、存在性的动态修正，实现跨版本/配置的运行兼容。这一机制大幅降低了 eBPF 程序的移植成本，使其真正成为“一次编译，到处运行”的内核可编程工具。</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0000 UTC'>发布于2025-07-01</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to CO-RE机制与vmlinux.h" href=https://kerolt.github.io/posts/ebpf/co-re%E6%9C%BA%E5%88%B6%E4%B8%8Evmlinux.h/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Curl使用</h2></header><div class=entry-content><p>curl 是一个强大的命令行工具，用于传输数据，支持多种协议（HTTP、HTTPS、FTP 等）。以下是 curl 的基本使用方法和常见示例。
基本语法 curl [options] [URL...] 常用选项 选项 描述 -X 指定 HTTP 请求方法 (GET, POST, PUT, DELETE 等) -H 添加请求头 -d 发送 POST 请求数据 -F 发送表单数据 (multipart/form-data) -G 将 -d 数据作为 GET 请求的查询参数 -o 将输出保存到文件 -O 将输出保存到文件，使用远程文件名 -L 跟随重定向 -v 显示详细输出 (verbose) -u 指定用户名和密码 -A 设置 User-Agent -k 允许不安全的 SSL 连接 -I 只获取响应头 -s 静默模式 (不显示进度或错误信息) --data-urlencode URL 编码 POST 数据 常见用法示例 1. 发送 GET 请求 curl https://example.com 2. 发送 POST 请求 curl -X POST https://example.com/api -d 'name=value' 3. 发送 JSON 数据 curl -X POST https://example.com/api \ -H "Content-Type: application/json" \ -d '{"key1":"value1", "key2":"value2"}' 4. 发送表单数据 curl -X POST https://example.com/form \ -d 'username=admin' \ -d 'password=123456' 5. 上传文件 curl -X POST https://example.com/upload \ -F "file=@/path/to/file.txt" 6. 设置请求头 curl -H "Authorization: Bearer token" \ -H "Content-Type: application/json" \ https://example.com/api 7. 下载文件 curl -O https://example.com/file.zip 8. 跟随重定向 curl -L https://example.com/redirect 9. 使用基本认证 curl -u username:password https://example.com 10. 保存 cookie 并发送 # 保存 cookie curl -c cookies.txt https://example.com/login -d "user=name&amp;pass=123" # 使用 cookie curl -b cookies.txt https://example.com/dashboard 11. 测试 API 响应时间 curl -o /dev/null -s -w 'Total: %{time_total}s\n' https://example.com 12. 限制下载速度 curl --limit-rate 100K -O https://example.com/largefile.zip 高级用法 发送多部分请求 curl -X POST https://example.com/upload \ -F "file=@image.jpg" \ -F "description=My image" 使用代理 curl -x http://proxy.example.com:8080 https://example.com 调试请求 curl -v https://example.com 只获取响应头 curl -I https://example.com 使用自定义 User-Agent curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" https://example.com 注意事项 在脚本中使用 curl 时，考虑添加 -s 或 -sS 选项（-S 显示错误） 处理 JSON 数据时，可以使用 jq 工具进行格式化 对于复杂的 API 调用，考虑将请求保存为文件并使用 -K 选项 在 Windows 上，使用双引号 " 而不是单引号 '</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0000 UTC'>发布于2025-07-01</span>&nbsp;&nbsp;·&nbsp;&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to Curl使用" href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/curl%E4%BD%BF%E7%94%A8/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://kerolt.github.io/posts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://kerolt.github.io/posts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>