<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Kerolt's Blog</title><meta name=keywords content><meta name=description content="Posts - Kerolt's Blog"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.5b90ca56d432f576bba1f6ce202271509c48bea7e64b7db7b3018ea0ce698db2.css integrity="sha256-W5DKVtQy9Xa7ofbOICJxUJxIvqfmS323swGOoM5pjbI=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kerolt.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>关于内存对齐、位域的思考</h2></header><div class=entry-content><p>什么是内存对齐？为什么需要它？ 内存对齐（Memory Alignment）是计算机系统中数据在内存中存储的一种规则：​​数据在内存中的起始地址必须是其自身大小的整数倍​​。例如，一个 4 字节的整型变量（int），其起始地址必须是 4 的倍数（如地址 0x0000、0x0004、0x0008 等）。
而需要内存对齐主要基于以下三个原因：
​​硬件访问效率​​： CPU 通过内存总线从内存读取数据时，通常以固定大小的“块”为单位（例如 4 字节或 8 字节）。如果数据对齐，CPU 一次读取操作即可获取完整数据。 ​​非对齐示例​​：假设一个 int 变量（4 字节）存储在地址 0x0001（非 4 的倍数），CPU 需要分两次读取：先读取 0x0000-0x0003（包含前 3 字节），再读取 0x0004-0x0007（包含最后 1 字节），最后拼接数据。这会显著降低性能。 ​​硬件兼容性​​： 部分架构（如 ARM、MIPS）的 CPU 无法直接访问非对齐内存。尝试访问时会导致硬件异常（如“总线错误”）。对齐保证了代码的跨平台兼容性。 ​​缓存效率优化​​： 现代 CPU 使用缓存行（Cache Line，通常 64 字节）预加载数据。对齐的数据更可能完整地位于单个缓存行中。若数据跨缓存行存储，会引发两次缓存访问，降低效率。 alignas 和 alignof c++11 以后引入两个关键字 alignas 与 alignof。
alignas 用于显式设置变量、类成员或类型的内存对齐要求；而 alignof 用于获取类型或变量的内存对齐要求。例如：
struct Test1 {}; struct alignas(4) Test2 {}; static_assert(sizeof(Test1) == 1); static_assert(sizeof(Test2) == 4); static_assert(alignof(Test1) == 1); static_assert(alignof(Test2) == 4); alignas 支持三种语法形式：
alignas(expression)：expression 必须是计算结果为零的整数常量表达式，或者是对齐或扩展对齐的有效值（2 的倍数）。 alignas(type-id)：等效于 alignas(alignof(type-id)) alignas(pack...)：等效于应用于同一声明的多个 alignas 说明符，参数包的每个成员对应一个说明符，可以是类型参数包或常量参数包 Note 注意：若指定的对齐值小于编译器默认对齐要求，部分编译器可能忽略该设置。
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0000 UTC'>2025-07-22</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 关于内存对齐、位域的思考" href=https://kerolt.github.io/posts/c++/%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BD%8D%E5%9F%9F%E7%9A%84%E6%80%9D%E8%80%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>eBPF Map中的数据成员类型的宏定义</h2></header><div class=entry-content><p>__uint, __type, __array, __ulong 这些宏主要用于 eBPF Map 的定义 中，帮助 LLVM 编译器和 BPF CO-RE (Compile Once – Run Everywhere) 理解和提取 eBPF Map 的元数据信息。它们通常与 BPF_MAP_DEF 或 struct 配合使用，在 eBPF 程序中用于告诉内核如何创建 BPF map。
常用的几个宏 1. __uint(name, val) #define __uint(name, val) int (*name)[val] 用途：定义一个名为 name 的字段，其值是一个大小为 val 的整数数组指针。
__uint(max_entries, 1024); 等价于：
int (*max_entries)[1024]; 作用：
用于在 eBPF Map 的定义中指定 max_entries 这一属性（即 map 的最大容量）。这种“类型欺骗”的方式让 clang 编译器能保留这些信息在 ELF 文件的 BTF（BPF Type Format）部分里，从而被 bpftool、libbpf 提取并传给内核。
2. __type(name, val) #define __type(name, val) typeof(val) *name 用途：定义一个名为 name 的字段，其类型是 val 的指针。
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0000 UTC'>2025-07-07</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;300 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to eBPF Map中的数据成员类型的宏定义" href=https://kerolt.github.io/posts/ebpf/ebpf-map%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CO-RE机制与vmlinux.h</h2></header><div class=entry-content><p>通过解耦编译时依赖和运行时重定位，实现 BPF 程序对内核版本与配置差异的自动适配。vmlinux.h 之所以无需严格匹配你的内核配置或版本，关键在于以下机制：
BTF（BPF Type Format）提供统一类型描述 vmlinux.h 本质是内核 BTF 的 C 语言翻译：它由 bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h 命令生成，完整包含内核所有数据结构的类型定义（如结构体、枚举）。 独立于具体配置：BTF 记录了内核的最终内存布局（包括因配置选项如 CONFIG_COMPAT 导致的字段偏移变化）。因此，编译时使用的 vmlinux.h 只需是某一有效内核的 BTF 快照，无需与目标内核完全一致。 生成 vmlinux.h bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h Clang 编译时记录“重定位元信息” 当使用 Clang（≥10）编译 BPF 程序时，对内核结构的访问（如 task_struct->pid）会被转换为 CO-RE 重定位项。这些项记录： 访问的字段名（如 pid） 类型路径（如 struct task_struct） 预期偏移/大小等。 此过程依赖 vmlinux.h 提供类型合法性检查，但不绑定具体偏移。 libbpf 运行时动态重定位 加载 BPF 程序时，libbpf 执行关键两步： 查询目标内核的 BTF（/sys/kernel/btf/vmlinux），获取实际结构布局； 比对编译时的重定位项，修正字段偏移、处理字段增减（如通过 bpf_core_field_exists() 判断成员是否存在）。 例如：若目标内核的 struct user_arg_ptr 因 CONFIG_COMPAT=y 新增 is_compat 字段，libbpf 会自动调整 native 字段的访问偏移。 CO-RE 辅助函数实现条件兼容 BPF 代码可通过以下函数动态适应内核差异： bpf_core_read(dst, src)：替代直接指针访问，按运行时偏移安全读取字段； BPF_CORE_READ(src, field)：处理嵌套结构； bpf_core_field_exists(field)：条件执行兼容逻辑（如选择参数索引）。 这些函数在编译时生成重定位项，在运行时由 libbpf 解析为正确操作。 实际限制与注意事项 限制 说明 目标内核需开启 BTF 必须配置 CONFIG_DEBUG_INFO_BTF=y（多数发行版已默认开启）。 旧内核无 BTF 支持 若无 BTF，需手动提供等效的 BTF 文件（如通过 BTFHub）。 宏与函数签名变化 BTF 不记录宏或函数参数列表变化，需通过 #ifdef 或运行时检测处理。 BPF CO-RE 将类型描述（vmlinux.h）、编译时元信息（Clang 重定位项）、运行时适配器（libbpf）三者分离，使 vmlinux.h 仅需作为“合法类型模板”，而非精确内存布局参考。最终由 libbpf 借助目标内核的 BTF 完成字段偏移、存在性的动态修正，实现跨版本/配置的运行兼容。这一机制大幅降低了 eBPF 程序的移植成本，使其真正成为“一次编译，到处运行”的内核可编程工具。</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0000 UTC'>2025-07-01</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;126 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to CO-RE机制与vmlinux.h" href=https://kerolt.github.io/posts/ebpf/co-re%E6%9C%BA%E5%88%B6%E4%B8%8Evmlinux.h/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Curl使用</h2></header><div class=entry-content><p>curl 是一个强大的命令行工具，用于传输数据，支持多种协议（HTTP、HTTPS、FTP 等）。以下是 curl 的基本使用方法和常见示例。
基本语法 curl [options] [URL...] 常用选项 选项 描述 -X 指定 HTTP 请求方法 (GET, POST, PUT, DELETE 等) -H 添加请求头 -d 发送 POST 请求数据 -F 发送表单数据 (multipart/form-data) -G 将 -d 数据作为 GET 请求的查询参数 -o 将输出保存到文件 -O 将输出保存到文件，使用远程文件名 -L 跟随重定向 -v 显示详细输出 (verbose) -u 指定用户名和密码 -A 设置 User-Agent -k 允许不安全的 SSL 连接 -I 只获取响应头 -s 静默模式 (不显示进度或错误信息) --data-urlencode URL 编码 POST 数据 常见用法示例 1. 发送 GET 请求 curl https://example.com 2. 发送 POST 请求 curl -X POST https://example.com/api -d 'name=value' 3. 发送 JSON 数据 curl -X POST https://example.com/api \ -H "Content-Type: application/json" \ -d '{"key1":"value1", "key2":"value2"}' 4. 发送表单数据 curl -X POST https://example.com/form \ -d 'username=admin' \ -d 'password=123456' 5. 上传文件 curl -X POST https://example.com/upload \ -F "file=@/path/to/file.txt" 6. 设置请求头 curl -H "Authorization: Bearer token" \ -H "Content-Type: application/json" \ https://example.com/api 7. 下载文件 curl -O https://example.com/file.zip 8. 跟随重定向 curl -L https://example.com/redirect 9. 使用基本认证 curl -u username:password https://example.com 10. 保存 cookie 并发送 # 保存 cookie curl -c cookies.txt https://example.com/login -d "user=name&amp;pass=123" # 使用 cookie curl -b cookies.txt https://example.com/dashboard 11. 测试 API 响应时间 curl -o /dev/null -s -w 'Total: %{time_total}s\n' https://example.com 12. 限制下载速度 curl --limit-rate 100K -O https://example.com/largefile.zip 高级用法 发送多部分请求 curl -X POST https://example.com/upload \ -F "file=@image.jpg" \ -F "description=My image" 使用代理 curl -x http://proxy.example.com:8080 https://example.com 调试请求 curl -v https://example.com 只获取响应头 curl -I https://example.com 使用自定义 User-Agent curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" https://example.com 注意事项 在脚本中使用 curl 时，考虑添加 -s 或 -sS 选项（-S 显示错误） 处理 JSON 数据时，可以使用 jq 工具进行格式化 对于复杂的 API 调用，考虑将请求保存为文件并使用 -K 选项 在 Windows 上，使用双引号 " 而不是单引号 '</p></div><footer class=entry-footer><span title='2025-07-01 00:00:00 +0000 UTC'>2025-07-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;248 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to Curl使用" href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/curl%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【eBPF学习】使用fentry跟踪tcp连接</h2></header><div class=entry-content><p>本文是对 cilium/ebpf examples: fentry 的一个学习记录
在这里，我们将会利用 ebpf 监控并记录系统上所有新发起的 IPv4 TCP 连接，其工作流程如下：
挂载点：程序使用 fentry 机制把自己附加到内核函数 tcp_connect 的入口。每当系统中有任何一个进程尝试发起一个 TCP 连接时，这个内核函数就会被调用，从而触发我们的 eBPF 程序。 过滤：程序首先检查连接的地址族是否为 AF_INET，即 IPv4。如果不是（例如是 IPv6），程序会直接退出，不做任何处理。 数据提取：对于 IPv4 连接，程序会从传递给 tcp_connect 函数的 struct sock 参数中提取以下关键信息： 源 IP 地址 (saddr) 目标 IP 地址 (daddr) 目标端口 (dport) 源端口 (sport) 获取进程信息：使用 bpf_get_current_comm() 辅助函数获取当前发起连接的进程名（例如 curl, ssh 等）。 数据发送：程序将收集到的所有信息（IP 地址、端口、进程名）打包成一个 struct event 结构体，并通过一个高效的 ringbuf 映射发送到用户空间。 什么是 fentry fentry 是 eBPF 中的一种程序附加类型，全称为 “function entry”（函数入口）。它是现代 Linux 内核中用于跟踪和性能分析的高效机制。
fentry 允许将 eBPF 程序附加到内核函数的入口点，当该函数被调用时，eBPF 程序会在函数的主体执行前运行。这种机制让我们可以：
...</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;538 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【eBPF学习】使用fentry跟踪tcp连接" href=https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8fentry%E8%B7%9F%E8%B8%AAtcp%E8%BF%9E%E6%8E%A5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>84. 柱状图中最大的矩形</h2></header><div class=entry-content><p>单调栈中保存每个柱子在 heights 中的下标，从栈底到栈顶的元素对应的柱子的高度是单调递增的。
顺序遍历 heights，如果 heights[i] 比栈顶对应柱子高度更小（heights[i] &lt; heights[st.top()]），那么说明 heights[st.top()] 这个高度在当前柱子加入后已经没有了作用（现在最小的高度是当前柱子，那么要算矩形面积的时候也只会用 heights[i] 来作为矩形的高）。
我们每次计算的矩形为 [栈顶元素代表的矩形, i对应的矩形)：
在弹出栈顶元素==后==，矩形的宽（weight）应该为 i - st.top() - 1，如果栈为空了就为 i - (-1) - 1 -> i。
class Solution { public: int largestRectangleArea(vector&lt;int>& heights) { stack&lt;int> st; int res = 0; heights.push_back(-1); for (int i = 0; i &lt; heights.size(); ++i) { while (!st.empty() && heights[i] &lt; heights[st.top()]) { int h = heights[st.top()]; st.pop(); int w = i; // 即 w = i - (-1) - 1 if (!st.empty()) { w = i - st.top() - 1; } res = max(res, h * w); } st.push(i); } return res; } };</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;103 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 84. 柱状图中最大的矩形" href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/84.-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++透明运算符</h2></header><div class=entry-content><p>透明运算符的概念与价值 在 C++ 编程中，当编写泛型代码时，不同类型的比较或操作可能导致意外的类型转换或精度损失。假设有一个 std::vector&lt;uint32_t>，使用自定义仿函数进行排序，一切运行正常。但当你将容器改为 std::vector&lt;uint64_t> 却忘记修改仿函数的实现时，编译器不会报错，但数据可能在比较前被静默截断，导致排序结果完全错误。而 C++14 引入透明运算符可以帮助我们避免这种 bug。
透明运算符（Transparent Operator）是 C++14 引入的一项强大特性，它通过 std::less&lt;>、std::greater&lt;> 等空模板参数的运算符函子实现，允许编译器在模板实例化时自动推导操作数的实际类型，从而避免不必要的类型转换和潜在错误。与传统的重载运算符不同，透明运算符的核心优势在于其类型透明性——它们不会强迫操作数转换为特定类型，而是根据操作数的实际类型进行推导，保留完整的类型信息。
传统 C++ 运算符重载需要严格定义操作数类型，这使得编写真正通用的泛型代码变得困难。例如，当我们使用 std::less&lt;int> 进行比较时，它会强制将两个操作数都视为 int 类型，如果操作数实际是 long 或 double，就可能发生精度损失或意外的类型转换。而透明运算符如 std::less&lt;> 则解决了这一问题，它本质上是一个模板化的函子，能够自动适应操作数的类型，保持代码的通用性和安全性。
实现原理 透明运算符的神奇之处在于其简洁而精妙的实现机制。让我们深入探究其工作原理，揭开这层看似简单的语法糖衣下蕴含的强大能力。
模板元编程技巧 透明运算符的核心实现依赖于空模板参数列表（operator&lt;>）这一巧妙设计。观察 std::less 的标准库实现，我们会发现它提供了两种形式：
// 传统形式：指定比较类型 template &lt;class T> struct less { bool operator()(const T& lhs, const T& rhs) const; }; // 透明形式：自动类型推导 template &lt;> struct less&lt;void> { template &lt;class T, class U> auto operator()(T&& t, U&& u) const -> decltype(std::forward&lt;T>(t) &lt; std::forward&lt;U>(u)); }; 当使用 std::less&lt;> 时，我们特化到了 less&lt;void>，它包含一个泛化的函数调用运算符。这个运算符是模板成员函数，接受任意类型的两个参数 T 和 U，并返回它们比较的结果。
类型推导与完美转发 透明运算符的实现依赖于两个现代 C++ 核心特性：自动类型推导和完美转发。当编译器遇到 std::less&lt;>{}(a, b) 这样的表达式时：
模板参数推导：编译器根据参数 a 和 b 的实际类型推导出模板参数 T 和 U 完美转发：通过 std::forward 保持参数的值类别（左值/右值），避免不必要的拷贝 返回类型推导：使用 decltype 自动推导比较结果的准确类型，保留常量性、引用性等类型信息 这种机制确保了比较操作以最直接的方式进行，不引入任何中间转换。例如，比较 int 和 double 时，编译器会直接生成 int 与 double 比较的代码，遵循标准的算术类型转换规则，而不是先将两者转换为同一类型。
...</p></div><footer class=entry-footer><span title='2025-06-20 00:00:00 +0000 UTC'>2025-06-20</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;376 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to C++透明运算符" href=https://kerolt.github.io/posts/c++/c++%E9%80%8F%E6%98%8E%E8%BF%90%E7%AE%97%E7%AC%A6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>【eBPF学习】使用kprobe监测捕获unlink系统调用</h2></header><div class=entry-content><p>本文是对于 Eunomia Tutorials 2 的一个学习记录
什么是 kprobe Kprobe​​（Kernel Probe）是 Linux 内核提供的一项强大功能，它允许开发者和系统管理员在不​​修改内核源代码​​或重启系统的前提下，在任意内核函数处动态插入“探针”：
​​工作原理​​：通过​​临时替换​​目标函数的前几条指令为一个断点指令（如 int3） ​​执行流程​​：当程序执行到断点时，CPU 控制权会交给 kprobe 系统 ​​事件回调​​：系统执行注册的回调函数，完成数据采集后恢复原函数执行 ​​两种类型​​： ​​Kprobe​​：在函数入口处执行 ​​Kretprobe​​：在函数返回时执行 这种机制为我们提供了​​零侵入式​​的内核行为洞察能力，特别适用于​​实时监控​​、​​性能分析​​和​​故障排查​​等场景。
do_unlinkat 的作用 do_unlinkat 是 Linux 内核中的一个内部函数，它的作用是执行文件或目录的删除操作。其在内核源码中的定义如下：
static int do_unlinkat(int dfd, struct filename *name) { ... } do_unlinkat 是内核中实际执行文件删除逻辑的最终汇聚点 用户空间调用 unlink()、unlinkat() 或 rmdir() 等系统调用时，最终都会通过系统调用表路由到这个函数 采用文件描述符 (AT_FDCWD) 和路径名的组合方式，提供了灵活的路径解析能力 vmlinux.h 不同内核版本之间，内核数据结构如结构体字段位置、字段名称等都可能发生变化。传统的 eBPF 程序直接使用内核头文件会导致：
兼容性问题：程序在​​不同内核版本​​中崩溃 字段偏移错误：读取到​​无效内存数据​​ 维护困难：需要针对​​每个内核版本​​进行适配 vmlinux.h 利用内核的​​BTF（BPF Type Format）​​ 信息生成与当前运行内核完全匹配的类型定义：
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h 内核态程序 kprobe_unlink.bpf.c 为 do_unlinkat 函数同时设置入口探针和返回探针：
​​函数入口​​： 捕获调用进程的 PID 获取要删除的文件名 ​​函数返回​​： 捕获调用进程的 PID 获取函数返回值（删除操作的结果） //go:build ignore #include "vmlinux.h" // 下面几个头文件需要安装了libbpf库 #include &lt;bpf/bpf_core_read.h> #include &lt;bpf/bpf_helpers.h> #include &lt;bpf/bpf_tracing.h> char LICENSE[] SEC("license") = "Dual BSD/GPL"; SEC("kprobe/do_unlinkat") int BPF_KPROBE(do_unlinkat, int dfd, struct filename* name) { pid_t pid; const char* filename; pid = bpf_get_current_pid_tgid() >> 32; filename = BPF_CORE_READ(name, name); bpf_printk("KPROBE ENTRY pid = %d, filename = %s\n", pid, filename); return 0; } SEC("kretprobe/do_unlinkat") int BPF_KRETPROBE(do_unlinkat_exit, long ret) { pid_t pid; pid = bpf_get_current_pid_tgid() >> 32; bpf_printk("KPROBE EXIT: pid = %d, ret = %ld\n", pid, ret); return 0; } 用户态 Go 程序 用户态程序负责三个主要任务：
...</p></div><footer class=entry-footer><span title='2025-06-10 00:00:00 +0000 UTC'>2025-06-10</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;403 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 【eBPF学习】使用kprobe监测捕获unlink系统调用" href=https://kerolt.github.io/posts/ebpf/ebpf%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8kprobe%E7%9B%91%E6%B5%8B%E6%8D%95%E8%8E%B7unlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式缓存</h2></header><div class=entry-content><p>项目地址：https://github.com/kerolt/kcache
KCache 是一个分布式缓存系统，支持一致性哈希和 LRU 缓存淘汰策略。该项目使用 conan 作为包管理工具，使用 CMake 作为项目的构建工具。
数据流程 当有客户端请求 kcache node 中的数据时：
kcache node 首先检查本地缓存 如果本地缓存未命中，使用 PeerPicker 选择负责该键的节点 如果键属于远程节点，通过 gRPC 向远程节点请求数据 如果远程节点也没有数据，回退到原始数据源加载（例如数据源是 MySQL、SQLite 等数据库） 将加载的数据添加到本地缓存 示意架构图如下：
致谢 本项目参考了 geektutu/7days-golang 项目，感谢其作者提供的 教程 和代码示例。 项目第二版参考了 【代码随想录知识星球】项目分享-缓存系统（Go） 项目结构 . |-- .vscode | `-- launch.json |-- example | |-- CMakeLists.txt | `-- example.cpp |-- src | |-- cache | | `-- lru.cpp | |-- consistent_hash | | `-- consistent_hash.cpp | |-- group | | `-- group.cpp | |-- include | | `-- kcache | | |-- cache.h | | |-- consistent_hash.h | | |-- group.h | | |-- grpc_server.h | | |-- peer.h | | |-- registry.h | | `-- singleflight.h | |-- peer | | |-- peer.cpp | | `-- peer_picker.cpp | |-- proto | | |-- kcache.grpc.pb.cc | | |-- kcache.grpc.pb.h | | |-- kcache.pb.cc | | |-- kcache.pb.h | | `-- kcache.proto | |-- registry | | `-- registry.cpp | |-- server | | `-- grpc_server.cpp | `-- CMakeLists.txt |-- test | |-- CMakeLists.txt | |-- test_consistent_hash.cpp | |-- test_group.cpp | `-- test_lru.cpp |-- .clang-format |-- .gitignore |-- CMakeLists.txt |-- CMakePresets.json |-- conanfile.txt |-- LICENSE `-- README.md 依赖 项目依赖如下：
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0000 UTC'>2025-05-25</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;369 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to 分布式缓存" href=https://kerolt.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git使用</h2></header><div class=entry-content><p>如何修改上次的 commit 比如有的时候 commit 漏掉了文件、commit 信息写错了，可以这么做：
你要指定一个有效的编辑器作为 Git 的默认编辑器，可以使 Vim 或者 VSCode：
git config --global core.editor "vim" # 使用 VSCode 的话就用 code 然后将上次忘记提交的修改先 git add （如果有的话），接着：
git commit --amend --amend 会用新的内容替换上一次提交，而不是创建一个新的提交。如果上一次提交已经被推送到远程仓库，使用 --amend 后需要强制推送：
git push --force 这个方法我有时候用来同步一下两台电脑上的代码，因为有时候一台电脑上写了一部分代码但是还没有到一次提交的地步，这时如果要外出或者要用另一台电脑了，就可以用这个方法来同步一下。
不过，使用 git push --force 强制推送后，远程仓库的历史记录会被改写。这种操作可能会导致本地和远程分支的提交历史不一致。我自己通常这么解决：
git fetch origin git reset --hard origin/&lt;branch> 这一般是不需要保留本地未推送的更改，可以直接将本地分支强制更新为远程分支的状态。
git 如何移除 submodule git submodule deinit -f path/to/submodule git rm -f path/to/submodule rm -rf path/to/submodule # 如果要删除物理目录 git commit -m "Removed submodule path/to/submodule" rm -rf .git/modules/path/to/submodule # 可选清理</p></div><footer class=entry-footer><span title='2025-05-18 00:00:00 +0000 UTC'>2025-05-18</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;78 words&nbsp;·&nbsp;Kerolt</footer><a class=entry-link aria-label="post link to Git使用" href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/git%E4%BD%BF%E7%94%A8/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://kerolt.github.io/posts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://kerolt.github.io/posts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>