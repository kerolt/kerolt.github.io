<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【MIT6.S081】Lab10 mmap | Kerolt's Blog</title>
<meta name=keywords content="xv6,MIT6-S081,OS"><meta name=description content="什么是mmap？
mmap 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 mmap，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/><meta name=google-site-verification content="NpIO0KEIJS0CPRzTzQCbYQdSRIyb0Lspx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="2300A23B82DB579A2DEA6261191AD771"><link crossorigin=anonymous href=/assets/css/stylesheet.035011695ba11fe36df35b8148f02b5baa41b9707b8d79a5a7d00fb4e65cc340.css integrity="sha256-A1ARaVuhH+Nt81uBSPArW6pBuXB7jXmlp9APtOZcw0A=" rel="preload stylesheet" as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【MIT6.S081】Lab10 mmap"><meta property="og:description" content="什么是mmap？ mmap 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 mmap，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-22T00:00:00+00:00"><meta property="article:tag" content="Xv6"><meta property="article:tag" content="MIT6-S081"><meta property="article:tag" content="OS"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【MIT6.S081】Lab10 mmap"><meta name=twitter:description content="什么是mmap？
mmap 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 mmap，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【MIT6.S081】Lab10 mmap","item":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【MIT6.S081】Lab10 mmap","name":"【MIT6.S081】Lab10 mmap","description":"什么是mmap？ mmap 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 mmap，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。\n","keywords":["xv6","MIT6-S081","OS"],"articleBody":"什么是mmap？ mmap 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 mmap，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。\n在Linux中，虚拟内存的布局如下：\n图片来源：小林coding\n当我们在Linux上使用mmap系统调用时，得到的文件映射就会放在图中的“文件映射与匿名映射区”。每当我们需要读取或修改文件时，只需要去操作这一块虚拟内存即可，而省去了将文件的内容从磁盘读取到内核缓冲区，然后再拷贝到用户空间的缓冲区，这大大减小了资源开销。\n系统调用参数说明 该lab希望我们实现xv6上的mmap和munmap系统调用，其函数声明为：\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t len); 这与Linux上的使用是相同的，对其中的参数解释如下：\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);：\naddr (void *): 这是建议的映射起始地址。通常设置为 NULL，由内核自动选择合适的地址。如果指定了非空地址，则内核尽量在这个地址处创建映射（但不保证）。（xv6中不要求实现，addr只要考虑为0/NULL的情况） 如果使用了 MAP_FIXED 标志，则必须将映射建立在 addr 所指向的地址，否则映射会失败。（xv6中不要求实现） len (size_t): 要映射的内存长度（以字节为单位）。如果不是页大小的倍数，通常会向上舍入到最近的页边界。 prot (int): 映射区域的保护权限。可以是以下权限的组合： PROT_READ: 映射区域可读。 PROT_WRITE: 映射区域可写。 PROT_EXEC: 映射区域可执行。 PROT_NONE: 映射区域不可访问。 flags (int): 控制映射对象的类型、映射页是否可共享、映射是否同步到磁盘等。常见的标志有： MAP_SHARED: 共享映射，对映射区域的修改会同步到底层文件，其他映射到同一文件的进程也会看到修改。 MAP_PRIVATE: 私有映射，对映射区域的修改不会影响底层文件，修改是写时复制的（Copy-On-Write）。 MAP_ANONYMOUS: 创建一个匿名映射，与文件无关。fd 参数被忽略，通常与 MAP_PRIVATE 结合使用。（xv6不要求实现） fd (int): 打开的文件描述符，表示要映射的文件。如果使用 MAP_ANONYMOUS 标志，则此参数被忽略，通常设为 -1。 offset (off_t): 文件映射的起始偏移量。必须是页大小的整数倍。（xv6中不要求实现，即只要输入0） int munmap(void *addr, size_t len)：\naddr (void *): 要解除映射的起始地址。这个地址必须是由之前的 mmap 调用返回的地址，或者是由 mmap 创建的某个映射区域的地址。 len (size_t): 要解除映射的内存长度，必须与 mmap 调用中的 len 相匹配。如果长度小于 mmap 时指定的长度，可能会导致部分映射区域仍然保留。 如何实现？ 在xv6的虚拟内存布局中，可以看到堆区和trapframe之间有一片没有使用的区域，我们可以拿它作为文件映射区域。（xv6和Linux的虚拟内存布局有点区别，xv6的堆区在栈区上面）\n当使用mmap系统调用时，也可以使用懒分配的策略（类似于Copy On Write）：我们在mmap系统调用中 标识（不是分配） 文件映射区中有一个区域与文件相关联，但这时还不会分配物理块，自然还不急着将文件读入这片内存区域；当我们需要访问这片区域的内存时，可以通过触发page fault来分配物理块，然后读入文件内容到内存块中，并将虚拟内存映射到这块物理内存上。\n使用munmap系统调用时，会解除文件在映射区[addr, addr + len]范围内的映射，将这块区域的内存写回文件，并释放掉这块内存。实验中保证释放的区域大小一定是页的整数倍。\n我们也仿照Linux上的，让文件映射区从高地址处开始向低地址增长。下图是文件映射的样子，左边为映射区域大小不固定，右边为映射大小为页框的整数倍：\n在实验的提示中，有说到mmaptest中没有使用的功能可以不实现，其中每次使用mmap都是映射的PGSIZE的整数倍，那也就说明我们可以之用考虑右边的情况，这让实验降低了一点复杂度。\n标识映射区域 根据实验提示，我们需要为每个进程设置用于标识映射区域的结构体：\n// proc.h #define NVMA 16 struct vma { uint len; // 映射区域大小 uint prot; // 映射区域的保护权限 struct file *file; // 需要映射的文件 int used; // 是否被使用 int flags; // 映射类型 int offset; // 偏移量 uint64 start; // 映射区域开始的地址 uint64 end; // 映射区域结束的地址 }; struct proc { ... struct vma vmas[NVMA]; // Virtual memory area }; 实现sys_mmap 在此之前，我们需要先注册mmap和munmap系统调用，这里我们就不赘述了\n获得映射区中的可用区域 什么意思呢？我们的映射区设计的是从高地址向低地址增长，那么我们每次需要增长时，最简单的就是在已有的映射区中找到地址最低的，并将新的映射区放在其之后，即地址最低的映射区的start就是新的映射区的end：\n可是这样的算法有很大的问题：如果我们取消了文件2的映射后，有一个只需要一个页框的映射区，按照这个算法它会被安排到文件3的映射区下面，这样就浪费了之前释放的映射区。\n不过嘛，在这个实验中这么做没什么问题😜，如果想知道更好的方法，可以参考这篇博客。\n我的实现如下：\n// sysfile.c // 获取一个可使用的vma的end地址 static uint64 vma_end() { struct proc *p = myproc(); struct vma *v = 0; uint64 min_vma_end = TRAPFRAME; for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used \u0026\u0026 p-\u003evmas[i].end \u003c= min_vma_end) { min_vma_end = p-\u003evmas[i].end; v = \u0026p-\u003evmas[i]; } } // 如果进程中还没有文件映射，就从trapframe后开始设置映射区 if (!v) { return min_vma_end; } // 这里可以直接返回v-\u003estart，这样做可以处理映射区域大小不固定的情况（应该吧） return PGROUNDDOWN(v-\u003estart); } sys_mmap 虽然刚刚我们有了可以获取映射区地址的函数，但是这个系统调用并不用真正分配内存，它只需要进行标记vma即可。\n找到一个可以使用的vma区域的end地址 初始化vma 返回vma的start地址 这里我觉得最重要的就是设置start和end地址，一个映射区的范围为[start, end)，其长度就为len，通过vma_end函数我们可以获取新映射区的end地址，再通过end - len即可得到start地址。\n// sysfile.c uint64 sys_mmap(void) { // void *mmap(void *addr, int len, int prot, int flags, int fd, int offset); uint64 addr; int len, prot, flags, fd, offset; struct proc *p = myproc(); struct file *f; argaddr(0, \u0026addr); argint(1, \u0026len); argint(2, \u0026prot); argint(3, \u0026flags); argfd(4, \u0026fd, \u0026f); argint(5, \u0026offset); if (addr \u003c 0 || len \u003c 0 || prot \u003c 0 || flags \u003c 0 || fd \u003c 0 || offset \u003c 0) { return -1; } if (!f-\u003ereadable \u0026\u0026 (prot \u0026 PROT_READ) \u0026\u0026 (flags \u0026 MAP_SHARED)) { return -1; } if (!f-\u003ewritable \u0026\u0026 (prot \u0026 PROT_WRITE) \u0026\u0026 (flags \u0026 MAP_SHARED)) { return -1; } // 找到一个可用的vma struct vma *v = 0; for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used == 0) { v = \u0026p-\u003evmas[i]; break; } } if (!v) { return -1; } // 初始化vma uint64 end = vma_end(); v-\u003elen = len; v-\u003eprot = prot; v-\u003efile = f; v-\u003eused = 1; v-\u003eflags = flags; v-\u003eoffset = offset; v-\u003eend = end; v-\u003estart = end - len; // 有文件映射时，对应的文件的引用计数也+1 filedup(f); return v-\u003estart; } 懒分配策略 找到触发fault的地址，并据此找到对应的vma 校验 分配物理内存块 设置权限 读取文件内容到内存块中，注意偏移量 设置物理内存与虚拟内存的映射 // trap.c // 处理mmap的懒分配策略 static int handle_mmap_fault(uint64 addr) { struct proc *p = myproc(); struct vma *v = 0; // 根据触发fault的地址，并据此找到对应的vma for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used \u0026\u0026 addr \u003e= p-\u003evmas[i].start \u0026\u0026 addr \u003c p-\u003evmas[i].end) { v = \u0026p-\u003evmas[i]; break; } } if (!v) { printf(\"no no no\\n\"); return -1; } // 校验 if (!v-\u003efile-\u003ereadable \u0026\u0026 r_scause() == 13 \u0026\u0026 (v-\u003eflags \u0026 MAP_SHARED)) { return -1; } if (!v-\u003efile-\u003ewritable \u0026\u0026 r_scause() == 15 \u0026\u0026 (v-\u003eflags \u0026 MAP_SHARED)) { return -1; } // 设置内存块权限 uint perm = PTE_V | PTE_U; if (v-\u003eprot \u0026 PROT_READ) { perm |= PTE_R; } if (v-\u003eprot \u0026 PROT_WRITE) { perm |= PTE_W; } if (v-\u003eprot \u0026 PROT_EXEC) { perm |= PTE_X; } // 分配物理块 char *pa = kalloc(); if (!pa) { return -1; } memset(pa, 0, PGSIZE); // 读取文件内容到内存块 uint offset = addr - v-\u003estart; ilock(v-\u003efile-\u003eip); if (readi(v-\u003efile-\u003eip, 0, (uint64)pa, offset, PGSIZE) == 0) { iunlock(v-\u003efile-\u003eip); return -1; } iunlock(v-\u003efile-\u003eip); // 设置虚拟内存与物理内存的映射 mappages(p-\u003epagetable, PGROUNDDOWN(addr), PGSIZE, (uint64)pa, perm); return 0; } 然后在usertrap中处理读写造成的page fault：\n// trap.c void usertrap(void) { ... if(r_scause() == 8){ ... } else if((which_dev = devintr()) != 0){ // ok } else if (r_scause() == 13 || r_scause() == 15) { if (handle_mmap_fault(r_stval()) != 0) { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); setkilled(p); } } else { ... } .. } 实现sys_munmap sys_munmap sys_munmap需要将内存块中的内容写回文件，并释放这个内存块。这里我们将这个操作额外封装一层，即不将具体实现放在sys_munmap中，这是因为在进程销毁也需要使用这个操作。\n// sysfile.c uint64 sys_munmap(void) { // int munmap(void *addr, int len); uint64 addr; int len; argaddr(0, \u0026addr); argint(1, \u0026len); if (addr \u003c 0 || len \u003c 0) { return -1; } return munmap(addr, len); } 解除映射 遍历所有的vma，找到addr所在的vma，要求addr不能是vma区域的中间位置，可以是开头和结束位置。 使用mmap_writeback将这addr的内容写回对应的文件 更新vma的范围 如果vma的len小于等于0，说明该文件的映射已经结束，可以关闭文件了，同时这个vma也应该释放了 // vm.c // 解除区域 [addr, addr + len) 的文件映射 uint64 munmap(uint64 addr, int len) { struct proc *p = myproc(); struct vma *v = 0; for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used \u0026\u0026 addr \u003e= p-\u003evmas[i].start \u0026\u0026 addr \u003c p-\u003evmas[i].end) { v = \u0026p-\u003evmas[i]; break; } } if (!v) { return -1; } // 不在合法的位置 if (addr \u003e v-\u003estart \u0026\u0026 addr + len \u003c v-\u003eend) { return -1; } // 将映射区域写回文件 mmap_writeback(p-\u003epagetable, addr, len, v); // 修改映射区域大小 if (addr == v-\u003estart) { v-\u003estart += len; } else if (addr == v-\u003eend - len) { v-\u003eend = addr; } v-\u003elen -= len; // 映射区域大小为0 if (v-\u003elen \u003c= 0) { fileclose(v-\u003efile); v-\u003eused = 0; } return 0; } 将映射区内容写回文件 遍历这个vma中的所有页框，对于其中的每一个页帧，获取对应的pte，需要考虑到由于懒分配带来的影响。 如果这个页帧被修改过，并且这块vma的策略是可写，那么就将这个页写回文件，注意偏移量 释放这块页帧对应的物理内存 // 将映射区域写回文件，并释放映射区域的内存 static int mmap_writeback(pagetable_t pgtbl, uint64 src_va, int len, struct vma *vma) { pte_t *pte; uint64 addr; // 遍历区域的页框 for (addr = PGROUNDDOWN(src_va); addr \u003c PGROUNDDOWN(src_va + len); addr += PGSIZE) { // 获取页帧对应的pte if ((pte = walk(pgtbl, addr, 0)) == 0) { panic(\"mmap_writeback\"); } // 这是为了处理这样一种情况：使用了mmap系统调用却没有有访问映射的文件，由于懒分配的策略， // 在写回文件时vma虽然有效，但是对应的pte并没有设置PTE_V，映射区域也还没有真正的映射文件 if (!(*pte \u0026 PTE_V)) { continue; } // 映射区域被修改了，可以写回文件 if ((*pte \u0026 PTE_D) \u0026\u0026 (vma-\u003eflags \u0026 MAP_SHARED)) { begin_op(); ilock(vma-\u003efile-\u003eip); uint offset = addr - src_va; writei(vma-\u003efile-\u003eip, 1, addr, offset, PGSIZE); iunlock(vma-\u003efile-\u003eip); end_op(); } kfree((void *)PTE2PA(*pte)); *pte = 0; } return 0; } 我们使用到了pte中的一个标志位PTE_D，它是用来标识一个页框是否被修改了（即脏位），我们需要在riscv.h中定义它：\n// riscv.h #define PTE_D (1L \u003c\u003c 7) 在exit时需要清空映射区 当进程退出时，其映射区中的内容也需要释放，这也是为什么要将munmap独立出来的原因。\n// proc.c void exit(int status) { struct proc *p = myproc(); if(p == initproc) panic(\"init exiting\"); for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used) { if (munmap(p-\u003evmas[i].start, p-\u003evmas[i].len) != 0) { panic(\"exit: munmap\"); } } } ... } 在fork时需要“复制”映射区 我们这里所说的复制并不是将映射区的内存块在fork时都复制给子进程，可别忘了COW哦，我们只需要复制父进程中的vma数组，知道映射的哪些位置有什么样的文件映射，在真正访问时再按需加载即可。\n// proc.c int fork(void) { ... for (int i = 0; i \u003c NVMA; i++) { if (p-\u003evmas[i].used) { np-\u003evmas[i] = p-\u003evmas[i]; // 子进程也映射了和父进程相同的文件，那么这个文件的引用计数也要增加 filedup(p-\u003evmas[i].file); } } ... } Code Details 代码实现详情请见：Github\nReference https://xiaolincoding.com/os/3_memory/linux_mem.html#_3-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4 https://ttzytt.com/2022/08/xv6_lab11_record/index.html Summary 这个lab的代码还是比较多的，不过它还给我们放了些水，只让我们实现一些基础的功能。在lab中更重要的是要搞清楚mmap的实现原理，一定要去理解其中的细节。\n","wordCount":"1017","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-22T00:00:00Z","dateModified":"2024-11-22T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab10-mmap/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kerolt.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kerolt.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">【MIT6.S081】Lab10 mmap</h1><div class=post-meta><span title='2024-11-22 00:00:00 +0000 UTC'>2024-11-22</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1017 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags><li><a href=https://kerolt.github.io/tags/xv6/>Xv6</a></li><li><a href=https://kerolt.github.io/tags/mit6-s081/>MIT6-S081</a></li><li><a href=https://kerolt.github.io/tags/os/>OS</a></li></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afmmap aria-label=什么是mmap？>什么是mmap？</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e aria-label=系统调用参数说明>系统调用参数说明</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0 aria-label=如何实现？>如何实现？</a></li><li><a href=#%e6%a0%87%e8%af%86%e6%98%a0%e5%b0%84%e5%8c%ba%e5%9f%9f aria-label=标识映射区域>标识映射区域</a></li><li><a href=#%e5%ae%9e%e7%8e%b0sys_mmap aria-label=实现sys_mmap>实现sys_mmap</a><ul><li><a href=#%e8%8e%b7%e5%be%97%e6%98%a0%e5%b0%84%e5%8c%ba%e4%b8%ad%e7%9a%84%e5%8f%af%e7%94%a8%e5%8c%ba%e5%9f%9f aria-label=获得映射区中的可用区域>获得映射区中的可用区域</a></li><li><a href=#sys_mmap aria-label=sys_mmap>sys_mmap</a></li></ul></li><li><a href=#%e6%87%92%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5 aria-label=懒分配策略>懒分配策略</a></li><li><a href=#%e5%ae%9e%e7%8e%b0sys_munmap aria-label=实现sys_munmap>实现sys_munmap</a><ul><li><a href=#sys_munmap aria-label=sys_munmap>sys_munmap</a></li><li><a href=#%e8%a7%a3%e9%99%a4%e6%98%a0%e5%b0%84 aria-label=解除映射>解除映射</a></li><li><a href=#%e5%b0%86%e6%98%a0%e5%b0%84%e5%8c%ba%e5%86%85%e5%ae%b9%e5%86%99%e5%9b%9e%e6%96%87%e4%bb%b6 aria-label=将映射区内容写回文件>将映射区内容写回文件</a></li></ul></li><li><a href=#%e5%9c%a8exit%e6%97%b6%e9%9c%80%e8%a6%81%e6%b8%85%e7%a9%ba%e6%98%a0%e5%b0%84%e5%8c%ba aria-label=在exit时需要清空映射区>在exit时需要清空映射区</a></li><li><a href=#%e5%9c%a8fork%e6%97%b6%e9%9c%80%e8%a6%81%e5%a4%8d%e5%88%b6%e6%98%a0%e5%b0%84%e5%8c%ba aria-label=在fork时需要“复制”映射区>在fork时需要“复制”映射区</a></li><li><a href=#code-details aria-label="Code Details">Code Details</a></li><li><a href=#reference aria-label=Reference>Reference</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=什么是mmap>什么是mmap？<a hidden class=anchor aria-hidden=true href=#什么是mmap>#</a></h2><p><code>mmap</code> 是一种用于将文件或设备与进程的地址空间关联起来的内存映射技术。通过 <code>mmap</code>，可以将文件的内容直接映射到进程的虚拟内存地址空间，使得文件的内容可以像操作普通内存一样进行读取和写入。</p><p>在Linux中，虚拟内存的布局如下：</p><p><div class=post-img-view><a data-fancybox=gallery href=https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png><img src=https://cdn.xiaolincoding.com//mysql/other/532e6cdf4899588f8b873b6435cba2d8.png alt></a></div></p><blockquote><p>图片来源：<a href=https://xiaolincoding.com/os/3_memory/linux_mem.html#_3-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4>小林coding</a></p></blockquote><p>当我们在Linux上使用mmap系统调用时，得到的文件映射就会放在图中的“文件映射与匿名映射区”。每当我们需要读取或修改文件时，只需要去操作这一块虚拟内存即可，而省去了将文件的内容从磁盘读取到内核缓冲区，然后再拷贝到用户空间的缓冲区，这大大减小了资源开销。</p><h2 id=系统调用参数说明>系统调用参数说明<a hidden class=anchor aria-hidden=true href=#系统调用参数说明>#</a></h2><p>该lab希望我们实现xv6上的<code>mmap</code>和<code>munmap</code>系统调用，其函数声明为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mmap</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>prot</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>munmap</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>);</span>
</span></span></code></pre></div><p>这与Linux上的使用是相同的，对其中的参数解释如下：</p><blockquote><p><code>void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);</code>：</p></blockquote><ol><li><strong><code>addr</code> (void *)</strong>:<ul><li>这是建议的映射起始地址。通常设置为 <code>NULL</code>，由内核自动选择合适的地址。如果指定了非空地址，则内核尽量在这个地址处创建映射（但不保证）。（xv6中不要求实现，addr只要考虑为0/NULL的情况）</li><li>如果使用了 <code>MAP_FIXED</code> 标志，则必须将映射建立在 <code>addr</code> 所指向的地址，否则映射会失败。（xv6中不要求实现）</li></ul></li><li><strong><code>len</code> (size_t)</strong>:<ul><li>要映射的内存长度（以字节为单位）。如果不是页大小的倍数，通常会向上舍入到最近的页边界。</li></ul></li><li><strong><code>prot</code> (int)</strong>:<ul><li>映射区域的保护权限。可以是以下权限的组合：<ul><li><code>PROT_READ</code>: 映射区域可读。</li><li><code>PROT_WRITE</code>: 映射区域可写。</li><li><code>PROT_EXEC</code>: 映射区域可执行。</li><li><code>PROT_NONE</code>: 映射区域不可访问。</li></ul></li></ul></li><li><strong><code>flags</code> (int)</strong>:<ul><li>控制映射对象的类型、映射页是否可共享、映射是否同步到磁盘等。常见的标志有：<ul><li><code>MAP_SHARED</code>: 共享映射，对映射区域的修改会同步到底层文件，其他映射到同一文件的进程也会看到修改。</li><li><code>MAP_PRIVATE</code>: 私有映射，对映射区域的修改不会影响底层文件，修改是写时复制的（Copy-On-Write）。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射，与文件无关。<code>fd</code> 参数被忽略，通常与 <code>MAP_PRIVATE</code> 结合使用。（xv6不要求实现）</li></ul></li></ul></li><li><strong><code>fd</code> (int)</strong>:<ul><li>打开的文件描述符，表示要映射的文件。如果使用 <code>MAP_ANONYMOUS</code> 标志，则此参数被忽略，通常设为 <code>-1</code>。</li></ul></li><li><strong><code>offset</code> (off_t)</strong>:<ul><li>文件映射的起始偏移量。必须是页大小的整数倍。（xv6中不要求实现，即只要输入0）</li></ul></li></ol><blockquote><p><code>int munmap(void *addr, size_t len)</code>：</p></blockquote><ol><li><strong><code>addr</code> (void *)</strong>:<ul><li>要解除映射的起始地址。这个地址必须是由之前的 <code>mmap</code> 调用返回的地址，或者是由 <code>mmap</code> 创建的某个映射区域的地址。</li></ul></li><li><strong><code>len</code> (size_t)</strong>:<ul><li>要解除映射的内存长度，必须与 <code>mmap</code> 调用中的 <code>len</code> 相匹配。如果长度小于 <code>mmap</code> 时指定的长度，可能会导致部分映射区域仍然保留。</li></ul></li></ol><h2 id=如何实现>如何实现？<a hidden class=anchor aria-hidden=true href=#如何实现>#</a></h2><p>在xv6的虚拟内存布局中，可以看到堆区和trapframe之间有一片没有使用的区域，我们可以拿它作为文件映射区域。（xv6和Linux的虚拟内存布局有点区别，xv6的堆区在栈区上面）</p><p><div class=post-img-view><a data-fancybox=gallery href=https://gitee.com/kerolt/picture/raw/main/20241215-134845.png><img src=https://gitee.com/kerolt/picture/raw/main/20241215-134845.png alt></a></div></p><p>当使用<code>mmap</code>系统调用时，也可以使用懒分配的策略（类似于Copy On Write）：我们在mmap系统调用中 <strong>标识（不是分配）</strong> 文件映射区中有一个区域与文件相关联，但这时还不会分配物理块，自然还不急着将文件读入这片内存区域；当我们需要访问这片区域的内存时，可以通过触发page fault来分配物理块，然后读入文件内容到内存块中，并将虚拟内存映射到这块物理内存上。</p><p>使用<code>munmap</code>系统调用时，会解除文件在映射区<code>[addr, addr + len]</code>范围内的映射，将这块区域的内存写回文件，并释放掉这块内存。实验中保证释放的区域大小一定是页的整数倍。</p><p>我们也仿照Linux上的，让文件映射区从高地址处开始向低地址增长。下图是文件映射的样子，左边为映射区域大小不固定，右边为映射大小为页框的整数倍：</p><p><div class=post-img-view><a data-fancybox=gallery href=https://gitee.com/kerolt/picture/raw/main/20241215-134845-1.png><img src=https://gitee.com/kerolt/picture/raw/main/20241215-134845-1.png alt></a></div></p><p>在实验的提示中，有说到<code>mmaptest</code>中没有使用的功能可以不实现，其中每次使用<code>mmap</code>都是映射的<code>PGSIZE</code>的整数倍，那也就说明我们可以之用考虑右边的情况，这让实验降低了一点复杂度。</p><h2 id=标识映射区域>标识映射区域<a hidden class=anchor aria-hidden=true href=#标识映射区域>#</a></h2><p>根据实验提示，我们需要为每个进程设置用于标识映射区域的结构体：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// proc.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define NVMA 16
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>vma</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>len</span><span class=p>;</span> <span class=c1>// 映射区域大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint</span> <span class=n>prot</span><span class=p>;</span> <span class=c1>// 映射区域的保护权限
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>;</span> <span class=c1>// 需要映射的文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>used</span><span class=p>;</span> <span class=c1>// 是否被使用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// 映射类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>offset</span><span class=p>;</span> <span class=c1>// 偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>start</span><span class=p>;</span> <span class=c1>// 映射区域开始的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>end</span><span class=p>;</span> <span class=c1>// 映射区域结束的地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>vma</span> <span class=n>vmas</span><span class=p>[</span><span class=n>NVMA</span><span class=p>];</span>       <span class=c1>// Virtual memory area
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h2 id=实现sys_mmap>实现sys_mmap<a hidden class=anchor aria-hidden=true href=#实现sys_mmap>#</a></h2><blockquote><p>在此之前，我们需要先注册mmap和munmap系统调用，这里我们就不赘述了</p></blockquote><h3 id=获得映射区中的可用区域>获得映射区中的可用区域<a hidden class=anchor aria-hidden=true href=#获得映射区中的可用区域>#</a></h3><p>什么意思呢？我们的映射区设计的是从高地址向低地址增长，那么我们每次需要增长时，最简单的就是在已有的映射区中找到地址最低的，并将新的映射区放在其之后，<strong>即地址最低的映射区的start就是新的映射区的end</strong>：</p><p><div class=post-img-view><a data-fancybox=gallery href=https://gitee.com/kerolt/picture/raw/main/20241215-134845-2.png><img src=https://gitee.com/kerolt/picture/raw/main/20241215-134845-2.png alt></a></div></p><p>可是这样的算法有很大的问题：如果我们取消了文件2的映射后，有一个只需要一个页框的映射区，按照这个算法它会被安排到文件3的映射区下面，这样就浪费了之前释放的映射区。</p><p>不过嘛，在这个实验中这么做没什么问题😜，如果想知道更好的方法，可以参考这篇<a href=https://ttzytt.com/2022/08/xv6_lab11_record/index.html>博客</a>。</p><p>我的实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// sysfile.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 获取一个可使用的vma的end地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>uint64</span> <span class=nf>vma_end</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>vma</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>min_vma_end</span> <span class=o>=</span> <span class=n>TRAPFRAME</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>end</span> <span class=o>&lt;=</span> <span class=n>min_vma_end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>min_vma_end</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果进程中还没有文件映射，就从trapframe后开始设置映射区
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_vma_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这里可以直接返回v-&gt;start，这样做可以处理映射区域大小不固定的情况（应该吧）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=sys_mmap>sys_mmap<a hidden class=anchor aria-hidden=true href=#sys_mmap>#</a></h3><p>虽然刚刚我们有了可以获取映射区地址的函数，但是这个系统调用并不用真正分配内存，它只需要进行标记vma即可。</p><ol><li>找到一个可以使用的vma区域的end地址</li><li>初始化vma</li><li>返回vma的start地址</li></ol><p>这里我觉得最重要的就是设置<code>start</code>和<code>end</code>地址，一个映射区的范围为<code>[start, end)</code>，其长度就为<code>len</code>，通过<code>vma_end</code>函数我们可以获取新映射区的end地址，再通过<code>end - len</code>即可得到start地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// sysfile.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_mmap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// void *mmap(void *addr, int len, int prot, int flags, int fd, int offset);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span><span class=p>,</span> <span class=n>prot</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argfd</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>prot</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>flags</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>offset</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>readable</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_READ</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>writable</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_WRITE</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 找到一个可用的vma
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>vma</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 初始化vma
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>end</span> <span class=o>=</span> <span class=nf>vma_end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>prot</span> <span class=o>=</span> <span class=n>prot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>used</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>=</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>end</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 有文件映射时，对应的文件的引用计数也+1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>filedup</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=懒分配策略>懒分配策略<a hidden class=anchor aria-hidden=true href=#懒分配策略>#</a></h2><ol><li>找到触发fault的地址，并据此找到对应的vma</li><li>校验</li><li>分配物理内存块</li><li>设置权限</li><li>读取文件内容到内存块中，注意偏移量</li><li>设置物理内存与虚拟内存的映射</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// trap.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 处理mmap的懒分配策略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>handle_mmap_fault</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>vma</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 根据触发fault的地址，并据此找到对应的vma
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>start</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;no no no</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 校验
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>readable</span> <span class=o>&amp;&amp;</span> <span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>13</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>writable</span> <span class=o>&amp;&amp;</span> <span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>15</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 设置内存块权限
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint</span> <span class=n>perm</span> <span class=o>=</span> <span class=n>PTE_V</span> <span class=o>|</span> <span class=n>PTE_U</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_READ</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perm</span> <span class=o>|=</span> <span class=n>PTE_R</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_WRITE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perm</span> <span class=o>|=</span> <span class=n>PTE_W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>prot</span> <span class=o>&amp;</span> <span class=n>PROT_EXEC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perm</span> <span class=o>|=</span> <span class=n>PTE_X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 分配物理块
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pa</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>pa</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 读取文件内容到内存块
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>-</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>ilock</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>readi</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>iunlock</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>iunlock</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 设置虚拟内存与物理内存的映射
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>mappages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>addr</span><span class=p>),</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>perm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在<code>usertrap</code>中处理读写造成的page fault：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// trap.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>usertrap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>8</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>((</span><span class=n>which_dev</span> <span class=o>=</span> <span class=nf>devintr</span><span class=p>())</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>13</span> <span class=o>||</span> <span class=nf>r_scause</span><span class=p>()</span> <span class=o>==</span> <span class=mi>15</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>handle_mmap_fault</span><span class=p>(</span><span class=nf>r_stval</span><span class=p>())</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;usertrap(): unexpected scause %p pid=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>r_scause</span><span class=p>(),</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;            sepc=%p stval=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>r_sepc</span><span class=p>(),</span> <span class=nf>r_stval</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=nf>setkilled</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>..</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=实现sys_munmap>实现sys_munmap<a hidden class=anchor aria-hidden=true href=#实现sys_munmap>#</a></h2><h3 id=sys_munmap>sys_munmap<a hidden class=anchor aria-hidden=true href=#sys_munmap>#</a></h3><p><code>sys_munmap</code>需要将内存块中的内容写回文件，并释放这个内存块。这里我们将这个操作额外封装一层，即不将具体实现放在<code>sys_munmap</code>中，这是因为在进程销毁也需要使用这个操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// sysfile.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_munmap</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// int munmap(void *addr, int len);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>munmap</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=解除映射>解除映射<a hidden class=anchor aria-hidden=true href=#解除映射>#</a></h3><ol><li>遍历所有的vma，找到addr所在的vma，要求addr不能是vma区域的中间位置，可以是开头和结束位置。</li><li>使用<code>mmap_writeback</code>将这addr的内容写回对应的文件</li><li>更新vma的范围</li><li>如果vma的len小于等于0，说明该文件的映射已经结束，可以关闭文件了，同时这个vma也应该释放了</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// vm.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 解除区域 [addr, addr + len) 的文件映射
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uint64</span> <span class=nf>munmap</span><span class=p>(</span><span class=n>uint64</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>vma</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>start</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>v</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 不在合法的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&gt;</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span> <span class=o>&amp;&amp;</span> <span class=n>addr</span> <span class=o>+</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 将映射区域写回文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>mmap_writeback</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 修改映射区域大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>==</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=o>-&gt;</span><span class=n>start</span> <span class=o>+=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>==</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>end</span> <span class=o>-</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=o>-&gt;</span><span class=n>end</span> <span class=o>=</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>-=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 映射区域大小为0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fileclose</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=o>-&gt;</span><span class=n>used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=将映射区内容写回文件>将映射区内容写回文件<a hidden class=anchor aria-hidden=true href=#将映射区内容写回文件>#</a></h3><ol><li>遍历这个vma中的所有页框，对于其中的每一个页帧，获取对应的pte，需要考虑到由于懒分配带来的影响。</li><li>如果这个页帧被修改过，并且这块vma的策略是可写，那么就将这个页写回文件，注意偏移量</li><li>释放这块页帧对应的物理内存</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 将映射区域写回文件，并释放映射区域的内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>mmap_writeback</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pgtbl</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>src_va</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>,</span> <span class=k>struct</span> <span class=n>vma</span> <span class=o>*</span><span class=n>vma</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 遍历区域的页框
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>addr</span> <span class=o>=</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>src_va</span><span class=p>);</span> <span class=n>addr</span> <span class=o>&lt;</span> <span class=nf>PGROUNDDOWN</span><span class=p>(</span><span class=n>src_va</span> <span class=o>+</span> <span class=n>len</span><span class=p>);</span> <span class=n>addr</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取页帧对应的pte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pgtbl</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;mmap_writeback&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这是为了处理这样一种情况：使用了mmap系统调用却没有有访问映射的文件，由于懒分配的策略，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 在写回文件时vma虽然有效，但是对应的pte并没有设置PTE_V，映射区域也还没有真正的映射文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 映射区域被修改了，可以写回文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_D</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>MAP_SHARED</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>begin_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=nf>ilock</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>uint</span> <span class=n>offset</span> <span class=o>=</span> <span class=n>addr</span> <span class=o>-</span> <span class=n>src_va</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>writei</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>iunlock</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>ip</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>end_op</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们使用到了pte中的一个标志位<code>PTE_D</code>，它是用来标识一个页框是否被修改了（即脏位），我们需要在<code>riscv.h</code>中定义它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// riscv.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define PTE_D (1L &lt;&lt; 7)
</span></span></span></code></pre></div><h2 id=在exit时需要清空映射区>在exit时需要清空映射区<a hidden class=anchor aria-hidden=true href=#在exit时需要清空映射区>#</a></h2><p>当进程退出时，其映射区中的内容也需要释放，这也是为什么要将<code>munmap</code>独立出来的原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// proc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>initproc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;init exiting&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>munmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>start</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>len</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;exit: munmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=在fork时需要复制映射区>在fork时需要“复制”映射区<a hidden class=anchor aria-hidden=true href=#在fork时需要复制映射区>#</a></h2><p>我们这里所说的复制并不是将映射区的内存块在fork时都复制给子进程，可别忘了COW哦，我们只需要复制父进程中的vma数组，知道映射的哪些位置有什么样的文件映射，在真正访问时再按需加载即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// proc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NVMA</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>used</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>np</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 子进程也映射了和父进程相同的文件，那么这个文件的引用计数也要增加
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nf>filedup</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>vmas</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=code-details>Code Details<a hidden class=anchor aria-hidden=true href=#code-details>#</a></h2><p>代码实现详情请见：<a href=https://github.com/kerolt/xv6-labs-2023/commit/b9d23e3590bba8a4fbd561cefe320b911e1286d1>Github</a></p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ol><li><a href=https://xiaolincoding.com/os/3_memory/linux_mem.html#_3-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4>https://xiaolincoding.com/os/3_memory/linux_mem.html#_3-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4</a></li><li><a href=https://ttzytt.com/2022/08/xv6_lab11_record/index.html>https://ttzytt.com/2022/08/xv6_lab11_record/index.html</a></li></ol><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>这个lab的代码还是比较多的，不过它还给我们放了些水，只让我们实现一些基础的功能。在lab中更重要的是要搞清楚mmap的实现原理，一定要去理解其中的细节。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%9C%A8vscode%E4%B8%AD%E9%85%8D%E7%BD%AElldb/><span class=title>« Prev</span><br><span>在VSCode中配置LLDB</span>
</a><a class=next href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab9-file-system/><span class=title>Next »</span><br><span>【MIT6.S081】Lab9 file system</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>