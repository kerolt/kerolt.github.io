<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【MIT6.S081】Lab8 lock | Kerolt's Blog</title>
<meta name=keywords content="OS,MIT6-S081,xv6"><meta name=description content="Intro
这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8a19d6c7d40c68078a482516c7c2a326ccb9f6e9282cabe7240ecc1a80c6cb47.css integrity="sha256-ihnWx9QMaAeKSCUWx8KjJsy59ukoLKvnJA7MGoDGy0c=" rel="preload stylesheet" as=style><link rel=icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【MIT6.S081】Lab8 lock"><meta property="og:description" content="Intro 这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-17T00:00:00+00:00"><meta property="article:tag" content="OS"><meta property="article:tag" content="MIT6-S081"><meta property="article:tag" content="Xv6"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【MIT6.S081】Lab8 lock"><meta name=twitter:description content="Intro
这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【MIT6.S081】Lab8 lock","item":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【MIT6.S081】Lab8 lock","name":"【MIT6.S081】Lab8 lock","description":"Intro 这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。\n","keywords":["OS","MIT6-S081","xv6"],"articleBody":"Intro 这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。\nMemory Allocator 在xv6中，内存通过kalloc()来分配，在其内部，会使用一个kmem的结构体变量：\n// kernel/kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; kmem.freelist保存着未使用的内存块（每块大小为4KB），在内核初始化时，会通过kinit()将地址KERNBASE ~ PHYSTOP的物理内存（一共128MB）放入freelist中：\nvoid kinit() { initlock(\u0026kmem.lock, \"kmem\"); freerange(end, (void*)PHYSTOP); // end为kernel.ld中定义的，值为0x80000000，即KERNBASE } void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE \u003c= (char*)pa_end; p += PGSIZE) kfree(p); // 使用kfree将内存块放入freelist中 } 通过上面的源码分析我们可以看到，整个xv6内核都是通过一个全局的kmem来分配和回收内存块，那么如果当多个CPU（多个core）需要操作内存块时，就必须得用锁才能保证整体的稳定和正确。\n但是这样做又会有一个大问题，那就是一个cpu在操作kmem时，另一个CPU即便想获取内存块或释放内存块，因为锁的缘故也只能等待。故我们的解决方案是为每个CPU都设置一个kmem，这样，哪个CPU需要操作内存块时就可以只锁上它自己的kmem，其他CPU受到的干扰会大大减少。\n为什么说是大大减少而不是完全减少呢？这是因为当某个CPU的kmem.freelist中没有可分配的内存块时，需要去其他CPU的kmem.freelist中去拿一个过来，这时就需要处理好这两个CPU的锁的处理了。\nstruct { struct spinlock lock; struct run *freelist; char lock_name[8]; // 每个kmem的锁的名称 } kmem[NCPU]; // 为每个CPU都设置一个kmem void kinit() { // 初始化时要对每个kmem都初始锁 for (int i = 0; i \u003c NCPU; i++) { initlock(\u0026kmem[i].lock, \"kmem\"); snprintf(kmem[i].lock_name, sizeof(kmem[i].lock_name), \"kmem%d\", i); } // 这里会先将所有内存块都分配给kmem[0]，因为内核启动时是cpus[0]在做初始化操作 // 之后其他CPU需要内存块时，从cpus[0]这里拿 freerange(end, (void*)PHYSTOP); } void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u003c end || (uint64)pa \u003e= PHYSTOP) panic(\"kfree\"); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; // ---------------------------------------- // kfree时只需要将内存块放到自己所属cpu的kmem.freelist中 push_off(); int cid = cpuid(); acquire(\u0026kmem[cid].lock); r-\u003enext = kmem[cid].freelist; kmem[cid].freelist = r; release(\u0026kmem[cid].lock); pop_off(); // ---------------------------------------- } void * kalloc(void) { struct run *r; // ---------------------------------------- push_off(); int cid = cpuid(); acquire(\u0026kmem[cid].lock); r = kmem[cid].freelist; if (r) { // 如果当前的freelist中还有内存块，则直接用 kmem[cid].freelist = r-\u003enext; } else { // 没有？那就拿！ // 遍历一下其他CPU的kmem，如果找到的freelist中还有内存块，就拿它的 for (int next_cid = 0; next_cid \u003c NCPU; next_cid++) { // 不找自己 if (next_cid == cid) continue; acquire(\u0026kmem[next_cid].lock); r = kmem[next_cid].freelist; if (r) { kmem[next_cid].freelist = r-\u003enext; release(\u0026kmem[next_cid].lock); break; } release(\u0026kmem[next_cid].lock); } } release(\u0026kmem[cid].lock); pop_off(); // ---------------------------------------- if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } Buffer Cache 先介绍下实验初始的bcache：\nstruct { struct spinlock lock; struct buf buf[NBUF]; // Linked list of all buffers, through prev/next. // Sorted by how recently the buffer was used. // head.next is most recent, head.prev is least. struct buf head; } bcache; struct spinlock lock：bcache的全局锁 struct buf buf[NBUF]：缓冲块池，即包含了所有的buffer cache struct buf head：一个LRU链表，用于操作缓冲块，使用head.next获取的是最近刚使用过的buffer，head.prev获取的是最近未使用时间最久的buffer（或者说是未被使用的buffer，即引用计数为0） 原来的bcache中的buf数组在binit时就给LRU链表初始化用了：\nvoid binit(void) { struct buf *b; initlock(\u0026bcache.lock, \"bcache\"); // Create linked list of buffers bcache.head.prev = \u0026bcache.head; bcache.head.next = \u0026bcache.head; for(b = bcache.buf; b \u003c bcache.buf+NBUF; b++){ b-\u003enext = bcache.head.next; b-\u003eprev = \u0026bcache.head; initsleeplock(\u0026b-\u003elock, \"buffer\"); bcache.head.next-\u003eprev = b; bcache.head.next = b; } } 而这样设计的buffer cache有一个问题，由于buffer cache只有一个全局锁，当在高并发的情况下，进程需要并发访问bcache时，无法达到多进程带来的优势，一个进程必须要先等前一个进程释放锁后才可以操作。\n考虑前一个实验中的kalloc，我们能否也使用那样的策略？\nReducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won’t work for the block cache.\n为什么这么说呢？是因为block cache并不像内存页那样具有通用性。block cache对应着真实的物理外存块，每一个CPU都可能使用同一个block cache，所以无法像kalloc中那样为每个CPU分配其对应的cache。\n既然我们无法分别为每个CPU分配，那么我们可以换一个角度，对所有的block块进行分组：我们可以创建一个哈希桶hash buckets（这里使用的容量为13），那么对每个block块的块号进行取余操作（mod 13）即可将它们映射到其中一个哈希桶中。这样一来，我们需要使用标号为blockno的块时，到其映射的哈希桶中去寻找即可，并且，在并发情况下，我们一般上锁的单位从整个bcache变为了其中的一个桶，锁的粒度大大减小了。\n那么我们修改一下bcache的数据结构：\n#define NBUCKET 13 #define BLOCK_HASH(blockno) (blockno % NBUCKET) struct { struct spinlock g_lock; // 全局锁，这里相较之前只是改了个名字 struct buf buf[NBUF]; struct spinlock bk_lock[NBUCKET]; // 每个hash bucket都对应有一把锁 struct buf bucket[NBUCKET]; // hash bucket int size; // 缓冲块池（buf[NBUF]）中已使用的块数 } bcache; 我们在重构的方案中，不再使用LRU链表，但还是使用了LRU算法的思想，只是用时间戳来代替LRU链表：\nstruct buf { int valid; // has data been read from disk? int disk; // does disk \"own\" buf? uint dev; uint blockno; struct sleeplock lock; uint refcnt; // struct buf *prev; // LRU cache list struct buf *next; uchar data[BSIZE]; uint timestamp; }; 这个时间戳通过一个全局变量ticks（trap.c）来获取：\nextern uint ticks; 那么在初始化bcache时，我们只需要初始化其中的锁和bcache.size即可：\nvoid binit(void) { struct buf *b; bcache.size = 0; initlock(\u0026bcache.g_lock, \"bcache\"); for (int i = 0; i \u003c NBUCKET; i++) { initlock(\u0026bcache.bk_lock[i], \"bk_lock\"); } for(b = bcache.buf; b \u003c bcache.buf+NBUF; b++){ initsleeplock(\u0026b-\u003elock, \"buffer\"); } } 由于我们对于锁的操作单位变为了bucket，所以下面两个函数也需要修改：\nvoid bpin(struct buf *b) { int idx = BLOCK_HASH(b-\u003eblockno); acquire(\u0026bcache.bk_lock[idx]); b-\u003erefcnt++; release(\u0026bcache.bk_lock[idx]); } void bunpin(struct buf *b) { int idx = BLOCK_HASH(b-\u003eblockno); acquire(\u0026bcache.bk_lock[idx]); b-\u003erefcnt--; release(\u0026bcache.bk_lock[idx]); } 在原先的释放buffer块的brelse(struct buf *b)函数中，会先对b的引用计数-1，当其值为0时，将其转移至LRU链表的head-\u003eprev位置，说明这个buffer没有被任何进程使用了。而在重构方案中，我们使用时间戳代替了LRU链表，每个bucket中我们并没有维护一个LRU链表，而是认为引用计数为0且时间戳最小的的buffer是没有被任何进程使用的，故在引用计数为0时，只需要更新buffer的时间戳即可：\nvoid brelse(struct buf *b) { if(!holdingsleep(\u0026b-\u003elock)) panic(\"brelse\"); releasesleep(\u0026b-\u003elock); int idx = BLOCK_HASH(b-\u003eblockno); acquire(\u0026bcache.bk_lock[idx]); b-\u003erefcnt--; if (b-\u003erefcnt == 0) { // no one is waiting for it. b-\u003etimestamp = ticks; // 未使用的buffer的时间戳一定是最小的 } release(\u0026bcache.bk_lock[idx]); } 对于bcache最重要的bget()函数，我们重构的思路为：\n检查标号为blockno的块的缓存是否在cache中，如果在，则其引用计数+1，返回该缓存块 在缓存中没有找到，先在缓冲块池中寻找还未分配给bucket的缓存块 如果缓冲块池中都分配出去了，就到每个bucket中去找。如果当前遍历的bucket中有buffer的引用计数为0，拿到其中时间戳最小的buffer（这也就是说这个buffer是距离现在最久没有使用的合法块） 如果这个buffer在原先的bucket中，返回这个buffer 否则需要将这个buffer从当前bucket中转移到目标bucket中 这是一个大致的思路，具体细节参考如下代码：\nstatic struct buf* bget(uint dev, uint blockno) { struct buf *b; int bucket_idx = BLOCK_HASH(blockno); // 先对blockno对应的bucket上锁即可 acquire(\u0026bcache.bk_lock[bucket_idx]); // Is the block already cached? for(b = \u0026bcache.bucket[bucket_idx]; b; b = b-\u003enext){ if(b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno){ b-\u003erefcnt++; release(\u0026bcache.bk_lock[bucket_idx]); acquiresleep(\u0026b-\u003elock); return b; } } // 在缓存中没有找到，先在缓冲块池中寻找还未分配给bucket的缓存块 // 需要使用全局锁来保证bcache.size++的原子性 // 这里也是为什么buffer时间戳不需要初始化的原因：每一次需要使用buffer时（会调用bget）， // 如果buffer池中还有空闲buffer，则会直接使用这个buffer，完成操作后会调用relese释放buffer，此时就会更新buffer的时间戳 acquire(\u0026bcache.g_lock); if (bcache.size \u003c NBUF) { struct buf *b = \u0026bcache.buf[bcache.size++]; b-\u003enext = bcache.bucket[bucket_idx].next; bcache.bucket[bucket_idx].next = b; b-\u003edev = dev; b-\u003eblockno = blockno; b-\u003evalid = 0; b-\u003erefcnt = 1; release(\u0026bcache.g_lock); acquiresleep(\u0026b-\u003elock); return b; } release(\u0026bcache.g_lock); // 在这时才能释放该bucket的锁，假设在检查缓存是否存在后释放： // 如果有两个进程1和2，此时缓冲块池还有多个未分配的块，进程1检查bucket，发现没有缓存，释放锁，准备去缓冲块池中拿 // 此时切换到进程2，进程2检查bucket,发现没有缓存，也去缓冲块池中拿 // 这样就会导致bucket会添加两个blockno的缓冲块 release(\u0026bcache.bk_lock[bucket_idx]); // 在每个bucket中去找可用的buffer cache for (int i = 0; i \u003c NBUCKET; i++) { struct buf *cur_buf, *pre_buf, *min_buf, *min_pre_buf; uint min_timestamp = -1; acquire(\u0026bcache.bk_lock[bucket_idx]); pre_buf = \u0026bcache.bucket[bucket_idx]; cur_buf = pre_buf-\u003enext; // 遍历bcache.bucket[bucket_idx] while (cur_buf) { // 为什么这里需要重新检查？考虑这样一种情况： // 假设缓冲块池中还有一个未分配的，此时有两个进程，进程1和2都需要访问同一个标号blockno的块 // 进程1先拿到这个未分配的，并将其放入了对应的bucket中 // 之后进程2发现池中没有未分配的了，开始遍历所有bucket， // 如果这时不重新检查一下blockno对应的bucket，则会导致一个bucket中有两个blockno的块 if (bucket_idx == BLOCK_HASH(blockno) \u0026\u0026 cur_buf-\u003eblockno == blockno \u0026\u0026 cur_buf-\u003edev == dev) { cur_buf-\u003erefcnt++; release(\u0026bcache.bk_lock[bucket_idx]); acquiresleep(\u0026cur_buf-\u003elock); return cur_buf; } // 只有引用计数为0,并且时间戳最小的缓冲块才可被重新分配 if (cur_buf-\u003erefcnt == 0 \u0026\u0026 cur_buf-\u003etimestamp \u003c min_timestamp) { min_pre_buf = pre_buf; min_buf = cur_buf; min_timestamp = cur_buf-\u003etimestamp; } pre_buf = cur_buf; cur_buf = cur_buf-\u003enext; } // 在本轮中找到了可重新分配的缓冲块 if (min_buf) { min_buf-\u003edev = dev; min_buf-\u003eblockno = blockno; min_buf-\u003evalid = 0; min_buf-\u003erefcnt = 1; // 是自身bucket中的，不用做转移操作 if (bucket_idx == BLOCK_HASH(blockno)) { // release(\u0026bcache.hash_lock); release(\u0026bcache.bk_lock[bucket_idx]); acquiresleep(\u0026min_buf-\u003elock); return min_buf; } // 是其他bucket中的，需要转移 // 先将目标bucket中的buffer移除，然后释放锁 min_pre_buf-\u003enext = min_buf-\u003enext; release(\u0026bcache.bk_lock[bucket_idx]); // 接着获取blockno对应的锁，并将从目标bucket中移除的buffer放至blockno对应的bucket，返回该buffer bucket_idx = BLOCK_HASH(blockno); acquire(\u0026bcache.bk_lock[bucket_idx]); min_buf-\u003enext = bcache.bucket[bucket_idx].next; bcache.bucket[bucket_idx].next = min_buf; release(\u0026bcache.bk_lock[bucket_idx]); acquiresleep(\u0026min_buf-\u003elock); return min_buf; } release(\u0026bcache.bk_lock[bucket_idx]); // 如果到底了，从头来，保证遍历每一个bucket if (++bucket_idx == NBUCKET) { bucket_idx = 0; } } panic(\"bget: no buffers\"); } bget是这个lab中最复杂的地方，其处理逻辑虽然较好理解，但是多个锁的操作顺序很让人头疼，需要考虑到多种并发情况。\nCode Details 代码实现详情请见Github：https://github.com/kerolt/xv6-labs-2023/commit/ccac48e8ae6b6dde3e7c747a77f4149232420901\nReference https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab8-locks.md https://blog.csdn.net/LostUnravel/article/details/121430900 ","wordCount":"859","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-17T00:00:00Z","dateModified":"2024-11-17T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab8-lock/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)"><img src=https://kerolt.github.io/apple-touch-icon.png alt aria-label=logo height=35>Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【MIT6.S081】Lab8 lock</h1><div class=post-meta><span title='2024-11-17 00:00:00 +0000 UTC'>2024-11-17</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;859 words&nbsp;·&nbsp;Kerolt</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#memory-allocator aria-label="Memory Allocator">Memory Allocator</a></li><li><a href=#buffer-cache aria-label="Buffer Cache">Buffer Cache</a></li><li><a href=#code-details aria-label="Code Details">Code Details</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>这个实验个人感觉挺难的，需要我们重新设计数据结构，还要考虑在并发（并行）情况下对于锁的操作，以减少多核情况下对于锁的竞争。其中主要涉及内存分配和IO缓冲块分配，在这个lab之前，xv6对于这两个分配都是使用的全局对象，并只有一把全局锁进行操作，这样的话在并行情况下锁的竞争是很激烈的，我们的任务就是重新设计这两个分配器，它们的重构思路并不完全一致，需要具体问题具体分析。</p><h2 id=memory-allocator>Memory Allocator<a hidden class=anchor aria-hidden=true href=#memory-allocator>#</a></h2><p>在xv6中，内存通过<code>kalloc()</code>来分配，在其内部，会使用一个<code>kmem</code>的结构体变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/kalloc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>run</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>kmem</span><span class=p>;</span>
</span></span></code></pre></div><p><code>kmem.freelist</code>保存着未使用的内存块（每块大小为4KB），在内核初始化时，会通过<code>kinit()</code>将地址<code>KERNBASE ~ PHYSTOP</code>的物理内存（一共128MB）放入freelist中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>kinit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;kmem&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>freerange</span><span class=p>(</span><span class=n>end</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>PHYSTOP</span><span class=p>);</span> <span class=c1>// end为kernel.ld中定义的，值为0x80000000，即KERNBASE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freerange</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pa_start</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>pa_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>PGROUNDUP</span><span class=p>((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa_start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(;</span> <span class=n>p</span> <span class=o>+</span> <span class=n>PGSIZE</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>pa_end</span><span class=p>;</span> <span class=n>p</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>(</span><span class=n>p</span><span class=p>);</span> <span class=c1>// 使用kfree将内存块放入freelist中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>通过上面的源码分析我们可以看到，整个xv6内核都是通过一个全局的<code>kmem</code>来分配和回收内存块，那么如果当多个CPU（多个core）需要操作内存块时，就必须得用锁才能保证整体的稳定和正确。</p><p>但是这样做又会有一个大问题，那就是一个cpu在操作<code>kmem</code>时，另一个CPU即便想获取内存块或释放内存块，因为锁的缘故也只能等待。故我们的解决方案是为每个CPU都设置一个<code>kmem</code>，这样，哪个CPU需要操作内存块时就可以只锁上它自己的kmem，其他CPU受到的干扰会大大减少。</p><p>为什么说是大大减少而不是完全减少呢？这是因为当某个CPU的<code>kmem.freelist</code>中没有可分配的内存块时，需要去其他CPU的<code>kmem.freelist</code>中去拿一个过来，这时就需要处理好这两个CPU的锁的处理了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>lock_name</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=c1>// 每个kmem的锁的名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>kmem</span><span class=p>[</span><span class=n>NCPU</span><span class=p>];</span> <span class=c1>// 为每个CPU都设置一个kmem
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>kinit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 初始化时要对每个kmem都初始锁
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NCPU</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;kmem&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>snprintf</span><span class=p>(</span><span class=n>kmem</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock_name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>kmem</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lock_name</span><span class=p>),</span> <span class=s>&#34;kmem%d&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这里会先将所有内存块都分配给kmem[0]，因为内核启动时是cpus[0]在做初始化操作
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 之后其他CPU需要内存块时，从cpus[0]这里拿
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>freerange</span><span class=p>(</span><span class=n>end</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>PHYSTOP</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>kfree</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pa</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(((</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span> <span class=o>%</span> <span class=n>PGSIZE</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>||</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span> <span class=o>&gt;=</span> <span class=n>PHYSTOP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kfree&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Fill with junk to catch dangling refs.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>memset</span><span class=p>(</span><span class=n>pa</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>r</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>run</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ----------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// kfree时只需要将内存块放到自己所属cpu的kmem.freelist中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>push_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>cid</span> <span class=o>=</span> <span class=nf>cpuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>pop_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ----------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>kalloc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ----------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>push_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>cid</span> <span class=o>=</span> <span class=nf>cpuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果当前的freelist中还有内存块，则直接用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 没有？那就拿！
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 遍历一下其他CPU的kmem，如果找到的freelist中还有内存块，就拿它的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>next_cid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>next_cid</span> <span class=o>&lt;</span> <span class=n>NCPU</span><span class=p>;</span> <span class=n>next_cid</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 不找自己
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>next_cid</span> <span class=o>==</span> <span class=n>cid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>next_cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>r</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>[</span><span class=n>next_cid</span><span class=p>].</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>kmem</span><span class=p>[</span><span class=n>next_cid</span><span class=p>].</span><span class=n>freelist</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>next_cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>next_cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>[</span><span class=n>cid</span><span class=p>].</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>pop_off</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ----------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>r</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span> <span class=c1>// fill with junk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=buffer-cache>Buffer Cache<a hidden class=anchor aria-hidden=true href=#buffer-cache>#</a></h2><p>先介绍下实验初始的bcache：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=n>buf</span><span class=p>[</span><span class=n>NBUF</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Linked list of all buffers, through prev/next.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Sorted by how recently the buffer was used.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// head.next is most recent, head.prev is least.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>buf</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>bcache</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><code>struct spinlock lock</code>：bcache的全局锁</li><li><code>struct buf buf[NBUF]</code>：缓冲块池，即包含了所有的buffer cache</li><li><code>struct buf head</code>：一个LRU链表，用于操作缓冲块，使用head.next获取的是最近刚使用过的buffer，head.prev获取的是最近未使用时间最久的buffer（或者说是未被使用的buffer，即引用计数为0）</li></ul><p><img loading=lazy src=https://gitee.com/kerolt/picture/raw/main/20241215-134743.png></p><p>原来的bcache中的buf数组在binit时就给LRU链表初始化用了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>binit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;bcache&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Create linked list of buffers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>prev</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>b</span> <span class=o>=</span> <span class=n>bcache</span><span class=p>.</span><span class=n>buf</span><span class=p>;</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=n>bcache</span><span class=p>.</span><span class=n>buf</span><span class=o>+</span><span class=n>NBUF</span><span class=p>;</span> <span class=n>b</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>initsleeplock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;buffer&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bcache</span><span class=p>.</span><span class=n>head</span><span class=p>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而这样设计的buffer cache有一个问题，由于buffer cache只有一个全局锁，当在高并发的情况下，进程需要并发访问bcache时，无法达到多进程带来的优势，一个进程必须要先等前一个进程释放锁后才可以操作。</p><p>考虑前一个实验中的kalloc，我们能否也使用那样的策略？</p><blockquote><p>Reducing contention in the block cache is more tricky than for kalloc, because bcache buffers are truly shared among processes (and thus CPUs). For kalloc, one could eliminate most contention by giving each CPU its own allocator; that won&rsquo;t work for the block cache.</p></blockquote><p>为什么这么说呢？是因为block cache并不像内存页那样具有通用性。block cache对应着真实的物理外存块，每一个CPU都可能使用同一个block cache，所以无法像kalloc中那样为每个CPU分配其对应的cache。</p><p>既然我们无法分别为每个CPU分配，那么我们可以换一个角度，对所有的block块进行分组：我们可以创建一个哈希桶hash buckets（这里使用的容量为13），那么对每个block块的块号进行取余操作（mod 13）即可将它们映射到其中一个哈希桶中。这样一来，我们需要使用标号为blockno的块时，到其映射的哈希桶中去寻找即可，并且，在并发情况下，我们一般上锁的单位从整个bcache变为了其中的一个桶，锁的粒度大大减小了。</p><p>那么我们修改一下bcache的数据结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define NBUCKET 13
</span></span></span><span class=line><span class=cl><span class=cp>#define BLOCK_HASH(blockno) (blockno % NBUCKET)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>g_lock</span><span class=p>;</span> <span class=c1>// 全局锁，这里相较之前只是改了个名字
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>buf</span> <span class=n>buf</span><span class=p>[</span><span class=n>NBUF</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>bk_lock</span><span class=p>[</span><span class=n>NBUCKET</span><span class=p>];</span> <span class=c1>// 每个hash bucket都对应有一把锁
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>buf</span> <span class=n>bucket</span><span class=p>[</span><span class=n>NBUCKET</span><span class=p>];</span>       <span class=c1>// hash bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// 缓冲块池（buf[NBUF]）中已使用的块数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>bcache</span><span class=p>;</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/kerolt/picture/raw/main/20241215-134743-1.png></p><p>我们在重构的方案中，不再使用LRU链表，但还是使用了LRU算法的思想，只是用时间戳来代替LRU链表：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>buf</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>valid</span><span class=p>;</span>   <span class=c1>// has data been read from disk?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>disk</span><span class=p>;</span>    <span class=c1>// does disk &#34;own&#34; buf?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint</span> <span class=n>dev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>blockno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sleeplock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>refcnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// struct buf *prev; // LRU cache list
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uchar</span> <span class=n>data</span><span class=p>[</span><span class=n>BSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这个时间戳通过一个全局变量<code>ticks</code>（trap.c）来获取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint</span> <span class=n>ticks</span><span class=p>;</span>
</span></span></code></pre></div><p>那么在初始化bcache时，我们只需要初始化其中的锁和bcache.size即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>binit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>bcache</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>g_lock</span><span class=p>,</span> <span class=s>&#34;bcache&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NBUCKET</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=s>&#34;bk_lock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>b</span> <span class=o>=</span> <span class=n>bcache</span><span class=p>.</span><span class=n>buf</span><span class=p>;</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=n>bcache</span><span class=p>.</span><span class=n>buf</span><span class=o>+</span><span class=n>NBUF</span><span class=p>;</span> <span class=n>b</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>initsleeplock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;buffer&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于我们对于锁的操作单位变为了bucket，所以下面两个函数也需要修改：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>bpin</span><span class=p>(</span><span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>bunpin</span><span class=p>(</span><span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在原先的释放buffer块的<code>brelse(struct buf *b)</code>函数中，会先对<code>b</code>的引用计数-1，当其值为0时，将其转移至LRU链表的<code>head->prev</code>位置，说明这个buffer没有被任何进程使用了。而在重构方案中，我们使用时间戳代替了LRU链表，每个bucket中我们并没有维护一个LRU链表，而是认为引用计数为0且时间戳最小的的buffer是没有被任何进程使用的，故在引用计数为0时，只需要更新buffer的时间戳即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>brelse</span><span class=p>(</span><span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>holdingsleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;brelse&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>releasesleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// no one is waiting for it.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>timestamp</span> <span class=o>=</span> <span class=n>ticks</span><span class=p>;</span> <span class=c1>// 未使用的buffer的时间戳一定是最小的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于bcache最重要的<code>bget()</code>函数，我们重构的思路为：</p><ol><li>检查标号为blockno的块的缓存是否在cache中，如果在，则其引用计数+1，返回该缓存块</li><li>在缓存中没有找到，先在缓冲块池中寻找还未分配给bucket的缓存块</li><li>如果缓冲块池中都分配出去了，就到每个bucket中去找。如果当前遍历的bucket中有buffer的引用计数为0，拿到其中时间戳最小的buffer（这也就是说这个buffer是距离现在最久没有使用的合法块）<ul><li>如果这个buffer在原先的bucket中，返回这个buffer</li><li>否则需要将这个buffer从当前bucket中转移到目标bucket中</li></ul></li></ol><p>这是一个大致的思路，具体细节参考如下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>buf</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>bget</span><span class=p>(</span><span class=n>uint</span> <span class=n>dev</span><span class=p>,</span> <span class=n>uint</span> <span class=n>blockno</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>bucket_idx</span> <span class=o>=</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 先对blockno对应的bucket上锁即可
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Is the block already cached?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=n>b</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>];</span> <span class=n>b</span><span class=p>;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>==</span> <span class=n>dev</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>==</span> <span class=n>blockno</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 在缓存中没有找到，先在缓冲块池中寻找还未分配给bucket的缓存块
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 需要使用全局锁来保证bcache.size++的原子性
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这里也是为什么buffer时间戳不需要初始化的原因：每一次需要使用buffer时（会调用bget），
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果buffer池中还有空闲buffer，则会直接使用这个buffer，完成操作后会调用relese释放buffer，此时就会更新buffer的时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>g_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>bcache</span><span class=p>.</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>NBUF</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>buf</span><span class=p>[</span><span class=n>bcache</span><span class=p>.</span><span class=n>size</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>].</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>=</span> <span class=n>dev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>=</span> <span class=n>blockno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>valid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>g_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>g_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 在这时才能释放该bucket的锁，假设在检查缓存是否存在后释放：
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果有两个进程1和2，此时缓冲块池还有多个未分配的块，进程1检查bucket，发现没有缓存，释放锁，准备去缓冲块池中拿
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 此时切换到进程2，进程2检查bucket,发现没有缓存，也去缓冲块池中拿
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这样就会导致bucket会添加两个blockno的缓冲块
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 在每个bucket中去找可用的buffer cache
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NBUCKET</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>buf</span> <span class=o>*</span><span class=n>cur_buf</span><span class=p>,</span> <span class=o>*</span><span class=n>pre_buf</span><span class=p>,</span> <span class=o>*</span><span class=n>min_buf</span><span class=p>,</span> <span class=o>*</span><span class=n>min_pre_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint</span> <span class=n>min_timestamp</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>pre_buf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>cur_buf</span> <span class=o>=</span> <span class=n>pre_buf</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历bcache.bucket[bucket_idx]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>cur_buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 为什么这里需要重新检查？考虑这样一种情况：
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 假设缓冲块池中还有一个未分配的，此时有两个进程，进程1和2都需要访问同一个标号blockno的块
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 进程1先拿到这个未分配的，并将其放入了对应的bucket中
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 之后进程2发现池中没有未分配的了，开始遍历所有bucket，
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 如果这时不重新检查一下blockno对应的bucket，则会导致一个bucket中有两个blockno的块
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>bucket_idx</span> <span class=o>==</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>blockno</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>==</span> <span class=n>blockno</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>          <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>==</span> <span class=n>dev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>refcnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cur_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 只有引用计数为0,并且时间戳最小的缓冲块才可被重新分配
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>timestamp</span> <span class=o>&lt;</span> <span class=n>min_timestamp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>min_pre_buf</span> <span class=o>=</span> <span class=n>pre_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>min_buf</span> <span class=o>=</span> <span class=n>cur_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>min_timestamp</span> <span class=o>=</span> <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=n>pre_buf</span> <span class=o>=</span> <span class=n>cur_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>cur_buf</span> <span class=o>=</span> <span class=n>cur_buf</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 在本轮中找到了可重新分配的缓冲块
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>min_buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>dev</span> <span class=o>=</span> <span class=n>dev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>blockno</span> <span class=o>=</span> <span class=n>blockno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>valid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>refcnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 是自身bucket中的，不用做转移操作
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>bucket_idx</span> <span class=o>==</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>blockno</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// release(&amp;bcache.hash_lock);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>min_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 是其他bucket中的，需要转移
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 先将目标bucket中的buffer移除，然后释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>min_pre_buf</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// 接着获取blockno对应的锁，并将从目标bucket中移除的buffer放至blockno对应的bucket，返回该buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>bucket_idx</span> <span class=o>=</span> <span class=nf>BLOCK_HASH</span><span class=p>(</span><span class=n>blockno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>].</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>bcache</span><span class=p>.</span><span class=n>bucket</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>].</span><span class=n>next</span> <span class=o>=</span> <span class=n>min_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=nf>acquiresleep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>min_buf</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>min_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bcache</span><span class=p>.</span><span class=n>bk_lock</span><span class=p>[</span><span class=n>bucket_idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果到底了，从头来，保证遍历每一个bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>++</span><span class=n>bucket_idx</span> <span class=o>==</span> <span class=n>NBUCKET</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>bucket_idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;bget: no buffers&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>bget是这个lab中最复杂的地方，其处理逻辑虽然较好理解，但是多个锁的操作顺序很让人头疼，需要考虑到多种并发情况。</p><h2 id=code-details>Code Details<a hidden class=anchor aria-hidden=true href=#code-details>#</a></h2><p>代码实现详情请见Github：<a href=https://github.com/kerolt/xv6-labs-2023/commit/ccac48e8ae6b6dde3e7c747a77f4149232420901>https://github.com/kerolt/xv6-labs-2023/commit/ccac48e8ae6b6dde3e7c747a77f4149232420901</a></p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab8-locks.md>https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab8-locks.md</a></li><li><a href=https://blog.csdn.net/LostUnravel/article/details/121430900>https://blog.csdn.net/LostUnravel/article/details/121430900</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kerolt.github.io/tags/os/>OS</a></li><li><a href=https://kerolt.github.io/tags/mit6-s081/>MIT6-S081</a></li><li><a href=https://kerolt.github.io/tags/xv6/>Xv6</a></li></ul><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab9-file-system/><span class=title>« Prev</span><br><span>【MIT6.S081】Lab9 file system</span>
</a><a class=next href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081xv6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%90/><span class=title>Next »</span><br><span>【MIT6.S081】xv6进程调度分析</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>