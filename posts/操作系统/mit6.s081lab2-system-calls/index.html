<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【MIT6.S081】Lab2 system calls | Kerolt's Blog</title>
<meta name=keywords content="OS,MIT6-S081"><meta name=description content="前言
这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。"><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8a19d6c7d40c68078a482516c7c2a326ccb9f6e9282cabe7240ecc1a80c6cb47.css integrity="sha256-ihnWx9QMaAeKSCUWx8KjJsy59ukoLKvnJA7MGoDGy0c=" rel="preload stylesheet" as=style><link rel=icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【MIT6.S081】Lab2 system calls"><meta property="og:description" content="前言 这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-28T00:00:00+00:00"><meta property="article:tag" content="OS"><meta property="article:tag" content="MIT6-S081"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【MIT6.S081】Lab2 system calls"><meta name=twitter:description content="前言
这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【MIT6.S081】Lab2 system calls","item":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【MIT6.S081】Lab2 system calls","name":"【MIT6.S081】Lab2 system calls","description":"前言 这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。\n","keywords":["OS","MIT6-S081"],"articleBody":"前言 这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。\ntrace 首先，我们要清楚这个实验的目的是什么：\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 « SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\n译：在Xv6的trace命令中，它应该有一个参数，一个整数“掩码”，其位指定要跟踪的系统调用。例如，要跟踪fork系统调用，程序调用trace(1\u003c","wordCount":"1195","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-10-28T00:00:00Z","dateModified":"2024-10-28T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab2-system-calls/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)"><img src=https://kerolt.github.io/apple-touch-icon.png alt aria-label=logo height=35>Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【MIT6.S081】Lab2 system calls</h1><div class=post-meta><span title='2024-10-28 00:00:00 +0000 UTC'>2024-10-28</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1195 words&nbsp;·&nbsp;Kerolt</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#trace aria-label=trace>trace</a><ul><li><a href=#mask%e6%98%af%e4%bb%80%e4%b9%88 aria-label=mask是什么？>mask是什么？</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e5%8f%8a%e5%85%b6%e5%ad%90%e8%bf%9b%e7%a8%8b%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96mask aria-label=进程及其子进程如何获取mask？>进程及其子进程如何获取mask？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%b7%9f%e8%b8%aa%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label=如何跟踪系统调用？>如何跟踪系统调用？</a></li></ul></li><li><a href=#sysinfo aria-label=sysinfo>sysinfo</a><ul><li><a href=#%e8%ae%a1%e7%ae%97%e5%8f%af%e7%94%a8%e5%86%85%e5%ad%98%e5%ad%97%e8%8a%82%e6%95%b0 aria-label=计算可用内存字节数>计算可用内存字节数</a></li><li><a href=#%e8%ae%a1%e7%ae%97%e7%8a%b6%e6%80%81%e4%b8%ba%e6%9c%aa%e4%b8%ba%e4%bd%bf%e7%94%a8%e8%bf%9b%e7%a8%8b%e6%95%b0 aria-label=计算状态为未为使用进程数>计算状态为未为使用进程数</a></li><li><a href=#%e5%ae%8c%e6%88%90%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label=完成系统调用>完成系统调用</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>这个lab开始我们就正式进入了xv6的世界了，这一次我们可以了解到内核中系统调用的注册和运行原理，这可以说是之后lab的一个基石。</p><h2 id=trace>trace<a hidden class=anchor aria-hidden=true href=#trace>#</a></h2><p>首先，我们要清楚这个实验的目的是什么：</p><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You&rsquo;ll create a new trace system call that will control tracing. It should take one argument, an integer &ldquo;mask&rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &#171; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call&rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don&rsquo;t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>译：在Xv6的trace命令中，它应该有一个参数，一个整数“掩码”，其位指定要跟踪的系统调用。例如，要跟踪fork系统调用，程序调用<code>trace(1&lt;&lt;SYS_fork)</code>，其中SYS_fork是<code>kernel/syscall.h</code>中的系统调用编号。如果系统调用的编号在掩码中设置，则必须修改xv6内核，以便在每个系统调用即将返回时打印出一行。该行应包含<strong>进程id</strong>、<strong>系统调用的名称</strong>和<strong>返回值</strong>；您不需要打印系统调用参数。跟踪系统调用应启用对调用它的进程及其随后分叉的任何<strong>子进程</strong>的跟踪，但不应影响其他进程。</p><p>注意，在该实验的初始阶段，xv6已经为我们提供了trace命令的用户态实现，但是其底层的系统调用需要我们自己实现。</p><h3 id=mask是什么>mask是什么？<a hidden class=anchor aria-hidden=true href=#mask是什么>#</a></h3><p>在使用trace命令时用到的掩码，是用来跟踪之后使用的命令用到了哪些系统调用。例如实验中给出的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ trace <span class=m>32</span> grep hello README
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>1023</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>966</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>70</span>
</span></span><span class=line><span class=cl>3: syscall <span class=nb>read</span> -&gt; <span class=m>0</span>
</span></span></code></pre></div><p>这个32就是掩码，其跟踪到了grep命令中使用到了read系统调用（为什么是read？马上就说到了）。在xv6的<code>kernel/syscall.h</code>中有所有系统调用的编号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// System call numbers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SYS_fork    1
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_exit    2
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_wait    3
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_pipe    4
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_read    5
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_kill    6
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_exec    7
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_fstat   8
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_chdir   9
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_dup    10
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_getpid 11
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_sbrk   12
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_sleep  13
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_uptime 14
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_open   15
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_write  16
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_mknod  17
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_unlink 18
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_link   19
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_mkdir  20
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_close  21
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 添加
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define SYS_trace  22 
</span></span></span></code></pre></div><p>将这个mask以二进制的形式来看待更加容易理解，如果传入的mask是32，那么其二进制为100000，这个1出现的位置是第5位（最低位按0计数），也就是去找编号为5的系统调用，也就是<code>SYS_read</code>。</p><p>xv6内核提供给用户态的接口为trace，但是我们需要自己<strong>在xv6的用户头文件中添加函数的声明</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// user/user.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>trace</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>这个trace底层其实调用的应该是sys_trace（这个函数名不是固定的，但是源码中其他的系统调用的命名都为sys_*，故trace对应的系统调用写成sys_trace更加合理）。sys_trace需要做的是将用户传入的mask再传给当前进程及其子进程。</p><p>我们这里<strong>将系统调用sys_trace的编号设置为22</strong>。</p><h3 id=进程及其子进程如何获取mask>进程及其子进程如何获取mask？<a hidden class=anchor aria-hidden=true href=#进程及其子进程如何获取mask>#</a></h3><p>在xv6 book的4.3节中，有这么一段话：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>	syscall (kernel/syscall.c:132) retrieves the system call number from the saved a7 in the trapframe and uses it to index into syscalls. For the first system call, a7 contains SYS_exec (kernel/syscall.h:8),  resulting in a call to the system call implementation function sys_exec.
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	When sys_exec returns, syscall records its return value in p-&gt;trapframe-&gt;a0. This will cause the original user-space call to exec() to return that value, since the C calling convention on RISC-V places return values in a0. System calls conventionally return negative numbers to indicate errors, and zero or positive numbers for success. If the system call number is invalid, syscall prints an error and returns −1.
</span></span></code></pre></div><p>即系统调用的编号会保存在进程的trapframe中，根据a7寄存器即可获得，系统调用的返回值可通过a0寄存器获得。欸！这两个值可不就是实验实现中需要的吗！那么理所当然，实验中需要打印的语句应该就在这个函数中添加。</p><p>让我们来看看xv6中进程的数据结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/proc.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// p-&gt;lock must be held when using these:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>procstate</span> <span class=n>state</span><span class=p>;</span>        <span class=c1>// Process state
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>chan</span><span class=p>;</span>                  <span class=c1>// If non-zero, sleeping on chan
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>killed</span><span class=p>;</span>                  <span class=c1>// If non-zero, have been killed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>xstate</span><span class=p>;</span>                  <span class=c1>// Exit status to be returned to parent&#39;s wait
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>                     <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// wait_lock must be held when using this:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>         <span class=c1>// Parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// these are private to the process, so p-&gt;lock need not be held.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>kstack</span><span class=p>;</span>               <span class=c1>// Virtual address of kernel stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>sz</span><span class=p>;</span>                   <span class=c1>// Size of process memory (bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>;</span>       <span class=c1>// User page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=n>trapframe</span><span class=p>;</span> <span class=c1>// data page for trampoline.S
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>context</span> <span class=n>context</span><span class=p>;</span>      <span class=c1>// swtch() here to run process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>ofile</span><span class=p>[</span><span class=n>NOFILE</span><span class=p>];</span>  <span class=c1>// Open files
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>cwd</span><span class=p>;</span>           <span class=c1>// Current directory
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>               <span class=c1>// Process name (debugging)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// 添加
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>trace_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到诸如进程名、pid、上下文等信息都是保存在这个数据结构中，那么我们可以<strong>在其中加上一个成员变量 <code>trace_mask</code> 用于保存当前进程所对应trace命令中的掩码mask</strong>。</p><p>xv6已经实现了用户态的trace命令，其位于 <code>user/trace.c</code> 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/param.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/types.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;kernel/stat.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;user/user.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>nargv</span><span class=p>[</span><span class=n>MAXARG</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>3</span> <span class=o>||</span> <span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=sc>&#39;0&#39;</span> <span class=o>||</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=sc>&#39;9&#39;</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;Usage: %s mask command</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>trace</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;%s: trace failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAXARG</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>nargv</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>exec</span><span class=p>(</span><span class=n>nargv</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>nargv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于这样的一条命令 <code>trace 32 grep hello README</code> ，假设开启的进程名为p，那么32将会传给<code>p.trace_mask</code>，之后的grep操作将使用<code>exec</code><strong>创建子进程</strong>（假设进程名为son）执行，那么在创建子进程后应该有<code>son.trace_mask = p.trace_mask</code>，只有这样，grep操作所用到的系统调用才能被跟踪到。</p><p>在使用trace命令时，其后的mask参数会存到a0寄存器中，为了从其中拿到mask，可以使用<code>argint()</code>函数，其源码为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/syscall.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Fetch the nth 32-bit system call argument.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>argint</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>ip</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=nf>argraw</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>uint64</span> <span class=nf>argraw</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>3</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>4</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=mi>5</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;argraw&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>argint()</code>内调用了<code>argraw()</code>，在查看以上源码后，由于只传入了一个参数，故应该将0传入argraw中。<strong>在<code>kernel/sysproc.c</code>中实现<code>sys_trace()</code></strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/sysproc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trace_mask</span> <span class=o>=</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样当trace使用了底层的sys_trace时，就可以把mask参数传递给当前进程。但是只传递给当前进程还不够，还要传给当前进程的子进程。在Linux，我们创建子进程的函数为<code>fork()</code>，在xv6中也同样如此，fork内部先获取当前进程的proc结构体，然后新创建一个proc结构体代表子进程，并将父进程中的值拷贝过去，故<strong>传递给子进程的mask也在其中拷贝</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/proc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// copy mask from father process to son process
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// np为子进程，p为父进程
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>trace_mask</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trace_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>要注意一个小细节，<strong>当进程结构体被释放时（进程结束或者为进程分配proc结构体），其mask也该重置</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/proc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>freeproc</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trace_mask</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>完成好以上内容后，就可以<strong>实现sys_trace</strong>了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/sysproc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trace_mask</span> <span class=o>=</span> <span class=n>mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样，当前进程就可以获取了到mask，当其创建子进程时，子进程也可获取到mask~</p><h3 id=如何跟踪系统调用>如何跟踪系统调用？<a hidden class=anchor aria-hidden=true href=#如何跟踪系统调用>#</a></h3><p>刚刚我们说了mask的作用，还有进程及其子进程如何获取mask，那么我们又应该如何跟踪系统调用呢？</p><p>xv6中所用的系统调用都是在 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数中调用的，为了能在syscall.c中调用sys_trace，需要在其中<strong>添加extern声明</strong>（其定义在刚刚已经实现，位于kernel/sysproc.c）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=n>uint64</span> <span class=nf>sys_trace</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>同时需要<strong>在syscalls数组中添加sys_trace的编号</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=nf>uint64</span> <span class=p>(</span><span class=o>*</span><span class=n>syscalls</span><span class=p>[])(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>SYS_trace</span><span class=p>]</span>   <span class=n>sys_trace</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这里实际上就是 [22] = sys_trace
</span></span></span><span class=line><span class=cl><span class=c1>// 使用了gcc的一个拓展
</span></span></span></code></pre></div><p>并按照顺序<strong>添加各个系统调用的名字</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>syscall_names</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;fork&#34;</span><span class=p>,</span> <span class=s>&#34;exit&#34;</span><span class=p>,</span> <span class=s>&#34;wait&#34;</span><span class=p>,</span> <span class=s>&#34;pipe&#34;</span><span class=p>,</span> <span class=s>&#34;read&#34;</span><span class=p>,</span> <span class=s>&#34;kill&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;exec&#34;</span><span class=p>,</span> <span class=s>&#34;fstat&#34;</span><span class=p>,</span> <span class=s>&#34;chdir&#34;</span><span class=p>,</span> <span class=s>&#34;dup&#34;</span><span class=p>,</span> <span class=s>&#34;getpid&#34;</span><span class=p>,</span> <span class=s>&#34;sbrk&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;sleep&#34;</span><span class=p>,</span> <span class=s>&#34;uptime&#34;</span><span class=p>,</span> <span class=s>&#34;open&#34;</span><span class=p>,</span> <span class=s>&#34;write&#34;</span><span class=p>,</span> <span class=s>&#34;mknod&#34;</span><span class=p>,</span> <span class=s>&#34;unlink&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;link&#34;</span><span class=p>,</span> <span class=s>&#34;mkdir&#34;</span><span class=p>,</span> <span class=s>&#34;close&#34;</span><span class=p>,</span> <span class=s>&#34;trace&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在 <code>kernel/syscall.c</code> 中，xv6根据a7寄存器获取系统调用的编号，然后通过syscalls函数数组执行系统调用，那么我们的实现为：当使用的系统调用合法时，获取当前进程的mask，并通过判断<code>(mask >> syscall_num) & 1</code>是否为1来输出跟踪信息。</p><p>例如sys_read系统调用的编号为5，mask为32，则<code>(32 >> 5) & 1 = 1</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>syscall</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>num</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=nf>NELEM</span><span class=p>(</span><span class=n>syscalls</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Use num to lookup the system call function for num, call it,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and store its return value in p-&gt;trapframe-&gt;a0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=n>syscalls</span><span class=p>[</span><span class=n>num</span><span class=p>]();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// ===============================
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trace_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>mask</span> <span class=o>&gt;&gt;</span> <span class=n>num</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d: syscall %s -&gt; %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>syscall_names</span><span class=p>[</span><span class=n>num</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ===============================
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d %s: unknown sys call %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>那么，内核是如何通过trace找到sys_trace的呢？根据实验指导上的提示，可以知道 <code>user/usys.pl</code> 起到了一个中间人的作用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl># user/usys.pl
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sub entry {
</span></span><span class=line><span class=cl>    my $name = shift;
</span></span><span class=line><span class=cl>    print &#34;.global $name\n&#34;;
</span></span><span class=line><span class=cl>    print &#34;${name}:\n&#34;;
</span></span><span class=line><span class=cl>    print &#34; li a7, SYS_${name}\n&#34;;
</span></span><span class=line><span class=cl>    print &#34; ecall\n&#34;;
</span></span><span class=line><span class=cl>    print &#34; ret\n&#34;;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>entry(&#34;uptime&#34;);
</span></span><span class=line><span class=cl><span class=gi>++entry(&#34;trace&#34;); # 这是实验中需要由我们自己添加的
</span></span></span></code></pre></div><p>通过其中的entry函数，可以生成对应的调用（xv6中为ecall）系统调用的汇编语句，即大致的流程为xv6在构建内核时，会将用户态trace命令对应到：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=na>.global</span> <span class=no>trace</span>
</span></span><span class=line><span class=cl><span class=nl>trace:</span>
</span></span><span class=line><span class=cl>    <span class=nf>li</span> <span class=no>a7</span><span class=p>,</span> <span class=no>SYS_trace</span>
</span></span><span class=line><span class=cl>    <span class=nf>ecall</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>这样，当前进程就可以通过a7寄存器拿到sys_trace的系统调用编号了，也就是说，<code>syscall</code> 函数可以调用 <code>sys_trace</code> 了。</p><p>OK，那么一个大致的框架就出来了：</p><p><img loading=lazy src=https://s2.loli.net/2024/12/16/U2PElyAr1aZYxFe.png></p><p>完成上面的步骤后，最后只要在<code>Makefile</code>中的<code>UPROGS</code>加上<code>$U/_trace</code>即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl>UPROGS=\
</span></span><span class=line><span class=cl>	$U/_cat\
</span></span><span class=line><span class=cl>	$U/_echo\
</span></span><span class=line><span class=cl>	$U/_forktest\
</span></span><span class=line><span class=cl>	$U/_grep\
</span></span><span class=line><span class=cl>	$U/_init\
</span></span><span class=line><span class=cl>	$U/_kill\
</span></span><span class=line><span class=cl>	$U/_ln\
</span></span><span class=line><span class=cl>	$U/_ls\
</span></span><span class=line><span class=cl>	$U/_mkdir\
</span></span><span class=line><span class=cl>	$U/_rm\
</span></span><span class=line><span class=cl>	$U/_sh\
</span></span><span class=line><span class=cl>	$U/_stressfs\
</span></span><span class=line><span class=cl>	$U/_usertests\
</span></span><span class=line><span class=cl>	$U/_grind\
</span></span><span class=line><span class=cl>	$U/_wc\
</span></span><span class=line><span class=cl>	$U/_zombie\
</span></span><span class=line><span class=cl><span class=gi>++	$U/_trace
</span></span></span></code></pre></div><p>在这个lab中，我们需要添加一个系统调用sysinfo，用于收集有关正在运行的系统的信息。</p><p>系统调用的声明为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sysinfo</span><span class=p>(</span><span class=k>struct</span> <span class=n>sysinfo</span><span class=o>*</span><span class=p>);</span>
</span></span></code></pre></div><p>这个系统调用接受一个指向结构体sysinfo的指针，其定义为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/sysinfo.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sysinfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>freemem</span><span class=p>;</span>   <span class=c1>// amount of free memory (bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>nproc</span><span class=p>;</span>     <span class=c1>// number of process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>内核应填写此结构的字段：freemem字段应设置为可用内存的<strong>字节数</strong>，nproc字段应设为<strong>状态未使用</strong>的进程数。</p><h2 id=sysinfo>sysinfo<a hidden class=anchor aria-hidden=true href=#sysinfo>#</a></h2><p>在这个part中，我们需要添加一个系统调用sysinfo，用于收集有关正在运行的系统的信息。</p><h3 id=计算可用内存字节数>计算可用内存字节数<a hidden class=anchor aria-hidden=true href=#计算可用内存字节数>#</a></h3><p>我们可以通过内核中的<code>kmem</code>来获取可用的内存块的数量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>spinlock</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span> <span class=o>*</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>kmem</span><span class=p>;</span>
</span></span></code></pre></div><p><code>kmem.freelist</code>是一个链表，保存了所有<strong>可用</strong>的内存块的地址，我们遍历这个链表即可获取可用内存块数量，又一个内存块的大小为4KB，那么<code>系统可用的内存字节数 = 可用内存块数量 * 4KB</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/kalloc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>freemem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>run</span><span class=o>*</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>free_page</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span> <span class=o>=</span> <span class=n>kmem</span><span class=p>.</span><span class=n>freelist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>free_page</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>kmem</span><span class=p>.</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 4K = 2^12，左移操作相当于对2的乘法
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=p>(</span><span class=n>free_page</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=计算状态为未为使用进程数>计算状态为未为使用进程数<a hidden class=anchor aria-hidden=true href=#计算状态为未为使用进程数>#</a></h3><p>内核中有一个全局数组，其中每一项为系统中的进程，xv6中设置最多进程数为64个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>proc</span> <span class=n>proc</span><span class=p>[</span><span class=n>NPROC</span><span class=p>];</span>
</span></span></code></pre></div><p>在表示进程的结构体中，有一个成员表示这个进程的状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=n>procstate</span> <span class=p>{</span> <span class=n>UNUSED</span><span class=p>,</span> <span class=n>USED</span><span class=p>,</span> <span class=n>SLEEPING</span><span class=p>,</span> <span class=n>RUNNABLE</span><span class=p>,</span> <span class=n>RUNNING</span><span class=p>,</span> <span class=n>ZOMBIE</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Per-process state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=c1>// p-&gt;lock must be held when using these:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>procstate</span> <span class=n>state</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以遍历proc数组，找到所有<code>state != UNUSED</code>的进程的数量（这里一定要看清楚，是<strong>状态为未使用</strong>的进程数，而不是未使用的进程数）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// kernel/proc.c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>nproc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>not_unused</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>proc</span><span class=p>[</span><span class=n>NPROC</span><span class=p>];</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>!=</span> <span class=n>UNUSED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>not_unused</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>not_unused</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=完成系统调用>完成系统调用<a hidden class=anchor aria-hidden=true href=#完成系统调用>#</a></h3><blockquote><p>如何获取用户态传递过来的参数和注册系统调用可以参考这篇<a href=https://kerolt.github.io/posts/18ad9abb/#%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F>博客</a>，这里就不赘述了</p></blockquote><p>我们创建了<code>struct sysinfo</code>结构体变量<code>info</code>后，使用刚刚的<code>freemem</code>和<code>nproc</code>函数来为结构体变量赋值，之后通过<code>copyout</code>函数将内核态中的<code>info</code>拷贝给用户态的<code>struct sysinfo</code>结构体变量。</p><p>这里的实现原理是：用户态下我们使用系统调用传递了一个<code>struct sysinfo</code>指针，其实就是传递了一个内存地址<code>addr</code>；内核态下我们将<code>info</code>中的数据原封不动地搬一份到<code>addr</code>处。这样当用户态访问<code>addr</code>处的内存时就可以获取到想要的数据了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span> <span class=nf>sys_sysinfo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>argaddr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>sysinfo</span> <span class=n>info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>info</span><span class=p>.</span><span class=n>freemem</span> <span class=o>=</span> <span class=nf>freemem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>info</span><span class=p>.</span><span class=n>nproc</span> <span class=o>=</span> <span class=nf>nproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>copyout</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>info</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>info</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kerolt.github.io/tags/os/>OS</a></li><li><a href=https://kerolt.github.io/tags/mit6-s081/>MIT6-S081</a></li></ul><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab3-page-tables%E4%B8%8B/><span class=title>« Prev</span><br><span>【MIT6.S081】Lab3 page tables（下）</span>
</a><a class=next href=https://kerolt.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mit6.s081lab1-utilities/><span class=title>Next »</span><br><span>【MIT6.S081】Lab1 utilities</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>