<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【CMU15-445 Fall2023】Project4 Concurrency Control 小结 | Kerolt's Blog</title>
<meta name=keywords content="Database"><meta name=description content="这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：
每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~
0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：
class TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist."><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.205412d4e3165d21bba592536dfcf65daac7b5defe81eeb19f788d0f805b9eba.css integrity="sha256-IFQS1OMWXSG7pZJTbfz2XarHtd7+ge6xn3iND4Bbnro=" rel="preload stylesheet" as=style><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.jpeg><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【CMU15-445 Fall2023】Project4 Concurrency Control 小结"><meta property="og:description" content="这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：
每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~
0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：
class TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-15T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-15T00:00:00+00:00"><meta property="article:tag" content="Database"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【CMU15-445 Fall2023】Project4 Concurrency Control 小结"><meta name=twitter:description content="这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：
每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~
0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：
class TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【CMU15-445 Fall2023】Project4 Concurrency Control 小结","item":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【CMU15-445 Fall2023】Project4 Concurrency Control 小结","name":"【CMU15-445 Fall2023】Project4 Concurrency Control 小结","description":"这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：\n每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~\n0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：\nclass TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist.","keywords":["Database"],"articleBody":"这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：\n每个事务在启动时会被分配一个唯一的 事务 ID 或 读取时间戳 。 数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本： 可见性规则 ：事务只能看到在其读取时间戳之前提交的数据版本。 不可见性规则 ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。 15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~\n0. Bustub 中的 undolog bustub 中在 TransactionManager 中通过一个哈希表来保存所有 tuple 的 undolog 起点：\nclass TransactionManager { public: ... struct PageVersionInfo { /** protects the map */ std::shared_mutex mutex_; /** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because * it will create new elements even if it does not exist. Use `find` instead. */ std::unordered_map\u003cslot_offset_t, VersionUndoLink\u003e prev_version_; }; /** protects version info */ std::shared_mutex version_info_mutex_; /** Stores the previous version of each tuple in the table heap. Do not directly access this field. Use the helper * functions in `transaction_manager_impl.cpp`. */ std::unordered_map\u003cpage_id_t, std::shared_ptr\u003cPageVersionInfo\u003e\u003e version_info_; ... } 其中的 VersionUndoLink 也只是对 UndoLink 的一个包装：\nstruct UndoLink { /* Previous version can be found in which txn */ txn_id_t prev_txn_{INVALID_TXN_ID}; /* The log index of the previous version in `prev_txn_` */ int prev_log_idx_{0}; ... }; struct VersionUndoLink { /** The next version in the version chain. */ UndoLink prev_; /** Whether a transaction is modifying the version link. Fall 2023: you do not need to read / write this field until * task 4.2. */ bool in_progress_{false}; ... }; 一个 tuple 最新的数据会保存在 table heap 中，而 txn manager 通过这个 tuple 的 rid 可以获取到这个 tuple 的 undolog：\nexec_ctx_-\u003eGetTransactionManager()-\u003eGetUndoLink(rid); 1. Task 1 - Timestamps 每个事务有两个时间戳：\nread_ts：事务开始时分配，表示该事务能看到的最新提交的数据版本。 commit_ts：事务提交时分配，是一个单调递增的逻辑时间戳，决定事务的串行化顺序。 规则如下：\n事务开始时（Begin），read_ts = last_commit_ts 事务提交时（Commit），commit_ts = ++last_commit_ts 对于 Watermark 机制，其定义是所有活跃事务中的最小 read_ts，作用为确定哪些数据版本已经不再被任何事务读取，从而可以安全地清理旧版本数据。\n这里很简单，就是需要在维护好系统中的 watermark，遍历事务映射中的所有事务，找出所有进行中事务中最小的 read_ts 为 watermark。在事务的 Begin、Commit、Abort 中需要使用 Watermark::AddTxn 和 Watermark::RemoveTxn 来更新 watermark。在更新时，可以使用红黑树或者哈希表 + 优先队列来快速找到最小的 read_ts。\n2. Task2 - Storage Format and Sequential Scan 2.1 Tuple Reconstruction 数据库需要一种机制来“回溯”数据的历史版本，而 ReconstructTuple 正是这种机制的核心实现。\n在 MVCC 系统中，表堆（table heap）通常存储的是最新的数据版本，而旧版本的元组信息则通过 undo logs 记录下来。当事务需要访问某个元组的历史版本时，ReconstructTuple 会从表堆中获取最新的元组，并根据 undo logs 逐步恢复出符合事务读取时间戳的版本。\n在 MVCC 系统中，数据的删除操作并不会立即从表堆中移除元组，而是通过设置 is_deleted 标志来标记逻辑删除。ReconstructTuple 在处理 undo logs 时会检查 is_deleted 标志，从而判断某个元组是否已被删除。ReconstructTuple 将始终应用提供给函数的所有修改，而无需查看元数据或撤销日志中的时间戳。除了函数参数列表中提供的数据外，它不需要访问其他数据。\nundo log 记录的是上次操作完的结果（换句话说，这次没操作前是什么样子），只有 modified_fields_ 是为了告诉这次操作，在上次修改完成之前 tuple 是什么样子。\nmodified_fields_：长度与 tuple 的 schema 相同，每个位代表在这次的操作中对于某个字段时候有更新 tuple_：其长度 \u003c= 原始的 tuple，只记录了 modified_fields_ 中为 true 的字段，并且保存的值是本次操作之前的值 ReconstructTuple 的工作流程：\n获取最新元组 从表堆中读取最新版本的元组（base_tuple）及其元数据（base_meta）。 初始化 tuple_values，存储元组的字段值。 遍历 undo logs Undo logs 按时间戳降序排列，记录了元组的历史修改。 对于每个 undo log： 如果 is_deleted_ 为 true，标记元组为已删除。 否则，根据 modified_fields_ 更新 tuple_values 中对应字段的值。（所以这里类似于去覆盖更新） 生成结果元组 如果元组被标记为删除，返回空值。 否则，根据更新后的 tuple_values 构造并返回新的元组。 2.2 Sequential Scan / Tuple Retrieval 这里的意图就是需要在 bustub 执行 seq executor 算子时找到当前事务可以使用的 tuple。\n判断当前 tuple 是否对当前事务可见:\ncase1：tuple 的 ts_ 比 txn_read_ts 小，则 tuple 对当前事务可见 case2：tuple 的 ts_ 等于 txn_temp_ts，则 tuple 对当前事务可见 case3：不满足 case1 也不满足 case2，则 tuple 对当前事务不可见 如果是 case1 和 case2，说明当前事务可以直接使用 table heap 中的这条 tuple；而如果是 case3，则需要遍历这条 tuple 的版本链，找出可以用的 undolog，如果有就使用 ReconstructTuple 来重建一个可见的历史版本的 tuple。\n3. Task3 - MVCC Executors 在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；\n在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；\n在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。\nfrom 小林coding - 为什么需要-undo-log\n简单理解：改了什么，你就保存什么。\nInsert 在这一步只需要将插入的 tuple 的 rid 记录到事务 write set 中，然后在 txn manager 中设置新 tuple 的 undolog 链为空（相当于给这个 undolog 链初始化）。\n为什么 Insert 操作不需要 undo log\n在 MVCC（多版本并发控制）机制下，每个事务看到的数据版本取决于其时间戳。对于 INSERT 操作，由于插入的是全新的记录，不存在“历史版本”的问题。因此，不需要为 INSERT 操作维护 Undo Log 来支持 MVCC 中的版本链。\n当执行一个 INSERT 操作时，如果事务需要回滚，只需删除刚刚插入的记录即可，而无需像 UPDATE 或 DELETE 那样恢复旧数据状态。因此，INSERT 操作只需要记录被插入记录的主键信息，以便在回滚时定位并删除该记录。这种情况下，Undo Log 的作用非常有限，甚至可以省略。\n相比之下，UPDATE 和 DELETE 操作会创建新的版本或标记旧版本为无效，这些都需要通过 Undo Log 来记录和管理。\nUpdate \u0026 Delete 在修改操作（update 和 delete）中，对于 tuple 中的字段有两种情况：\n情况 1（当前事务在未提交前进行了修改）：由于每个事务都对当前操作的 tuple 的 undolog 只能保存一份，因此在生成本次的 undolog 后还需要需要合并上一次的 undolog。 情况 2（这是当前事务第一次修改）：创建一个新的 undolog，并把它添加到版本链中。 在完成修改操作后，需要更新 table heap 中的值：修改 tuple 的数据为更新后的值，同时更新 tuple 的 meta，其时间戳为当前事务的 temp ts（这可用于标识这个 tuple 正在被哪个事务修改）；然后还要将当前修改 tuple 的 id（也就是其 rid）添加到当前事务的 write set，这在事务提交时会根据 rid 来正确设置 table heap 中 tuple 的 ts。\nCommit 刚刚说到在修改时需要修改 tuple 的 meta 数据中的 ts 为当前事务的 temp ts，因为此时事务还没提交，使用 temp ts 就能分辨出现在这条 tuple 是否正在被修改：temp ts 是一个很大的数（TXN_START_ID + txn_id，其中 TXN_START_ID = 1LL \u003c\u003c 62），事务的 read ts 和 commit ts 都会小于这个数；在判断一个 tuple 是否可见时，都是通过事务的 read ts（txn.read_ts）与 tuple.meta.ts 进行比较，如果 tuple.meta.ts \u003c= txn.read_ts，那么这个 tuple 对于 txn 是可见的，而如果 tuple.meta.ts == txn.temp_ts，则这个 tuple 正在被 txn 进行修改。\n这样的话，即便是在修改后 tuple.meta.ts 也只是事务的 temp ts，所以在 commit 时，需要将其设置为系统的最新 commit ts。这里需要做几点：\n获取当前系统的 commit ts，计算方式为 last_commit_ts_ + 1 遍历当前要提交的事务的 write set，更新修改了的 tuple 的 meta 数据，将 meta.ts 设置为 commit ts 设置事务的 commit ts，并且更新系统的 last_commit_ts GarbageCollection 之前一旦我们将事务添加到 txn manager 中，我们就永远不会删除它，因为 read_ts 较小的事务可能需要读取存储在先前已提交或已中止事务中的撤销日志。这里需要实现 TransactionManager::GarbageCollection() 函数，删除未使用的事务。\n一个事务在运行时只需要看到它自己的快照，一旦事务结束，它所依赖的数据版本就可以被考虑回收。只有当某个数据版本不再被任何活跃事务需要时，才能进行垃圾回收（GC）。\n举个🌰，假设我们有如下记录：\nRID ts_ 数据 A 1 Alice A 2 Bob A 3 Charlie A 4 David 这表示记录 A 被不同事务更新了四次。现在系统中有三个事务：\n事务 ID 状态 可见性范围 T2 RUNNING ts ≤ 2 T4 RUNNING ts ≤ 4 T5 RUNNING ts ≤ 5 watermark = 2（最小活跃事务 ID）\nQ1: T5 能看到 ts_=1 的数据吗？\n没问题，因为 T5 的 ts=5 \u003e 1，且事务 1 已完成。\nQ2: ts_=1 的数据可以被清理吗？\n不可以，因为 T2（ts=2）还在运行，它的可见范围是 ts ≤ 2，所以它可能会访问 ts=1 的数据。\nQ3: 如果 T2 提交或中止，watermark 会变成多少？此时 ts=1 的数据能被清理吗？\nwatermark 更新为 min(4,5) = 4 此时所有活跃事务的 ts ≥ 4 所以 ts ≤ 3 的数据都对活跃事务不可见 → 可以安全清理 这里有一个关键点：可见 ≠ 不可清理\n可见性：表示某个事务是否能看到某条记录（比如 T5 能看到 ts_=3 的记录） 清理条件：表示这条记录是否仍然被任何一个活跃事务所需要，如果没有任何活跃事务再访问它，就可以清理 所以 GC 的步骤可以简单总结如下：\n遍历数据库中所有 tuple 判断 tuple.ts_ ≤ watermark → 不再被活跃事务访问 沿着 undo link 遍历 undo log 链 统计每个事务有多少 undo log 不再被访问 如果某个事务所有 undo log 都不可见，且事务已完成 → 删除其 undo log 和事务元信息 References https://blog.csdn.net/weixin_48885685/article/details/143225977 https://github.com/ZepengLi111/cmu15445-2023-fall-bustub Qwen ChatGPT ","wordCount":"732","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-15T00:00:00Z","dateModified":"2025-05-15T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project4-concurrency-control-%E5%B0%8F%E7%BB%93/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.jpeg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【CMU15-445 Fall2023】Project4 Concurrency Control 小结</h1><div class=post-meta><span title='2025-05-15 00:00:00 +0000 UTC'>2025-05-15</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;732 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags><li><a href=https://kerolt.github.io/tags/database/>Database</a></li></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-bustub-%e4%b8%ad%e7%9a%84-undolog aria-label="0. Bustub 中的 undolog">0. Bustub 中的 undolog</a></li><li><a href=#1-task-1---timestamps aria-label="1. Task 1 - Timestamps">1. Task 1 - Timestamps</a></li><li><a href=#2-task2---storage-format-and-sequential-scan aria-label="2. Task2 - Storage Format and Sequential Scan">2. Task2 - Storage Format and Sequential Scan</a><ul><li><a href=#21-tuple-reconstruction aria-label="2.1 Tuple Reconstruction">2.1 Tuple Reconstruction</a></li><li><a href=#22-sequential-scan--tuple-retrieval aria-label="2.2 Sequential Scan / Tuple Retrieval">2.2 Sequential Scan / Tuple Retrieval</a></li></ul></li><li><a href=#3-task3---mvcc-executors aria-label="3. Task3 - MVCC Executors">3. Task3 - MVCC Executors</a><ul><li><a href=#insert aria-label=Insert>Insert</a></li><li><a href=#update--delete aria-label="Update &amp;amp; Delete">Update & Delete</a></li><li><a href=#commit aria-label=Commit>Commit</a></li><li><a href=#garbagecollection aria-label=GarbageCollection>GarbageCollection</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>这个 project 主要是希望我们理解 MVCC 的一些相关知识。MVCC 的设计目标是通过维护多个版本的元组（tuple），使得不同的事务能够访问到与其时间戳一致的数据版本，而无需通过锁机制完全阻塞其他事务的操作。具体来说：</p><ul><li>每个事务在启动时会被分配一个唯一的 <strong>事务 ID</strong> 或 <strong>读取时间戳</strong> 。</li><li>数据库系统会根据事务的读取时间戳，决定该事务能看到哪些数据版本：<ul><li><strong>可见性规则</strong> ：事务只能看到在其读取时间戳之前提交的数据版本。</li><li><strong>不可见性规则</strong> ：事务不能看到在其读取时间戳之后提交或未提交的数据版本。</li></ul></li></ul><blockquote><p>15445 的 lab 写了太久太久了，自己懒是一方面，实力不够也是一方面，task4 后面的 lab 就不打算写了（无奈.jpg）。在这整个过程中，学到的东西还挺多的，对于代码能力也有提升，以后有时间还是可以多看看配套的课程，然后再好好读读代码，写写注释和博客去深入理解理解，毕竟 bustub 的不论是代码架构还是规范我都觉得非常棒。后面就要像 15445 网页中写到的，去多关注生活中其他感兴趣的地方了，希望能够不断提升自己~</p></blockquote><h2 id=0-bustub-中的-undolog>0. Bustub 中的 undolog<a hidden class=anchor aria-hidden=true href=#0-bustub-中的-undolog>#</a></h2><p>bustub 中在 <code>TransactionManager</code> 中通过一个哈希表来保存所有 tuple 的 undolog 起点：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>TransactionManager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=k>struct</span> <span class=nc>PageVersionInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** protects the map */</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_mutex</span> <span class=n>mutex_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** Stores previous version info for all slots. Note: DO NOT use `[x]` to access it because
</span></span></span><span class=line><span class=cl><span class=cm>     * it will create new elements even if it does not exist. Use `find` instead.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>slot_offset_t</span><span class=p>,</span> <span class=n>VersionUndoLink</span><span class=o>&gt;</span> <span class=n>prev_version_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** protects version info */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_mutex</span> <span class=n>version_info_mutex_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** Stores the previous version of each tuple in the table heap. Do not directly access this field. Use the helper
</span></span></span><span class=line><span class=cl><span class=cm>   * functions in `transaction_manager_impl.cpp`. */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>page_id_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>PageVersionInfo</span><span class=o>&gt;&gt;</span> <span class=n>version_info_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中的 <code>VersionUndoLink</code> 也只是对 <code>UndoLink</code> 的一个包装：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>UndoLink</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Previous version can be found in which txn */</span>
</span></span><span class=line><span class=cl>  <span class=n>txn_id_t</span> <span class=n>prev_txn_</span><span class=p>{</span><span class=n>INVALID_TXN_ID</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* The log index of the previous version in `prev_txn_` */</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prev_log_idx_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>VersionUndoLink</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The next version in the version chain. */</span>
</span></span><span class=line><span class=cl>  <span class=n>UndoLink</span> <span class=n>prev_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** Whether a transaction is modifying the version link. Fall 2023: you do not need to read / write this field until
</span></span></span><span class=line><span class=cl><span class=cm>   * task 4.2. */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>in_progress_</span><span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>一个 tuple 最新的数据会保存在 table heap 中，而 txn manager 通过这个 tuple 的 rid 可以获取到这个 tuple 的 undolog：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>exec_ctx_</span><span class=o>-&gt;</span><span class=n>GetTransactionManager</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetUndoLink</span><span class=p>(</span><span class=n>rid</span><span class=p>);</span>
</span></span></code></pre></div><p><img loading=lazy src=https://15445.courses.cs.cmu.edu/fall2023/project4/img/2-1-storage-format.png></p><p><img loading=lazy src=https://15445.courses.cs.cmu.edu/fall2023/project4/img/2-2-undo-log.png></p><h2 id=1-task-1---timestamps>1. Task 1 - Timestamps<a hidden class=anchor aria-hidden=true href=#1-task-1---timestamps>#</a></h2><p>每个事务有两个时间戳：</p><ul><li><code>read_ts</code>：事务开始时分配，表示该事务能看到的最新提交的数据版本。</li><li><code>commit_ts</code>：事务提交时分配，是一个单调递增的逻辑时间戳，决定事务的串行化顺序。</li></ul><p>规则如下：</p><ul><li>事务开始时（Begin），<code>read_ts = last_commit_ts</code></li><li>事务提交时（Commit），<code>commit_ts = ++last_commit_ts</code></li></ul><p>对于 Watermark 机制，其定义是<strong>所有活跃事务中的最小 <code>read_ts</code></strong>，作用为确定哪些数据版本已经不再被任何事务读取，从而可以安全地清理旧版本数据。</p><p>这里很简单，就是需要在维护好系统中的 watermark，遍历事务映射中的所有事务，找出所有进行中事务中最小的 read_ts 为 watermark。在事务的 Begin、Commit、Abort 中需要使用 <code>Watermark::AddTxn</code> 和 <code>Watermark::RemoveTxn</code> 来更新 watermark。在更新时，可以使用<strong>红黑树</strong>或者<strong>哈希表 + 优先队列</strong>来快速找到最小的 read_ts。</p><h2 id=2-task2---storage-format-and-sequential-scan>2. Task2 - Storage Format and Sequential Scan<a hidden class=anchor aria-hidden=true href=#2-task2---storage-format-and-sequential-scan>#</a></h2><h3 id=21-tuple-reconstruction>2.1 Tuple Reconstruction<a hidden class=anchor aria-hidden=true href=#21-tuple-reconstruction>#</a></h3><p>数据库需要一种机制来“回溯”数据的历史版本，而 <code>ReconstructTuple</code> 正是这种机制的核心实现。</p><p>在 MVCC 系统中，表堆（table heap）通常存储的是最新的数据版本，而旧版本的元组信息则通过 undo logs 记录下来。当事务需要访问某个元组的历史版本时，<code>ReconstructTuple</code> 会从表堆中获取最新的元组，并根据 undo logs 逐步恢复出符合事务读取时间戳的版本。</p><p>在 MVCC 系统中，数据的删除操作并不会立即从表堆中移除元组，而是通过设置 <code>is_deleted</code> 标志来标记逻辑删除。<code>ReconstructTuple</code> 在处理 undo logs 时会检查 <code>is_deleted</code> 标志，从而判断某个元组是否已被删除。<code>ReconstructTuple</code> 将始终应用提供给函数的所有修改，而无需查看元数据或撤销日志中的时间戳。除了函数参数列表中提供的数据外，它不需要访问其他数据。</p><p><img loading=lazy src=https://15445.courses.cs.cmu.edu/fall2023/project4/img/2-4-undo-log-format.png></p><p>undo log 记录的是上次操作完的结果（换句话说，这次没操作前是什么样子），只有 <code>modified_fields_</code> 是为了告诉这次操作，在上次修改完成之前 tuple 是什么样子。</p><ul><li><code>modified_fields_</code>：长度与 tuple 的 schema 相同，每个位代表在这次的操作中对于某个字段时候有更新</li><li><code>tuple_</code>：其长度 &lt;= 原始的 tuple，只记录了 modified_fields_ 中为 true 的字段，并且<strong>保存的值是本次操作之前的值</strong></li></ul><p><code>ReconstructTuple</code> 的工作流程：</p><ol><li><strong>获取最新元组</strong><ul><li>从表堆中读取最新版本的元组（<code>base_tuple</code>）及其元数据（<code>base_meta</code>）。</li><li>初始化 <code>tuple_values</code>，存储元组的字段值。</li></ul></li><li><strong>遍历 undo logs</strong><ul><li>Undo logs 按时间戳降序排列，记录了元组的历史修改。</li><li>对于每个 undo log：<ul><li>如果 <code>is_deleted_</code> 为 <code>true</code>，标记元组为已删除。</li><li>否则，根据 <code>modified_fields_</code> 更新 <code>tuple_values</code> 中对应字段的值。（所以这里类似于去覆盖更新）</li></ul></li></ul></li><li><strong>生成结果元组</strong><ul><li>如果元组被标记为删除，返回空值。</li><li>否则，根据更新后的 <code>tuple_values</code> 构造并返回新的元组。</li></ul></li></ol><h3 id=22-sequential-scan--tuple-retrieval>2.2 Sequential Scan / Tuple Retrieval<a hidden class=anchor aria-hidden=true href=#22-sequential-scan--tuple-retrieval>#</a></h3><p>这里的意图就是需要在 bustub 执行 <code>seq executor</code> 算子时找到当前事务可以使用的 tuple。</p><p>判断当前 tuple 是否对当前事务可见:</p><ul><li>case1：tuple 的 ts_ 比 txn_read_ts 小，则 tuple 对当前事务可见</li><li>case2：tuple 的 ts_ 等于 txn_temp_ts，则 tuple 对当前事务可见</li><li>case3：不满足 case1 也不满足 case2，则 tuple 对当前事务不可见</li></ul><p>如果是 case1 和 case2，说明当前事务可以直接使用 table heap 中的这条 tuple；而如果是 case3，则需要遍历这条 tuple 的版本链，找出可以用的 undolog，如果有就使用 <code>ReconstructTuple</code> 来重建一个可见的历史版本的 tuple。</p><h2 id=3-task3---mvcc-executors>3. Task3 - MVCC Executors<a hidden class=anchor aria-hidden=true href=#3-task3---mvcc-executors>#</a></h2><blockquote><p>在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；</p><p>在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；</p><p>在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。</p><p>from <a href=https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log>小林coding - 为什么需要-undo-log</a></p></blockquote><p>简单理解：改了什么，你就保存什么。</p><h3 id=insert>Insert<a hidden class=anchor aria-hidden=true href=#insert>#</a></h3><p>在这一步只需要将插入的 tuple 的 rid 记录到事务 write set 中，然后在 txn manager 中设置新 tuple 的 undolog 链为空（相当于给这个 undolog 链初始化）。</p><blockquote><p>为什么 Insert 操作不需要 undo log</p></blockquote><p>在 MVCC（多版本并发控制）机制下，每个事务看到的数据版本取决于其时间戳。对于 <code>INSERT</code> 操作，由于插入的是全新的记录，不存在“历史版本”的问题。因此，不需要为 <code>INSERT</code> 操作维护 Undo Log 来支持 MVCC 中的版本链。</p><p>当执行一个 <code>INSERT</code> 操作时，如果事务需要回滚，只需删除刚刚插入的记录即可，而无需像 <code>UPDATE</code> 或 <code>DELETE</code> 那样恢复旧数据状态。因此，<code>INSERT</code> 操作只需要记录被插入记录的主键信息，以便在回滚时定位并删除该记录。这种情况下，Undo Log 的作用非常有限，甚至可以省略。</p><p>相比之下，<code>UPDATE</code> 和 <code>DELETE</code> 操作会创建新的版本或标记旧版本为无效，这些都需要通过 Undo Log 来记录和管理。</p><h3 id=update--delete>Update & Delete<a hidden class=anchor aria-hidden=true href=#update--delete>#</a></h3><p>在修改操作（update 和 delete）中，对于 tuple 中的字段有两种情况：</p><ol><li>情况 1（当前事务在未提交前进行了修改）：由于每个事务都对当前操作的 tuple 的 undolog 只能保存一份，因此在生成本次的 undolog 后还需要需要合并上一次的 undolog。</li><li>情况 2（这是当前事务第一次修改）：创建一个新的 undolog，并把它添加到版本链中。</li></ol><p>在完成修改操作后，需要更新 table heap 中的值：修改 tuple 的数据为更新后的值，同时更新 tuple 的 meta，其时间戳为当前事务的 temp ts（这可用于标识这个 tuple 正在被哪个事务修改）；然后还要将当前修改 tuple 的 id（也就是其 rid）添加到当前事务的 write set，这在事务提交时会根据 rid 来正确设置 table heap 中 tuple 的 ts。</p><h3 id=commit>Commit<a hidden class=anchor aria-hidden=true href=#commit>#</a></h3><p>刚刚说到在修改时需要修改 tuple 的 meta 数据中的 ts 为当前事务的 temp ts，因为此时事务还没提交，使用 temp ts 就能分辨出现在这条 tuple 是否正在被修改：temp ts 是一个很大的数（<code>TXN_START_ID + txn_id</code>，其中 <code>TXN_START_ID = 1LL &lt;&lt; 62</code>），事务的 read ts 和 commit ts 都会小于这个数；在判断一个 tuple 是否可见时，都是通过事务的 read ts（txn.read_ts）与 tuple.meta.ts 进行比较，如果 <code>tuple.meta.ts &lt;= txn.read_ts</code>，那么这个 tuple 对于 txn 是可见的，而如果 <code>tuple.meta.ts == txn.temp_ts</code>，则这个 tuple 正在被 txn 进行修改。</p><p>这样的话，即便是在修改后 <code>tuple.meta.ts</code> 也只是事务的 temp ts，所以在 commit 时，需要将其设置为系统的最新 commit ts。这里需要做几点：</p><ol><li>获取当前系统的 commit ts，计算方式为 <code>last_commit_ts_ + 1</code></li><li>遍历当前要提交的事务的 write set，更新修改了的 tuple 的 meta 数据，将 meta.ts 设置为 commit ts</li><li>设置事务的 commit ts，并且更新系统的 last_commit_ts</li></ol><h3 id=garbagecollection>GarbageCollection<a hidden class=anchor aria-hidden=true href=#garbagecollection>#</a></h3><p>之前一旦我们将事务添加到 txn manager 中，我们就永远不会删除它，因为 read_ts 较小的事务可能需要读取存储在先前已提交或已中止事务中的撤销日志。这里需要实现 <code>TransactionManager::GarbageCollection()</code> 函数，删除未使用的事务。</p><p>一个事务在运行时只需要看到它自己的快照，一旦事务结束，它所依赖的数据版本就可以被考虑回收。<strong>只有当某个数据版本不再被任何活跃事务需要时，才能进行垃圾回收（GC）</strong>。</p><p>举个🌰，假设我们有如下记录：</p><table><thead><tr><th>RID</th><th>ts_</th><th>数据</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>Alice</td></tr><tr><td>A</td><td>2</td><td>Bob</td></tr><tr><td>A</td><td>3</td><td>Charlie</td></tr><tr><td>A</td><td>4</td><td>David</td></tr></tbody></table><p>这表示记录 A 被不同事务更新了四次。现在系统中有三个事务：</p><table><thead><tr><th>事务 ID</th><th>状态</th><th>可见性范围</th></tr></thead><tbody><tr><td>T2</td><td>RUNNING</td><td>ts ≤ 2</td></tr><tr><td>T4</td><td>RUNNING</td><td>ts ≤ 4</td></tr><tr><td>T5</td><td>RUNNING</td><td>ts ≤ 5</td></tr></tbody></table><p>watermark = 2（最小活跃事务 ID）</p><blockquote><p>Q1: T5 能看到 ts_=1 的数据吗？</p></blockquote><p>没问题，因为 T5 的 ts=5 > 1，且事务 1 已完成。</p><blockquote><p>Q2: ts_=1 的数据可以被清理吗？</p></blockquote><p>不可以，因为 T2（ts=2）还在运行，它的可见范围是 ts ≤ 2，所以它可能会访问 ts=1 的数据。</p><blockquote><p>Q3: 如果 T2 提交或中止，watermark 会变成多少？此时 ts=1 的数据能被清理吗？</p></blockquote><ul><li>watermark 更新为 min(4,5) = 4</li><li>此时所有活跃事务的 ts ≥ 4</li><li>所以 ts ≤ 3 的数据都对活跃事务不可见 → 可以安全清理</li></ul><p>这里有一个关键点：<strong>可见 ≠ 不可清理</strong></p><ul><li>可见性：表示某个事务是否能看到某条记录（比如 T5 能看到 ts_=3 的记录）</li><li>清理条件：表示这条记录是否仍然被任何一个活跃事务所需要，如果没有任何活跃事务再访问它，就可以清理</li></ul><p>所以 GC 的步骤可以简单总结如下：</p><ol><li>遍历数据库中所有 tuple</li><li>判断 tuple.ts_ ≤ watermark → 不再被活跃事务访问</li><li>沿着 undo link 遍历 undo log 链</li><li>统计每个事务有多少 undo log 不再被访问</li><li>如果某个事务所有 undo log 都不可见，且事务已完成 → 删除其 undo log 和事务元信息</li></ol><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://blog.csdn.net/weixin_48885685/article/details/143225977>https://blog.csdn.net/weixin_48885685/article/details/143225977</a></li><li><a href=https://github.com/ZepengLi111/cmu15445-2023-fall-bustub>https://github.com/ZepengLi111/cmu15445-2023-fall-bustub</a></li><li>Qwen</li><li>ChatGPT</li></ul></div><footer class=post-footer><nav class=paginav><a class=next href=https://kerolt.github.io/posts/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/><span class=title>Next »</span><br><span>875. 爱吃香蕉的珂珂</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>