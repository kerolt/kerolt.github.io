<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【CMU15-445 Fall2023】Project3 Query Execution 小结 | Kerolt's Blog</title>
<meta name=keywords content="CPlusPlus,Database"><meta name=description content="该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！
这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。
前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：
auto BustubInstance::ExecuteSqlTxn(const std::string &amp;sql, ResultWriter &amp;writer, Transaction *txn, std::shared_ptr<CheckOptions> check_options) -> bool { if (!sql.empty() && sql[0] == '\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement->type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner."><meta name=author content="Kerolt"><link rel=canonical href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.205412d4e3165d21bba592536dfcf65daac7b5defe81eeb19f788d0f805b9eba.css integrity="sha256-IFQS1OMWXSG7pZJTbfz2XarHtd7+ge6xn3iND4Bbnro=" rel="preload stylesheet" as=style><link rel=icon href=https://kerolt.github.io/images/avatar/favicon.jpeg><link rel=icon type=image/png sizes=16x16 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kerolt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/"><meta property="og:site_name" content="Kerolt's Blog"><meta property="og:title" content="【CMU15-445 Fall2023】Project3 Query Execution 小结"><meta property="og:description" content="该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！
这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。
前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：
auto BustubInstance::ExecuteSqlTxn(const std::string &amp;sql, ResultWriter &amp;writer, Transaction *txn, std::shared_ptr<CheckOptions> check_options) -> bool { if (!sql.empty() && sql[0] == '\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement->type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-11T00:00:00+00:00"><meta property="article:tag" content="CPlusPlus"><meta property="article:tag" content="Database"><meta property="og:image" content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【CMU15-445 Fall2023】Project3 Query Execution 小结"><meta name=twitter:description content="该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！
这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。
前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：
auto BustubInstance::ExecuteSqlTxn(const std::string &amp;sql, ResultWriter &amp;writer, Transaction *txn, std::shared_ptr<CheckOptions> check_options) -> bool { if (!sql.empty() && sql[0] == '\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement->type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kerolt.github.io/posts/"},{"@type":"ListItem","position":2,"name":"【CMU15-445 Fall2023】Project3 Query Execution 小结","item":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【CMU15-445 Fall2023】Project3 Query Execution 小结","name":"【CMU15-445 Fall2023】Project3 Query Execution 小结","description":"该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！\n这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。\n前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：\nauto BustubInstance::ExecuteSqlTxn(const std::string \u0026amp;sql, ResultWriter \u0026amp;writer, Transaction *txn, std::shared_ptr\u0026lt;CheckOptions\u0026gt; check_options) -\u0026gt; bool { if (!sql.empty() \u0026amp;\u0026amp; sql[0] == \u0026#39;\\\\\u0026#39;) { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement-\u0026gt;type_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner.","keywords":["CPlusPlus","Database"],"articleBody":" 该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！\n这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。\n前置奶酪 一条 SQL 语句的执行 这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：src/common/bustub_instance.cpp:ExecuteSqlTxn：\nauto BustubInstance::ExecuteSqlTxn(const std::string \u0026sql, ResultWriter \u0026writer, Transaction *txn, std::shared_ptr\u003cCheckOptions\u003e check_options) -\u003e bool { if (!sql.empty() \u0026\u0026 sql[0] == '\\\\') { // 处理元命令 ... } // binder，但是在其中会使用libpg_query来解析sql语句 bustub::Binder binder(*catalog_); binder.ParseAndSave(sql); // 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点 for (auto *stmt : binder.statement_nodes_) { // 将stmt转换成BoundStatement对象，方便后面处理数据 auto statement = binder.BindStatement(stmt); // 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行 switch (statement-\u003etype_) { ... } // 生成初步的执行计划 bustub::Planner planner(*catalog_); planner.PlanQuery(*statement); // 优化刚刚的执行计划 bustub::Optimizer optimizer(*catalog_, IsForceStarterRule()); auto optimized_plan = optimizer.Optimize(planner.plan_); ... // 执行优化后的plan，这里会使用火山模型去根据下面节点的Next函数来执行相应的算子 execution_engine_-\u003eExecute(optimized_plan, \u0026result_set, txn, exec_ctx.get()); // 将执行结果输出至指定位置 ... } return 是否执行成功;\t} 在 binder 之后，我们就有了一条 sql 的语句解析节点，例如执行 select * from (select * from test_2 where colA \u003e 10) where colB \u003e 2;，其 statement node 如下：\nBoundSelect { table=BoundSubqueryRef { alias=__subquery#0, subquery=BoundSelect { table=BoundBaseTableRef { table=test_2, oid=23 }, columns=[\"test_2.colA\", \"test_2.colB\", \"test_2.colC\"], groupBy=[], having=, where=(test_2.colA\u003e10), limit=, offset=, order_by=[], is_distinct=false, ctes=, }, columns=[\"test_2.colA\", \"test_2.colB\", \"test_2.colC\"], }, columns=[\"__subquery#0.test_2.colA\", \"__subquery#0.test_2.colB\", \"__subquery#0.test_2.colC\"], groupBy=[], having=, where=(__subquery#0.test_2.colB\u003e2), limit=, offset=, order_by=[], is_distinct=false, ctes=, } 其中的子查询和 where 的条件还有需要哪些列都能非常清楚的看到。\nIterator Model 通常一个 SQL 会被组织成树状的查询计划，数据从叶子节点流到根节点，查询结果在根节点中得出。\nbustub 中采用的数据库查询执行模型叫做迭代器模型，也叫火山模型。\n查询计划（query plan）中的每步 operator 对应的 executor 都实现一个 next 函数，每次调用时，operator 返回一个 tuple 或者 null，后者表示数据已经遍历完毕。operator 本身实现一个循环，每次调用其 child operators 的 next 函数，从它们那边获取下一条数据供自己操作，这样整个 query plan 就被从上至下地串联起来。\n但是像 Joins, Aggregates, Subqueries, Order By 这样的操作需要等所有 children 返回它们的 tuple。虽然一次调用请求一条数据，占用内存较小，但函数调用开销大。\nCatalog, Table and Index 下图出处：https://www.cnblogs.com/joey-wang/p/17351258.html\n索引 index 在 Bustub 中，索引用于加速数据访问。索引通过维护表中数据的有序结构，使得查询可以更快地定位到所需的记录。\n结构 索引的结构图和上面表的结构图类似。在 catalog 中，可以获取到一个表对应的所有IndexInfo，每个 IndexInfo 中包含着这个索引的信息，这里讲两个个我认为比较重要的成员变量：\nkey_schema_：索引对应的列的结构，例如使用其 ToString() 函数时，其会返回 (添加了索引的列的名称:该列的数据类型) index_：这是一个指针，指向一个 Index 类的对象，也就是真正的索引 // catalog.h class Catalog { public: template \u003cclass KeyType, class ValueType, class KeyComparator\u003e auto CreateIndex(Transaction *txn, const std::string \u0026index_name, const std::string \u0026table_name, const Schema \u0026schema, const Schema \u0026key_schema, const std::vector\u003cuint32_t\u003e \u0026key_attrs, std::size_t keysize, HashFunction\u003cKeyType\u003e hash_function, bool is_primary_key = false, IndexType index_type = IndexType::HashTableIndex) -\u003e IndexInfo *; auto GetIndex(const std::string \u0026index_name, const std::string \u0026table_name) -\u003e IndexInfo *; auto GetIndex(const std::string \u0026index_name, const table_oid_t table_oid) -\u003e IndexInfo *; auto GetIndex(index_oid_t index_oid) -\u003e IndexInfo *; auto GetTableIndexes(const std::string \u0026table_name) const -\u003e std::vector\u003cIndexInfo *\u003e; ... private: ... /** * Map index identifier -\u003e index metadata. * * NOTE: that `indexes_` owns all index metadata. */ std::unordered_map\u003cindex_oid_t, std::unique_ptr\u003cIndexInfo\u003e\u003e indexes_; /** Map table name -\u003e index names -\u003e index identifiers. */ std::unordered_map\u003cstd::string, std::unordered_map\u003cstd::string, index_oid_t\u003e\u003e index_names_; /** The next index identifier to be used. */ std::atomic\u003cindex_oid_t\u003e next_index_oid_{0}; }; struct IndexInfo { ... /** The schema for the index key */ Schema key_schema_; /** The name of the index */ std::string name_; /** An owning pointer to the index */ std::unique_ptr\u003cIndex\u003e index_; /** The unique OID for the index */ index_oid_t index_oid_; /** The name of the table on which the index is created */ std::string table_name_; /** The size of the index key, in bytes */ const size_t key_size_; /** Is primary key index? */ bool is_primary_key_; /** The index type */ [[maybe_unused]] IndexType index_type_{IndexType::BPlusTreeIndex}; }; Index 中有着三个虚函数供其派生类去实现，其唯一的成员变量的类型为 IndexMeta，用来存储一些元信息，例如这个索引的名称，它所属的表的名称，最重要的还有一个 key_attrs_，稍后就说谈论它。\n// index.h class IndexMeta { ... private: /** The name of the index */ std::string name_; /** The name of the table on which the index is created */ std::string table_name_; /** The mapping relation between key schema and tuple schema */ const std::vector\u003cuint32_t\u003e key_attrs_; /** The schema of the indexed key */ std::shared_ptr\u003cSchema\u003e key_schema_; /** Is primary key? */ bool is_primary_key_; }; class Index { ... private: /** The Index structure owns its metadata */ std::unique_ptr\u003cIndexMetadata\u003e metadata_; }; fall2023 我们使用的是哈希索引，底层使用的就是在 project2 中实现的可拓展哈希。\n// extendible_hash_table_index.h #define HASH_TABLE_INDEX_TYPE ExtendibleHashTableIndex template \u003ctypename KeyType, typename ValueType, typename KeyComparator\u003e class ExtendibleHashTableIndex : public Index { public: ExtendibleHashTableIndex(std::unique_ptr\u003cIndexMetadata\u003e \u0026\u0026metadata, BufferPoolManager *buffer_pool_manager, const HashFunction\u003cKeyType\u003e \u0026hash_fn); ~ExtendibleHashTableIndex() override = default; auto InsertEntry(const Tuple \u0026key, RID rid, Transaction *transaction) -\u003e bool override; void DeleteEntry(const Tuple \u0026key, RID rid, Transaction *transaction) override; void ScanKey(const Tuple \u0026key, std::vector\u003cRID\u003e *result, Transaction *transaction) override; protected: // comparator for key KeyComparator comparator_; // container DiskExtendibleHashTable\u003cKeyType, ValueType, KeyComparator\u003e container_; }; 更新索引 当插入新记录时，不仅需要将记录插入到表中，还需要将相应的索引条目插入到索引中。这样，后续的查询操作可以利用索引快速定位到目标记录。如果不更新索引，后续的查询操作可能会错过新插入的记录，导致查询结果不准确。\nUPDATE 和 DELETE 如何影响索引？\nUPDATE\n✅ 需要更新索引的情况：修改了索引列 的值（例如：将 id=100 的 name 字段从 “Alice” 改为 “Bob”，而 name 被建了索引）\n此时旧索引项（“Alice”）需要被删除 新索引项（“Bob”）需要被插入 ❌ 不需要更新索引的情况：修改的是非索引列\n例如：age 字段没有被索引，修改它不会影响索引 DELETE\n无论删除哪一行，只要该行在某个索引中存在，就需要从索引中删除对应的条目 。\nbustub 中有哈希索引和 B+Tree 索引，fall2023 版本使用的是可拓展哈希作为作为索引。不过这两个具体的实现都有一个基类 Index，其中有以下虚函数需要子类去实现：\nInsertEntry(const Tuple \u0026key, RID rid, Transaction *transaction): 插入一个索引条目。 DeleteEntry(const Tuple \u0026key, RID rid, Transaction *transaction): 删除一个索引条目。 ScanKey(const Tuple \u0026key, std::vector *result, Transaction *transaction): 根据索引键搜索记录，并将结果 RID 存储在指定的向量中。 所以不管用的是哈希还是 B+Tree，在操作索引时用的接口都相同。\n如何理解索引 就如网上很多介绍索引的博客所描述的那样，数据库索引是用来加速检索速度的，就如同新华字典中的音节索引一样：\n如同 table_info，catalog 中也有许多的 index_info，每个 index_info 就如同上图音节表中的一个字母。我们对一个字段（列）构建一个索引，就如同在上图中音节表中多加一个字母（例如 X）。\n需要插入一条记录时，就往对应的索引下插入 (记录， 对应记录的地址) 这样的键值对，例如上图的 (xian, 519)，这里的地址为 RID。 需要删除一条记录时，在对应的索引下删掉匹配的键值对。 需要更新一条记录时，由于 bustub 没有提供更新索引的 API，所以可以用先删除再插入的方式模拟更新。 执行器如何使用索引获取数据 当执行器需要从表中获取数据时，如果查询计划中包含索引扫描操作，执行器会通过索引来快速定位数据。以下是具体的步骤：\n解析查询计划： 执行器根据查询计划确定需要使用的索引。 获取索引的元数据，包括索引键的模式和表列的映射关系。 构建索引键： 根据查询条件和索引的元数据，构建索引键。这通常涉及到从查询条件中提取列值，并根据索引键的模式进行转换。 使用索引进行搜索： 调用索引的 ScanKey 方法，传入构建好的索引键和一个结果 RID 向量。 索引会根据键值查找对应的记录，并将找到的 RID 存储在结果向量中。 读取数据页： 使用结果向量中的 RID，从缓冲池中查找对应的页。如果页不在缓冲池中，则从磁盘加载到缓冲池。 从页中读取数据并创建 Tuple 对象。 处理和返回结果： 使用 Tuple 对象的方法（如 GetValue、IsNull 等）访问和处理元组中的数据。 将处理后的数据作为结果返回给用户或进一步处理。 谓词下推 谓词下推（Predicate Pushdown）是数据库查询优化中的一种技术，其核心思想是将查询中的过滤条件（即谓词）尽可能早地应用到查询执行计划的底部，也就是数据生成的地方。这样做的目的是为了减少数据的传输量和处理量，从而提高查询效率。\n具体来说，谓词下推包括以下几个方面：\n过滤条件前移：在查询执行的过程中，尽早地对数据进行过滤，这样不需要将所有数据都传递到上层操作中，只传递满足条件的数据。 减少数据传输：通过在数据生成的阶段就进行过滤，可以减少从数据库存储引擎到查询处理引擎之间的数据传输量。 减少 CPU 处理：不需要对所有数据进行后续的处理，只需要处理已经过滤的数据，这样可以减少 CPU 的工作量。 利用索引：如果过滤条件可以利用现有的索引，谓词下推可以使得查询直接利用索引来快速定位数据，而不是扫描整个表。 优化查询计划：数据库优化器会根据谓词下推的原则重新规划查询的执行步骤，生成更高效的查询计划。 例如：\nSELECT * FROM employees WHERE department_id = 5 AND salary \u003e 50000; 在这个查询中，WHERE 子句包含了两个过滤条件。如果不进行谓词下推，数据库可能会先扫描整个 employees 表，然后将所有行传递给上层操作，之后再应用过滤条件。而通过谓词下推，数据库可以在扫描表的时候直接应用这些过滤条件，只返回部门 ID 为 5 且薪资大于 50000 的员工记录。\n谓词下推是数据库查询优化中非常重要的一环，它有助于提高查询性能，特别是在处理大规模数据集时。数据库优化器会尝试自动应用谓词下推，但有时开发者也可以通过编写更优化的查询条件来帮助优化器更好地进行谓词下推。\nTask1 - Access Method Executors SeqScan 顺序扫描指定的表，表的遍历可以使用 TableIterator。\n每次找到一条没有被标记为“删除”或者不是 where 之类的过滤子句匹配（这里会在 delete 操作中说明）的 tuple（记录）就并返回，如果已经扫描到了表的结束位置则返回 false。\nInsert 为什么 Insert 等 Executor 有 child 而 SeqScan 没有？ InsertExecutor 的主要职责是将一条或多条记录插入到指定的表中。它可能需要依赖于其他 Executor 来获取要插入的数据。例如，如果 INSERT 操作是从一个 SELECT 查询的结果集中插入数据，那么 InsertExecutor 可能会有一个子 Executor（如 SeqScanExecutor 或其他类型的 Executor），该子 Executor 负责执行 SELECT 操作并提供数据给 InsertExecutor。\n因此，InsertExecutor 有 child 是因为它可能需要从另一个查询的结果中获取数据。\nSeqScanExecutor 的主要职责是对表进行全表扫描，即按顺序读取表中的所有记录。这是一个基本的操作，通常不需要其他 Executor 的支持来完成其工作。\n它直接作用于存储层，遍历表中的每一行数据，因此没有子 Executor。它的任务相对简单，就是遍历和返回表中的所有记录。\n简而言之，InsertExecutor 需要 child 是因为它的操作可能涉及从其他查询结果中获取数据，而 SeqScanExecutor 不需要 child 是因为它的任务是独立完成的，只需遍历表中的所有记录即可。这反映了数据库执行计划中不同操作之间的依赖关系和交互方式。其他 Executor 同理。\n举个批量插入的🌰：\n假设我们有一个 orders 表，包含以下列：\norder_id (主键) customer_id product_id quantity order_date 我们希望通过一个子查询（select）来获取一批订单记录，并将这些记录插入到 orders 表中：\nINSERT INTO orders (customer_id, product_id, quantity, order_date) SELECT customer_id, product_id, quantity, order_date FROM pending_orders WHERE status = 'approved'; 很明显，我们在插入之前要从 select 子句中获取数据，因此这个子查询操作就是 insert 操作的 child_executor。\n没有子操作时，需要插入的数据从哪里获取？ 比如执行如下 SQL 时：\ninsert into test_1 values (202, 1, 2, 3); 从肉眼看可以知道需要插入的数据为 (202, 1, 2, 3)，但是在代码中又是从哪里获取的呢？\n让我们使用一下 explain 工具来看看这条 SQL 语句在 bustub 内部做了什么：\nbustub\u003e explain insert into test_1 values (202, 1, 2, 3); === BINDER === BoundInsert { table=BoundBaseTableRef { table=test_1, oid=22 }, select= BoundSelect { table=BoundExpressionListRef { identifier=__values#0, values=[[\"202\", \"1\", \"2\", \"3\"]] }, columns=[\"__values#0.0\", \"__values#0.1\", \"__values#0.2\", \"__values#0.3\"], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } } === PLANNER === Insert { table_oid=22 } | (__bustub_internal.insert_rows:INTEGER) Projection { exprs=[\"#0.0\", \"#0.1\", \"#0.2\", \"#0.3\"] } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) Values { rows=1 } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) === OPTIMIZER === Insert { table_oid=22 } | (__bustub_internal.insert_rows:INTEGER) Values { rows=1 } | (__values#0.0:INTEGER, __values#0.1:INTEGER, __values#0.2:INTEGER, __values#0.3:INTEGER) 将目标聚焦在生成的查询计划上，从上到下，在一个 Insert 的查询计划中，使用 Projection 从其输入源（如表扫描、索引扫描、连接等）中提取所需的列，最下层使用 Value 获取到要操作的数据！\n所以对应的，InsertExecutor 的 child_executor 为 ProjectionExecutor，而 ProjectionExecutor 的 child_executor 为 ValuesExecutor，使用迭代器模型就能很方便的获取到数据了（ValuesExecutor 就是最后的 Executor，其 Next 函数不会再往下调用，其所做的只是根据在解析 SQL 及其之后的一些步骤中得到的需要操作的数据封装成一个 tuple 进行返回）。\nDelete 需要写的代码和 insert 操作的基本相同。但有个地方需要注意一下，在执行一条 delete 语句时，让我们看看做了些什么：\nbustub\u003e explain delete from test_1 where colA = 999; === BINDER === Delete { table=BoundBaseTableRef { table=test_1, oid=22 }, expr=(test_1.colA=999) } === PLANNER === Delete { table_oid=22 } | (__bustub_internal.delete_rows:INTEGER) Filter { predicate=(#0.0=999) } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) === OPTIMIZER === Delete { table_oid=22 } | (__bustub_internal.delete_rows:INTEGER) SeqScan { table=test_1, filter=(#0.0=999) } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) 可以看到，在 optimizer 阶段，where 子句的 filter 下放至 SeqScan 处与其合并了，也就是说，我们需要在实现 SeqScanExecutor 时注意处理一下 filter。这里提示一下：\nwhile (cur_tuple.first.is_deleted_ || (plan_-\u003efilter_predicate_ \u0026\u0026 !(plan_-\u003efilter_predicate_-\u003eEvaluate(tuple, GetOutputSchema()).GetAs\u003cbool\u003e()))) 如果其返回 true，说明 filter 匹配到了数据（就如例子中匹配到了 colA 列为 999 的 tuple），如果此时这个 tuple 没有被标记为删除，那么就说明找到了我们需要删除的 tuple。\nUpdate 我们如何知道 update 需要更新的数据从哪里取呢？\nbustub\u003e explain(p, o) update test_1 set colB = 15445; === PLANNER === Update { table_oid=22, target_exprs=[\"#0.0\", \"15445\", \"#0.2\", \"#0.3\"] } Filter { predicate=true } SeqScan { table=test_1 } === OPTIMIZER === Update { table_oid=22, target_exprs=[\"#0.0\", \"15445\", \"#0.2\", \"#0.3\"] } SeqScan { table=test_1, filter=true } 看看 Update 中，有一个 target_exprs 数组，这个数组可不就是我们的一行数据吗，并且是需要更新的那行数据：update 语句可以不加 where 子句，这样就是选中表中的所有行，也就是这里将表中 colB 列的数据都 update 为 15445！\n对于 target_exprs 这个数组，我们可以通过 plan_-\u003etarget_expressions_ 获取，然后用其构建一个新的 tuple。\n需要注意的是，这里并没有提供直接更新 tuple 的操作，所以我们的 update 操作可以用先删除后插入的方式来模拟。\nIndexScan 我们首先需要完成 OptimizeSeqScanAsIndexScan 这个优化步骤。\n假设现在我们有一个表叫“test_1”，其列如下：\n+-------------+-------------+-------------+-------------+ | test_1.colA | test_1.colB | test_1.colC | test_1.colD | +-------------+-------------+-------------+-------------+ 现在我们希望这条 SQL 能执行的更快：\nselect * from test_1 where colB = 11; 那比较不错的方法就是给 colB 列加上索引：\ncreate index v1 on test_1(colB); 这样在执行时可以更快速的查找数据。\n那么为了实现这一目标，我们需要通过 OptimizeSeqScanAsIndexScan 将 plan 树中的 SeqScanPlanNode 转换成 IndexScanPlanNode，这样我们才能使用 IndexScanPlanNode 对应的算子 —IndexScanExecutor 去使用索引。但是由于 bustub 的一些设计，需要遵循以下规则才可以转化：\n当前的节点的类型必须是 PlanType::SeqScan 当前节点必须有 filter 谓词，如果只是 select * from test_1; 这样的是不需要使用索引的 当前表中必须有索引，没有索引还玩啥呢 fileter 谓词中的逻辑表达式只能有一个，并且其类型必须是 ComparisonType::Equal（我想这里必须是“等于”是不是因为 fall2023 使用的索引是哈希索引） 在当前表的索引信息中找到与 filter 谓词相对应的索引后才能返回一个 IndexScanPlanNode 在 select * from test_1 where colB = 11; 中，加了索引后，最需要关注的就是 where colB = 11 这一个过滤条件。bustub 中要求 IndexScan 过滤运算符必须是 =，且只能有一个条件。如果 colA 和 colB 都是索引，然后执行 select * from test_1 where colB = 11 and colA = 1;，这样是不会走索引优化的。\n我们将查询计划中的过滤谓词转化成 ComparisonExpression 类型，据我的理解，其可通过 GetChildAt 函数获取比较谓词左边的列名表达式（即这里的“colB”，有了这个列名的表达式，我们就可以获取到这个列的 col_id 值）和右边的值（即“11”）。之后需要去这张表中的所有索引中去找是否有 colB 的索引，怎么确定是否有呢，那就要看这个表中的每个 Index 的 key_attrs_：\n在 Index 中，key_attrs_ 决定了索引的关键字由哪些列组成，对应了每个列的下标。例如：\n如果表的 schema 定义有 5 列，分别为 A, B, C, D, E。 某个索引的 key_attrs_ 是 [0, 2]，则表示该索引使用了第 0 列（A）和第 2 列（C）作为其关键字。 如果之前我们获取的列的 col_id 值和某个 Index 的 key_attrs_ 中的值相同，那么就存在相应的索引！这时构造一个 IndexScanPlanNode 返回即可（参考 merge_filter_scan.cpp 中是如何做的）。\n当优化器成功更换节点后，在执行时就会走索引，其底层算子就会使用到 IndexScanExecutor。到这里，这个算子需要做的事情就很简单了，就是调用哈希索引的 ScanKey 进行查找，不过这里有 3 点需要注意：\n在 project2 中，我们实现的索引引擎只支持一个键对应一个值（不只是这个版本的可拓展哈希，其他版本中的 B+Tree 也只要求这样实现），也就是我们的这个算子在底层索引引擎不扩展的情况下最多查到一条记录，这样的话就可以在算子的 Init 函数中调用 ScanKey 查找记录就行。 可拓展哈希中是将一个 Tuple 的 data 转化一下当作 key，所以在索引中，其是将索引列的值作为 key，其对应的 oid 作为值。在使用 ScanKey 时，第一个参数需要的 tuple 将用查询计划节点 IndexScanPlanNode 中的 pred_key_ 构造。 表中的 tuple 的元数据中，其 is_deleted_ 可能为 true，这说明这个 tuple 在逻辑上已经删除了，所以如果我们通过 2 中获取的 oid 对应的 tuple 是这种情况，就不用向上返回数据。 Task2 - Aggregation \u0026 Join Executors Aggregation 分析一个例子：\nbustub\u003e EXPLAIN SELECT MAX(colC), MIN(colB) FROM test_1 GROUP BY colA HAVING MAX(colB) \u003e 10; === BINDER === BoundSelect { table=BoundBaseTableRef { table=test_1, oid=22 }, columns=[\"max([\\\"test_1.colC\\\"])\", \"min([\\\"test_1.colB\\\"])\"], groupBy=[\"test_1.colA\"], having=(max([\"test_1.colB\"])\u003e10), where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\"#0.2\", \"#0.3\"] } | (\u003cunnamed\u003e:INTEGER, \u003cunnamed\u003e:INTEGER) Filter { predicate=(#0.1\u003e10) } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) Agg { types=[\"max\", \"max\", \"min\"], aggregates=[\"#0.1\", \"#0.2\", \"#0.1\"], group_by=[\"#0.0\"] } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) === OPTIMIZER === Projection { exprs=[\"#0.2\", \"#0.3\"] } | (\u003cunnamed\u003e:INTEGER, \u003cunnamed\u003e:INTEGER) Filter { predicate=(#0.1\u003e10) } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) Agg { types=[\"max\", \"max\", \"min\"], aggregates=[\"#0.1\", \"#0.2\", \"#0.1\"], group_by=[\"#0.0\"] } | (test_1.colA:INTEGER, agg#0:INTEGER, agg#1:INTEGER, agg#2:INTEGER) SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER) 对于 AggregationExecutor，我们可以获取到 SQL 语句中：\n聚合操作的 types（进行聚合操作的类型）和 aggregates（需要聚合操作的列），二者一一对应 需要 group by 进行分组的列 再看看 lecture 中的这个例子，其对列 cid 使用 group by 进行分组，其中涉及的聚合操作为 AVG，可转换成 COUNT 和 SUM 操作。这里相当于：\ntypes = ['count', 'sum'] aggregates = ['s.gpa', 's.gpa'] 我的理解是根据 group by 的字段的值进行 hash 函数处理作为哈希表的键，例如图中的“15-445”，“15-826”等；然后哈希表的值为一个集合，这个集合的大小和 types 和 aggregates 的大小相同，并且对应的位置就为 aggregates 的值：例如图中键“15-445”的值中，第一个元素就为 COUNT 操作下 s.gpa 为 15-445 的个数。\n在 lab 中需要实现 count、sum、max、min 操作，其实就是在 SimpleAggregationHashTable：：CombineAggregateValues 中实现对应的操作即可，本质上是对哈希表的几个很简单的操作。\naggregation 通常需要对一组数据进行计算，这些计算具有以下特点：\n需要完整输入：Aggregation 通常需要从下层拉取所有相关数据才能计算结果，例如计算 SUM 需要遍历所有行。 阻塞性：在传统实现中，Aggregation 算子通常被称为“阻塞算子”，因为它必须等待所有输入数据都拉取完成才能产出结果。这意味着 next() 调用会被延迟，直到聚合计算完成。 在我们的火山模型中 aggregation 是阻塞算子：\n当上层算子调用 next() 时，aggregation 会向下层算子连续调用 next()，直到拉取完全部数据并完成聚合。 在数据尚未完全拉取并聚合完成之前，上层的 next() 调用无法直接返回结果。 需要注意的是：\nSQL 中进行 group by 后使用 count，统计的是每组数据中的记录数，而非分组后新表的行数。 distinct 其实就是对某个字段进行 group by 操作 count(*) 统计 null，而 count(字段) 不统计 null NestedLoopJoin Inner Join：\nbustub\u003e EXPLAIN SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE; === BINDER === BoundSelect { table=BoundCrossProductRef { left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 } }, columns=[\"__mock_table_1.colA\", \"__mock_table_1.colB\", \"__mock_table_3.colE\", \"__mock_table_3.colF\"], groupBy=[], having=, where=(__mock_table_1.colA=__mock_table_3.colE), limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\"#0.0\", \"#0.1\", \"#0.2\", \"#0.3\"] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) Filter { predicate=(#0.0=#0.2) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Inner, predicate=true } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) bustub\u003e EXPLAIN SELECT * FROM __mock_table_1 INNER JOIN __mock_table_3 ON colA = colE; === BINDER === BoundSelect { table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 }, condition=(__mock_table_1.colA=__mock_table_3.colE) }, columns=[\"__mock_table_1.colA\", \"__mock_table_1.colB\", \"__mock_table_3.colE\", \"__mock_table_3.colF\"], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\"#0.0\", \"#0.1\", \"#0.2\", \"#0.3\"] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) 可以看到，即便我们不加 inner join，默认情况下也是使用的 Inner Join：NestedLoopJoin 中的 type 均为 Inner。\nLeft Join：\nbustub\u003e EXPLAIN SELECT * FROM __mock_table_1 LEFT OUTER JOIN __mock_table_3 ON colA = colE; === BINDER === BoundSelect { table=BoundJoin { type=Left, left=BoundBaseTableRef { table=__mock_table_1, oid=0 }, right=BoundBaseTableRef { table=__mock_table_3, oid=2 }, condition=(__mock_table_1.colA=__mock_table_3.colE) }, columns=[\"__mock_table_1.colA\", \"__mock_table_1.colB\", \"__mock_table_3.colE\", \"__mock_table_3.colF\"], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } === PLANNER === Projection { exprs=[\"#0.0\", \"#0.1\", \"#0.2\", \"#0.3\"] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) NestedLoopJoin { type=Left, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) === OPTIMIZER === NestedLoopJoin { type=Left, predicate=(#0.0=#1.0) } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER, __mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) MockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER) MockScan { table=__mock_table_3 } | (__mock_table_3.colE:INTEGER, __mock_table_3.colF:VARCHAR) 由于火山模型中的 Next 每次返回一条 tuple，所以我们需要在 Init 中得到 join 后的所有 tuple。Nested Loop Join 其实就是用两个 for 循环去遍历两张表，保存满足筛选条件的 tuple。\ninner join 只会返回两个表中满足连接条件的 tuple；而 left join 会返回左表中的所有记录，以及右表中满足条件的 tuple。所以在嵌套 for 循环中，如果右表中有未能满足条件的 tuple，那么就保存左表中的每一列的值，并且加上右表中每一列的 null 值。\nTask3 - HashJoin Executor and Optimization 为什么需要 hash join 呢？如果两张要进行 join 的表非常大，这时使用 NLJ 的时间复杂度就为 O(n*m)，但是如果我们使用 hash join，先对一张表建立哈希映射，然后再对另一张表进行哈希检测来判断是否满足连接条件，这样就只要各扫描一次两张表，时间复杂度就降为了 O(n+m)。\n将 NL Join 优化为 Hash Join 实验指导中说，优化器需要将 nl join 优化为 hash join 的情况为：连接条件中有多个等值 AND 操作，即 x = y AND a = b AND ...。那我们只要在碰到 NestedLoopPlanNode 时获取其谓词，判断一下是否满足该情况就好了。\n需要注意的是，当谓词仅为 a = b 时，这个谓词是一个 ComparationExpression；而当它为 x = y AND a = b AND ... 时，它是一个 LogicExpression。这里在判断的是否需要区分，而在之前的实验中，有学习到可以使用标准库中的 std::dynamic_pointer_cast 函数来将谓词从 Expression基类 转换为指定的 Expression派生类，当转换失败时，会返回空指针，这样我们可以通过返回的指针来判断是否是想要的 Expression，如果为空，就代表是另一个 Expression。\n由于谓词中很有可能是 LogicExpression 嵌套着 LogicExpression 和 ComparationExpression，数量也不确定，且子 LogicExpression 很可能还有嵌套，这样的话使用递归来处理就非常方便。\n实现 Hash Join hash join 的核心就是：先对一张表建立哈希映射，然后再对另一张表进行哈希检测来判断是否满足连接条件。哈希表中的 key 为连接条件中对应的值的拼接，value 为整个 tuple。而一张表中的所有 tuple，很有可能会有几个列是完全相同的，如果这些列刚好作为连接条件，那进行哈希时就会造成 key 相同的情况，这就造成了哈希碰撞。\n解决方法也很简单：\n使用 std::unordered_map，将拼接的列值作为 key，而值的类型为 std::vector; 使用 std::unordered_multimap 来处理。 当我们构建好哈希表后，每次获取了另一张表中的 tuple 后进行一次哈希检测，如果 key 存在，需要将所有 value 都进行连接拼接。同 nested loop join 一样，需要特殊处理连接类型为 left 的情况。\nTask4 - Sort + Limit Executors + Window Functions + Top-N Optimization Sort 这个算子的实现思路很简单，但是需要注意两点：\norder by 后面可以跟多个关键字，也就是需要在 std::sort 中对多个关键字进行排序（利用 for 循环）。 这些关键字中可能进行算数运算（算数对象类型为 ArithmeticExpression，搞清楚进行运算的函数就可）。 Limit 这个就更简单了，根据 limit 的返回对应数量的 tuple。\nTopN topn 算子的优化只有 sort 和 limit 同时出现的是否才会触发，这里的优化逻辑比较简单。\n而具体的算子的实现其实就是一个优先队列。举个例子，现在 tuple 按照某个关键字升序排列，并且 limit 为 10，那么就可以构造一个小根堆，并维护其大小最多为 10，最后留在堆中的就是结果。如果力扣刷了一点题的话很容易就能理解这里。\nWindow Function 说来惭愧，学 SQL 的时候并不知道窗口函数这个东西…简单来理解，就是在使用聚合函数的后面加上 over ([可选操作]) 即可对区间进行聚合操作。\n对于下面的 SQL，最后输出的 schema 应该和 WindowFunc.columns 相同，并且行数也和子 executor 返回的行数相同（下文将子 executor 返回的 tuple 称为 child_tuples），只是多了一些额外的计算列。\nbustub\u003e explain(o) select v1, min(v1) over () as min_v1, max(v1) over () as max_v1, count(v1) over () as count_v1, sum(v1) over () as sum_v1 from t1; === OPTIMIZER === WindowFunc { columns=#0.0, placeholder, placeholder, placeholder, placeholder, , window_functions={ 1=\u003e{ function_arg=#0.0, type=min, partition_by=[], order_by=[] }, 2=\u003e{ function_arg=#0.0, type=max, partition_by=[], order_by=[] }, 3=\u003e{ function_arg=#0.0, type=count, partition_by=[], order_by=[] }, 4=\u003e{ function_arg=#0.0, type=sum, partition_by=[], order_by=[] } } } SeqScan { table=t1 } 在这条 SQL 中，返回的 tuple 的格式应该为：\n这条 tuple 的 v1 列的值 所有 tuple 中最小的 v1 的值 所有 tuple 中最大的 v1 的值 所有 tuple 中 v1 的个数 所有 tuple 中 v1 的值的和 这其实和 WindowFunc.columns 有很大的关系，placeholder 说明这只是个占位符，其应该为 window_functions[下标] 对应的窗口函数。例如第二个 placeholder 在 columns 的下表为 1，其对应的窗口函数就是 { function_arg=#0.0, type=min, partition_by=[], order_by=[] }。那么就可以通过 column 来找到每个窗口对应的哈希表。\n️需要注意的是：\n如果按照 ORDER BY 进行排序后，每一行的窗口范围从第一行开始扩展到当前行 否则每一行的窗口范围是整个 child_tuples 既然如此，我们需要先从 child_executor 获取到所有的 child_tuples，然后对 child_tuples 遍历：如果有分组行为，那就需要按照某一列（或多列）进行分组，然后对于每一个 tuple，都让其执行一次 WindowFunc.window_functions 中的窗口函数。\n稍有不同的是，之前的 aggregation 操作分组后可能需要完成多个聚合函数，但是这里我们分组之后，只会完成一个聚合函数，因为每个窗口中只有一个聚合函数。\n现在看来，这个窗口函数也无非就是对某个范围内的 tuple 进行分组和聚合操作，实验指导中也提示我们可以去利用 task2 中写的代码。在我的实现方案中，并不像 task2 中只使用一个哈希表，因为在一条 SQL 函数中，可能有多个窗口函数，每一个窗口函数又可能又不同的分组和不同的聚合操作，因此我对于每一个窗口函数都设置了一个哈希表。\n该 task 中 bustub 很仁慈地简化了难度：如果窗口函数任意一个中有 order by，那么所有窗口函数的 order by 都相同。不过在有排序和没有排序的情况下，窗口的范围有所不同，处理起来的方法也不同。\n无排序的情况 这个情况下，每个窗口函数的范围就是整个 child_tuples。之后再次遍历每一条 tuple，按照输出的 schema 来构建返回的 tuple。那么实现操作应该如下：\n先描所有 tuple，生成这条 tuple 对应的 key 和 value，再把 key 和 value 加入对应的哈希表。\n然后对于每一条 tuple，遍历 WindowFunc.columns：\n如果 column 不是 placeholder，那么说明这个位置是这个 tuple 中的一列，获取这一列对应的 Value 就好。 如果 column 是 placeholder，那么说明这个位置的值应该是对应的窗口函数的执行结果，那么从 column 对应的哈希表中找出这个 tuple 对应的值就 ok。 有排序的情况 在这个情况下，排序号后每条 tuple 的范围是自身及之前的所有 tuple，而不是像之前一样的所有 tuple。这就有点像一句话：“走一步看一步”。\n还是遍历每一条 tuple，对每一条 tuple 又遍历 WindowFunc.columns：\n如果 column 不是 placeholder，那么说明这个位置是这个 tuple 中的一列，获取这一列对应的 Value 就好。这里和无排序的情况一致。 如果 column 是 placeholder， 生成这条 tuple 对应的 key 生成这条 tuple 对应的 value，并将 {key, value} 插入 column 对应的哈希表（在 task2 中可知，这里的“插入”其实是对 key 处的旧值 old_value 与新值 value 进行聚合操作） 从哈希表中取出 key 对应的 value 这里的 2.2 和 2.3 就是之前所说的“走一步看一步”：当前 tuple 的结果是在之前的 tuple 上聚合而来的。\n总结 这个 Project 需要我们去深入理解 bustub 的源码，知道一条 SQL 会被解析成一棵什么样的 plan 树，在经过基于规则的优化器优化后才会是最终的物理 plan 树，这时又要去理解这棵树上每个节点对应的算子应该是怎么实现的。其实知道了 plan 树是什么样子后，节点对应的算子就按照要求去设计就好了。\n在众多 AI 例如 ChatGPT、DeepSeek、Kimi 等帮助下，还是慢慢理解并完成了这个 Project！但是有的地方我可能还没有做的比较好，以后有时间再优化一下。\n","wordCount":"2423","inLanguage":"en","image":"https://kerolt.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-11T00:00:00Z","dateModified":"2025-03-11T00:00:00Z","author":{"@type":"Person","name":"Kerolt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kerolt.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/cmu15-445-fall2023project3-query-execution-%E5%B0%8F%E7%BB%93/"},"publisher":{"@type":"Organization","name":"Kerolt's Blog","logo":{"@type":"ImageObject","url":"https://kerolt.github.io/images/avatar/favicon.jpeg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kerolt.github.io/ accesskey=h title="Kerolt's Blog (Alt + H)">Kerolt's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kerolt.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://kerolt.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://kerolt.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://kerolt.github.io/about/ title=关于我><span>关于我</span></a></li><li><a href=https://kerolt.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">【CMU15-445 Fall2023】Project3 Query Execution 小结</h1><div class=post-meta><span title='2025-03-11 00:00:00 +0000 UTC'>2025-03-11</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2423 words&nbsp;·&nbsp;Kerolt</div><ul class=post-tags><li><a href=https://kerolt.github.io/tags/cplusplus/>CPlusPlus</a></li><li><a href=https://kerolt.github.io/tags/database/>Database</a></li></ul></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e7%bd%ae%e5%a5%b6%e9%85%aa aria-label=前置奶酪>前置奶酪</a><ul><li><a href=#%e4%b8%80%e6%9d%a1-sql-%e8%af%ad%e5%8f%a5%e7%9a%84%e6%89%a7%e8%a1%8c aria-label="一条 SQL 语句的执行">一条 SQL 语句的执行</a></li><li><a href=#iterator-model aria-label="Iterator Model">Iterator Model</a></li><li><a href=#catalog-table-and-index aria-label="Catalog, Table and Index">Catalog, Table and Index</a></li><li><a href=#%e7%b4%a2%e5%bc%95-index aria-label="索引 index">索引 index</a><ul><li><a href=#%e7%bb%93%e6%9e%84 aria-label=结构>结构</a></li><li><a href=#%e6%9b%b4%e6%96%b0%e7%b4%a2%e5%bc%95 aria-label=更新索引>更新索引</a></li><li><a href=#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e7%b4%a2%e5%bc%95 aria-label=如何理解索引>如何理解索引</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e5%99%a8%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e8%8e%b7%e5%8f%96%e6%95%b0%e6%8d%ae aria-label=执行器如何使用索引获取数据>执行器如何使用索引获取数据</a></li></ul></li><li><a href=#%e8%b0%93%e8%af%8d%e4%b8%8b%e6%8e%a8 aria-label=谓词下推>谓词下推</a></li></ul></li><li><a href=#task1---access-method-executors aria-label="Task1 - Access Method Executors">Task1 - Access Method Executors</a><ul><li><a href=#seqscan aria-label=SeqScan>SeqScan</a></li><li><a href=#insert aria-label=Insert>Insert</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88-insert-%e7%ad%89-executor-%e6%9c%89-child-%e8%80%8c-seqscan-%e6%b2%a1%e6%9c%89 aria-label="为什么 Insert 等 Executor 有 child 而 SeqScan 没有？">为什么 Insert 等 Executor 有 child 而 SeqScan 没有？</a></li><li><a href=#%e6%b2%a1%e6%9c%89%e5%ad%90%e6%93%8d%e4%bd%9c%e6%97%b6%e9%9c%80%e8%a6%81%e6%8f%92%e5%85%a5%e7%9a%84%e6%95%b0%e6%8d%ae%e4%bb%8e%e5%93%aa%e9%87%8c%e8%8e%b7%e5%8f%96 aria-label=没有子操作时，需要插入的数据从哪里获取？>没有子操作时，需要插入的数据从哪里获取？</a></li></ul></li><li><a href=#delete aria-label=Delete>Delete</a></li><li><a href=#update aria-label=Update>Update</a></li><li><a href=#indexscan aria-label=IndexScan>IndexScan</a></li></ul></li><li><a href=#task2---aggregation--join-executors aria-label="Task2 - Aggregation &amp;amp; Join Executors">Task2 - Aggregation & Join Executors</a><ul><li><a href=#aggregation aria-label=Aggregation>Aggregation</a></li><li><a href=#nestedloopjoin aria-label=NestedLoopJoin>NestedLoopJoin</a></li></ul></li><li><a href=#task3---hashjoin-executor-and-optimization aria-label="Task3 - HashJoin Executor and Optimization">Task3 - HashJoin Executor and Optimization</a><ul><li><a href=#%e5%b0%86-nl-join-%e4%bc%98%e5%8c%96%e4%b8%ba-hash-join aria-label="将 NL Join 优化为 Hash Join">将 NL Join 优化为 Hash Join</a></li><li><a href=#%e5%ae%9e%e7%8e%b0-hash-join aria-label="实现 Hash Join">实现 Hash Join</a></li></ul></li><li><a href=#task4---sort--limit-executors--window-functions--top-n-optimization aria-label="Task4 - Sort + Limit Executors + Window Functions + Top-N Optimization">Task4 - Sort + Limit Executors + Window Functions + Top-N Optimization</a><ul><li><a href=#sort aria-label=Sort>Sort</a></li><li><a href=#limit aria-label=Limit>Limit</a></li><li><a href=#topn aria-label=TopN>TopN</a></li><li><a href=#window-function aria-label="Window Function">Window Function</a><ul><li><a href=#%e6%97%a0%e6%8e%92%e5%ba%8f%e7%9a%84%e6%83%85%e5%86%b5 aria-label=无排序的情况>无排序的情况</a></li><li><a href=#%e6%9c%89%e6%8e%92%e5%ba%8f%e7%9a%84%e6%83%85%e5%86%b5 aria-label=有排序的情况>有排序的情况</a></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>该系列博客只是为了记录自己在写 Lab 时的思路，按照课程要求不会在 Github 和博客中公开源代码。欢迎与我一起讨论交流！</p></blockquote><p>这个 project 和之前就不一样了，开始深入数据库内核的实现了。需要理清楚一条 sql 语句是如何被执行的，方才能写出代码。</p><h2 id=前置奶酪>前置奶酪<a hidden class=anchor aria-hidden=true href=#前置奶酪>#</a></h2><h3 id=一条-sql-语句的执行>一条 SQL 语句的执行<a hidden class=anchor aria-hidden=true href=#一条-sql-语句的执行>#</a></h3><p><img loading=lazy src=https://15445.courses.cs.cmu.edu/fall2023/project3/img/project-structure.svg></p><p>这里需要去看看一条 sql 语句传入 bustub 内部之后的代码：<code>src/common/bustub_instance.cpp:ExecuteSqlTxn</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>BustubInstance</span><span class=o>::</span><span class=n>ExecuteSqlTxn</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>sql</span><span class=p>,</span> <span class=n>ResultWriter</span> <span class=o>&amp;</span><span class=n>writer</span><span class=p>,</span> <span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>CheckOptions</span><span class=o>&gt;</span> <span class=n>check_options</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sql</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>sql</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\\&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理元命令
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// binder，但是在其中会使用libpg_query来解析sql语句
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>bustub</span><span class=o>::</span><span class=n>Binder</span> <span class=n>binder</span><span class=p>(</span><span class=o>*</span><span class=n>catalog_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>binder</span><span class=p>.</span><span class=n>ParseAndSave</span><span class=p>(</span><span class=n>sql</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 经过上一步后，binder中的statement_nodes_存储着所有的语句解析节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=nl>stmt</span> <span class=p>:</span> <span class=n>binder</span><span class=p>.</span><span class=n>statement_nodes_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将stmt转换成BoundStatement对象，方便后面处理数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>statement</span> <span class=o>=</span> <span class=n>binder</span><span class=p>.</span><span class=n>BindStatement</span><span class=p>(</span><span class=n>stmt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 只有不需要构建plan树、不需要进行优化的sql语句才会在switch之后继续执行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>switch</span> <span class=p>(</span><span class=n>statement</span><span class=o>-&gt;</span><span class=n>type_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 生成初步的执行计划
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bustub</span><span class=o>::</span><span class=n>Planner</span> <span class=n>planner</span><span class=p>(</span><span class=o>*</span><span class=n>catalog_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>planner</span><span class=p>.</span><span class=n>PlanQuery</span><span class=p>(</span><span class=o>*</span><span class=n>statement</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 优化刚刚的执行计划
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bustub</span><span class=o>::</span><span class=n>Optimizer</span> <span class=n>optimizer</span><span class=p>(</span><span class=o>*</span><span class=n>catalog_</span><span class=p>,</span> <span class=n>IsForceStarterRule</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>optimized_plan</span> <span class=o>=</span> <span class=n>optimizer</span><span class=p>.</span><span class=n>Optimize</span><span class=p>(</span><span class=n>planner</span><span class=p>.</span><span class=n>plan_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 执行优化后的plan，这里会使用火山模型去根据下面节点的Next函数来执行相应的算子
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>execution_engine_</span><span class=o>-&gt;</span><span class=n>Execute</span><span class=p>(</span><span class=n>optimized_plan</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>result_set</span><span class=p>,</span> <span class=n>txn</span><span class=p>,</span> <span class=n>exec_ctx</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 将执行结果输出至指定位置
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=err>是否执行成功</span><span class=p>;</span>	
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 binder 之后，我们就有了一条 sql 的语句解析节点，例如执行 <code>select * from (select * from test_2 where colA > 10) where colB > 2;</code>，其 statement node 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BoundSelect</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>table</span><span class=o>=</span><span class=n>BoundSubqueryRef</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>alias</span><span class=o>=</span><span class=n>__subquery</span><span class=err>#</span><span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>subquery</span><span class=o>=</span><span class=n>BoundSelect</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>table</span><span class=o>=</span><span class=n>BoundBaseTableRef</span> <span class=p>{</span> <span class=n>table</span><span class=o>=</span><span class=n>test_2</span><span class=p>,</span> <span class=n>oid</span><span class=o>=</span><span class=mi>23</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s>&#34;test_2.colA&#34;</span><span class=p>,</span> <span class=s>&#34;test_2.colB&#34;</span><span class=p>,</span> <span class=s>&#34;test_2.colC&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>      <span class=n>having</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>where</span><span class=o>=</span><span class=p>(</span><span class=n>test_2</span><span class=p>.</span><span class=n>colA</span><span class=o>&gt;</span><span class=mi>10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=n>limit</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>offset</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>order_by</span><span class=o>=</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>      <span class=n>is_distinct</span><span class=o>=</span><span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>ctes</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s>&#34;test_2.colA&#34;</span><span class=p>,</span> <span class=s>&#34;test_2.colB&#34;</span><span class=p>,</span> <span class=s>&#34;test_2.colC&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s>&#34;__subquery#0.test_2.colA&#34;</span><span class=p>,</span> <span class=s>&#34;__subquery#0.test_2.colB&#34;</span><span class=p>,</span> <span class=s>&#34;__subquery#0.test_2.colC&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>  <span class=n>having</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>where</span><span class=o>=</span><span class=p>(</span><span class=n>__subquery</span><span class=err>#</span><span class=mf>0.</span><span class=n>test_2</span><span class=p>.</span><span class=n>colB</span><span class=o>&gt;</span><span class=mi>2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=n>limit</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>offset</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>order_by</span><span class=o>=</span><span class=p>[],</span>
</span></span><span class=line><span class=cl>  <span class=n>is_distinct</span><span class=o>=</span><span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ctes</span><span class=o>=</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中的子查询和 where 的条件还有需要哪些列都能非常清楚的看到。</p><h3 id=iterator-model>Iterator Model<a hidden class=anchor aria-hidden=true href=#iterator-model>#</a></h3><p>通常一个 SQL 会被组织成树状的查询计划，数据从叶子节点流到根节点，查询结果在根节点中得出。</p><p>bustub 中采用的数据库查询执行模型叫做迭代器模型，也叫火山模型。</p><p>查询计划（query plan）中的每步 operator 对应的 executor 都实现一个 <code>next</code> 函数，每次调用时，operator 返回一个 <code>tuple</code> 或者 null，后者表示数据已经遍历完毕。operator 本身实现一个循环，每次调用其 child operators 的 next 函数，从它们那边获取下一条数据供自己操作，这样整个 query plan 就被从上至下地串联起来。</p><p>但是像 Joins, Aggregates, Subqueries, Order By 这样的操作需要等所有 children 返回它们的 tuple。虽然一次调用请求一条数据，占用内存较小，但函数调用开销大。</p><h3 id=catalog-table-and-index>Catalog, Table and Index<a hidden class=anchor aria-hidden=true href=#catalog-table-and-index>#</a></h3><p>下图出处：https://www.cnblogs.com/joey-wang/p/17351258.html</p><p><img loading=lazy src=https://fastly.jsdelivr.net/gh/Angelia-Wang/blogImage/img/image-20230415234907799.png></p><h3 id=索引-index>索引 index<a hidden class=anchor aria-hidden=true href=#索引-index>#</a></h3><p>在 Bustub 中，索引用于加速数据访问。索引通过维护表中数据的有序结构，使得查询可以更快地定位到所需的记录。</p><h4 id=结构>结构<a hidden class=anchor aria-hidden=true href=#结构>#</a></h4><p>索引的结构图和上面表的结构图类似。在 catalog 中，可以获取到一个表对应的<strong>所有</strong><code>IndexInfo</code>，每个 <code>IndexInfo</code> 中包含着这个索引的信息，这里讲两个个我认为比较重要的成员变量：</p><ul><li><code>key_schema_</code>：索引对应的列的结构，例如使用其 <code>ToString()</code> 函数时，其会返回 <code>(添加了索引的列的名称:该列的数据类型)</code></li><li><code>index_</code>：这是一个指针，指向一个 <code>Index</code> 类的对象，也就是真正的索引</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// catalog.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Catalog</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>KeyType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>ValueType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>KeyComparator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>CreateIndex</span><span class=p>(</span><span class=n>Transaction</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>index_name</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>table_name</span><span class=p>,</span> <span class=k>const</span> <span class=n>Schema</span> <span class=o>&amp;</span><span class=n>schema</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=k>const</span> <span class=n>Schema</span> <span class=o>&amp;</span><span class=n>key_schema</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>key_attrs</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>keysize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>HashFunction</span><span class=o>&lt;</span><span class=n>KeyType</span><span class=o>&gt;</span> <span class=n>hash_function</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>is_primary_key</span> <span class=o>=</span> <span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>IndexType</span> <span class=n>index_type</span> <span class=o>=</span> <span class=n>IndexType</span><span class=o>::</span><span class=n>HashTableIndex</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>IndexInfo</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=nf>GetIndex</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>index_name</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>table_name</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>IndexInfo</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=nf>GetIndex</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>index_name</span><span class=p>,</span> <span class=k>const</span> <span class=n>table_oid_t</span> <span class=n>table_oid</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>IndexInfo</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=nf>GetIndex</span><span class=p>(</span><span class=n>index_oid_t</span> <span class=n>index_oid</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>IndexInfo</span> <span class=o>*</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=nf>GetTableIndexes</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>table_name</span><span class=p>)</span> <span class=k>const</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>IndexInfo</span> <span class=o>*&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Map index identifier -&gt; index metadata.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * NOTE: that `indexes_` owns all index metadata.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>index_oid_t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>IndexInfo</span><span class=o>&gt;&gt;</span> <span class=n>indexes_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** Map table name -&gt; index names -&gt; index identifiers. */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>index_oid_t</span><span class=o>&gt;&gt;</span> <span class=n>index_names_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/** The next index identifier to be used. */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>index_oid_t</span><span class=o>&gt;</span> <span class=n>next_index_oid_</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>IndexInfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The schema for the index key */</span>
</span></span><span class=line><span class=cl>  <span class=n>Schema</span> <span class=n>key_schema_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The name of the index */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** An owning pointer to the index */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Index</span><span class=o>&gt;</span> <span class=n>index_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The unique OID for the index */</span>
</span></span><span class=line><span class=cl>  <span class=n>index_oid_t</span> <span class=n>index_oid_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The name of the table on which the index is created */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>table_name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The size of the index key, in bytes */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>key_size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** Is primary key index? */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>is_primary_key_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The index type */</span>
</span></span><span class=line><span class=cl>  <span class=na>[[maybe_unused]]</span> <span class=n>IndexType</span> <span class=n>index_type_</span><span class=p>{</span><span class=n>IndexType</span><span class=o>::</span><span class=n>BPlusTreeIndex</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>Index</code> 中有着三个虚函数供其派生类去实现，其唯一的成员变量的类型为 <code>IndexMeta</code>，用来存储一些元信息，例如这个索引的名称，它所属的表的名称，最重要的还有一个 <code>key_attrs_</code>，稍后就说谈论它。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// index.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IndexMeta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The name of the index */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The name of the table on which the index is created */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>table_name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The mapping relation between key schema and tuple schema */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>key_attrs_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The schema of the indexed key */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Schema</span><span class=o>&gt;</span> <span class=n>key_schema_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** Is primary key? */</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>is_primary_key_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Index</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=cm>/** The Index structure owns its metadata */</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>IndexMetadata</span><span class=o>&gt;</span> <span class=n>metadata_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>fall2023 我们使用的是哈希索引，底层使用的就是在 project2 中实现的可拓展哈希。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// extendible_hash_table_index.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define HASH_TABLE_INDEX_TYPE ExtendibleHashTableIndex&lt;KeyType, ValueType, KeyComparator&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>KeyType</span><span class=p>,</span> <span class=k>typename</span> <span class=n>ValueType</span><span class=p>,</span> <span class=k>typename</span> <span class=n>KeyComparator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ExtendibleHashTableIndex</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Index</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>ExtendibleHashTableIndex</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>IndexMetadata</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span><span class=n>metadata</span><span class=p>,</span> <span class=n>BufferPoolManager</span> <span class=o>*</span><span class=n>buffer_pool_manager</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=n>HashFunction</span><span class=o>&lt;</span><span class=n>KeyType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>hash_fn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>ExtendibleHashTableIndex</span><span class=p>()</span> <span class=k>override</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=nf>InsertEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>Tuple</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>RID</span> <span class=n>rid</span><span class=p>,</span> <span class=n>Transaction</span> <span class=o>*</span><span class=n>transaction</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>bool</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>DeleteEntry</span><span class=p>(</span><span class=k>const</span> <span class=n>Tuple</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>RID</span> <span class=n>rid</span><span class=p>,</span> <span class=n>Transaction</span> <span class=o>*</span><span class=n>transaction</span><span class=p>)</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>ScanKey</span><span class=p>(</span><span class=k>const</span> <span class=n>Tuple</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>RID</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>result</span><span class=p>,</span> <span class=n>Transaction</span> <span class=o>*</span><span class=n>transaction</span><span class=p>)</span> <span class=k>override</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// comparator for key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>KeyComparator</span> <span class=n>comparator_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// container
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DiskExtendibleHashTable</span><span class=o>&lt;</span><span class=n>KeyType</span><span class=p>,</span> <span class=n>ValueType</span><span class=p>,</span> <span class=n>KeyComparator</span><span class=o>&gt;</span> <span class=n>container_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=更新索引>更新索引<a hidden class=anchor aria-hidden=true href=#更新索引>#</a></h4><p>当插入新记录时，不仅需要将记录插入到表中，还需要将相应的索引条目插入到索引中。这样，后续的查询操作可以利用索引快速定位到目标记录。如果不更新索引，后续的查询操作可能会错过新插入的记录，导致查询结果不准确。</p><blockquote><p><code>UPDATE</code> 和 <code>DELETE</code> 如何影响索引？</p></blockquote><ol><li><p><strong>UPDATE</strong></p><p>✅ 需要更新索引的情况：修改了<strong>索引列</strong> 的值（例如：将 <code>id=100</code> 的 <code>name</code> 字段从 &ldquo;Alice&rdquo; 改为 &ldquo;Bob&rdquo;，而 <code>name</code> 被建了索引）</p><ul><li>此时旧索引项（&ldquo;Alice&rdquo;）需要被删除</li><li>新索引项（&ldquo;Bob&rdquo;）需要被插入</li></ul><p>❌ 不需要更新索引的情况：修改的是<strong>非索引列</strong></p><ul><li>例如：<code>age</code> 字段没有被索引，修改它不会影响索引</li></ul></li><li><p><strong>DELETE</strong></p><p>无论删除哪一行，只要该行在某个索引中存在，就需要从索引中<strong>删除对应的条目</strong> 。</p></li></ol><p>bustub 中有哈希索引和 B+Tree 索引，fall2023 版本使用的是<strong>可拓展哈希</strong>作为作为索引。不过这两个具体的实现都有一个基类 <code>Index</code>，其中有以下虚函数需要子类去实现：</p><ul><li><code>InsertEntry(const Tuple &amp;key, RID rid, Transaction *transaction)</code>: 插入一个索引条目。</li><li><code>DeleteEntry(const Tuple &amp;key, RID rid, Transaction *transaction)</code>: 删除一个索引条目。</li><li><code>ScanKey(const Tuple &amp;key, std::vector&lt;RID> *result, Transaction *transaction)</code>: 根据索引键搜索记录，并将结果 RID 存储在指定的向量中。</li></ul><p>所以不管用的是哈希还是 B+Tree，在操作索引时用的接口都相同。</p><h4 id=如何理解索引>如何理解索引<a hidden class=anchor aria-hidden=true href=#如何理解索引>#</a></h4><p>就如网上很多介绍索引的博客所描述的那样，数据库索引是用来加速检索速度的，就如同新华字典中的音节索引一样：</p><p><img loading=lazy src=https://i2.kknews.cc/xGbg60mPdeRNfqICEnjrmqLM9nGZdeKcOg/0.jpg></p><p>如同 table_info，catalog 中也有许多的 index_info，每个 index_info 就如同上图音节表中的一个字母。我们对一个字段（列）构建一个索引，就如同在上图中音节表中多加一个字母（例如 X）。</p><ul><li>需要插入一条记录时，就往对应的索引下插入 <code>(记录， 对应记录的地址)</code> 这样的键值对，例如上图的 <code>(xian, 519)</code>，这里的地址为 <code>RID</code>。</li><li>需要删除一条记录时，在对应的索引下删掉匹配的键值对。</li><li>需要更新一条记录时，由于 bustub 没有提供更新索引的 API，所以可以用先删除再插入的方式模拟更新。</li></ul><h4 id=执行器如何使用索引获取数据>执行器如何使用索引获取数据<a hidden class=anchor aria-hidden=true href=#执行器如何使用索引获取数据>#</a></h4><p>当执行器需要从表中获取数据时，如果查询计划中包含索引扫描操作，执行器会通过索引来快速定位数据。以下是具体的步骤：</p><ol><li><strong>解析查询计划</strong>：<ul><li>执行器根据查询计划确定需要使用的索引。</li><li>获取索引的元数据，包括索引键的模式和表列的映射关系。</li></ul></li><li><strong>构建索引键</strong>：<ul><li>根据查询条件和索引的元数据，构建索引键。这通常涉及到从查询条件中提取列值，并根据索引键的模式进行转换。</li></ul></li><li><strong>使用索引进行搜索</strong>：<ul><li>调用索引的 <code>ScanKey</code> 方法，传入构建好的索引键和一个结果 RID 向量。</li><li>索引会根据键值查找对应的记录，并将找到的 RID 存储在结果向量中。</li></ul></li><li><strong>读取数据页</strong>：<ul><li>使用结果向量中的 RID，从缓冲池中查找对应的页。如果页不在缓冲池中，则从磁盘加载到缓冲池。</li><li>从页中读取数据并创建 <code>Tuple</code> 对象。</li></ul></li><li><strong>处理和返回结果</strong>：<ul><li>使用 <code>Tuple</code> 对象的方法（如 <code>GetValue</code>、<code>IsNull</code> 等）访问和处理元组中的数据。</li><li>将处理后的数据作为结果返回给用户或进一步处理。</li></ul></li></ol><h3 id=谓词下推>谓词下推<a hidden class=anchor aria-hidden=true href=#谓词下推>#</a></h3><p>谓词下推（Predicate Pushdown）是数据库查询优化中的一种技术，其核心思想是将查询中的过滤条件（即谓词）尽可能早地应用到查询执行计划的底部，也就是数据生成的地方。这样做的目的是为了减少数据的传输量和处理量，从而提高查询效率。</p><p>具体来说，谓词下推包括以下几个方面：</p><ol><li><strong>过滤条件前移</strong>：在查询执行的过程中，尽早地对数据进行过滤，这样不需要将所有数据都传递到上层操作中，只传递满足条件的数据。</li><li><strong>减少数据传输</strong>：通过在数据生成的阶段就进行过滤，可以减少从数据库存储引擎到查询处理引擎之间的数据传输量。</li><li><strong>减少 CPU 处理</strong>：不需要对所有数据进行后续的处理，只需要处理已经过滤的数据，这样可以减少 CPU 的工作量。</li><li><strong>利用索引</strong>：如果过滤条件可以利用现有的索引，谓词下推可以使得查询直接利用索引来快速定位数据，而不是扫描整个表。</li><li><strong>优化查询计划</strong>：数据库优化器会根据谓词下推的原则重新规划查询的执行步骤，生成更高效的查询计划。</li></ol><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>50000</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>在这个查询中，<code>WHERE</code> 子句包含了两个过滤条件。如果不进行谓词下推，数据库可能会先扫描整个 <code>employees</code> 表，然后将所有行传递给上层操作，之后再应用过滤条件。而通过谓词下推，数据库可以在扫描表的时候直接应用这些过滤条件，只返回部门 ID 为 5 且薪资大于 50000 的员工记录。</p><p>谓词下推是数据库查询优化中非常重要的一环，它有助于提高查询性能，特别是在处理大规模数据集时。数据库优化器会尝试自动应用谓词下推，但有时开发者也可以通过编写更优化的查询条件来帮助优化器更好地进行谓词下推。</p><h2 id=task1---access-method-executors>Task1 - Access Method Executors<a hidden class=anchor aria-hidden=true href=#task1---access-method-executors>#</a></h2><h3 id=seqscan>SeqScan<a hidden class=anchor aria-hidden=true href=#seqscan>#</a></h3><p>顺序扫描指定的表，表的遍历可以使用 <code>TableIterator</code>。</p><p>每次找到一条没有被标记为“删除”或者不是 where 之类的过滤子句匹配（这里会在 delete 操作中说明）的 tuple（记录）就并返回，如果已经扫描到了表的结束位置则返回 false。</p><h3 id=insert>Insert<a hidden class=anchor aria-hidden=true href=#insert>#</a></h3><h4 id=为什么-insert-等-executor-有-child-而-seqscan-没有>为什么 Insert 等 Executor 有 child 而 SeqScan 没有？<a hidden class=anchor aria-hidden=true href=#为什么-insert-等-executor-有-child-而-seqscan-没有>#</a></h4><p><code>InsertExecutor</code> 的主要职责是将一条或多条记录插入到指定的表中。它可能需要依赖于其他 <code>Executor</code> 来获取要插入的数据。例如，如果 <code>INSERT</code> 操作是从一个 <code>SELECT</code> 查询的结果集中插入数据，那么 <code>InsertExecutor</code> 可能会有一个子 <code>Executor</code>（如 <code>SeqScanExecutor</code> 或其他类型的 <code>Executor</code>），该子 <code>Executor</code> 负责执行 <code>SELECT</code> 操作并提供数据给 <code>InsertExecutor</code>。</p><p>因此，<code>InsertExecutor</code> 有 child 是因为它可能需要从另一个查询的结果中获取数据。</p><p><code>SeqScanExecutor</code> 的主要职责是对表进行全表扫描，即按顺序读取表中的所有记录。这是一个基本的操作，通常不需要其他 <code>Executor</code> 的支持来完成其工作。</p><p>它直接作用于存储层，遍历表中的每一行数据，因此没有子 <code>Executor</code>。它的任务相对简单，就是遍历和返回表中的所有记录。</p><p>简而言之，<code>InsertExecutor</code> 需要 child 是<strong>因为它的操作可能涉及从其他查询结果中获取数据</strong>，而 <code>SeqScanExecutor</code> 不需要 child 是因为它的任务是独立完成的，只需遍历表中的所有记录即可。这反映了数据库执行计划中不同操作之间的依赖关系和交互方式。其他 Executor 同理。</p><p>举个批量插入的🌰：</p><p>假设我们有一个 <code>orders</code> 表，包含以下列：</p><ul><li><code>order_id</code> (主键)</li><li><code>customer_id</code></li><li><code>product_id</code></li><li><code>quantity</code></li><li><code>order_date</code></li></ul><p>我们希望通过一个子查询（select）来获取一批订单记录，并将这些记录插入到 <code>orders</code> 表中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=p>(</span><span class=n>customer_id</span><span class=p>,</span><span class=w> </span><span class=n>product_id</span><span class=p>,</span><span class=w> </span><span class=n>quantity</span><span class=p>,</span><span class=w> </span><span class=n>order_date</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>customer_id</span><span class=p>,</span><span class=w> </span><span class=n>product_id</span><span class=p>,</span><span class=w> </span><span class=n>quantity</span><span class=p>,</span><span class=w> </span><span class=n>order_date</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>pending_orders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>status</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;approved&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>很明显，我们在插入之前要从 select 子句中获取数据，因此这个子查询操作就是 insert 操作的 <code>child_executor</code>。</p><h4 id=没有子操作时需要插入的数据从哪里获取>没有子操作时，需要插入的数据从哪里获取？<a hidden class=anchor aria-hidden=true href=#没有子操作时需要插入的数据从哪里获取>#</a></h4><p>比如执行如下 SQL 时：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>values</span><span class=w> </span><span class=p>(</span><span class=mi>202</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>从肉眼看可以知道需要插入的数据为 <code>(202, 1, 2, 3)</code>，但是在代码中又是从哪里获取的呢？</p><p>让我们使用一下 <code>explain</code> 工具来看看这条 SQL 语句在 bustub 内部做了什么：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>explain</span><span class=w> </span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>values</span><span class=w> </span><span class=p>(</span><span class=mi>202</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BoundInsert</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>table</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>select</span><span class=o>=</span><span class=w>  </span><span class=n>BoundSelect</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>table</span><span class=o>=</span><span class=n>BoundExpressionListRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>identifier</span><span class=o>=</span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>values</span><span class=o>=</span><span class=p>[[</span><span class=s2>&#34;202&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;3&#34;</span><span class=p>]]</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;__values#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__values#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__values#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__values#0.3&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>having</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>limit</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>offset</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>order_by</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>is_distinct</span><span class=o>=</span><span class=k>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ctes</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Insert</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__bustub_internal</span><span class=p>.</span><span class=n>insert_rows</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>3</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>Values</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>rows</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>3</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Insert</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__bustub_internal</span><span class=p>.</span><span class=n>insert_rows</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>Values</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>rows</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__values</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>3</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>将目标聚焦在生成的查询计划上，从上到下，在一个 <code>Insert</code> 的查询计划中，使用 <code>Projection</code> 从其输入源（如表扫描、索引扫描、连接等）中提取所需的列，最下层使用 <code>Value</code> 获取到要操作的数据！</p><p>所以对应的，<code>InsertExecutor</code> 的 <code>child_executor</code> 为 <code>ProjectionExecutor</code>，而 <code>ProjectionExecutor</code> 的 <code>child_executor</code> 为 <code>ValuesExecutor</code>，使用迭代器模型就能很方便的获取到数据了（<code>ValuesExecutor</code> 就是最后的 Executor，其 <code>Next</code> 函数不会再往下调用，其所做的只是根据在解析 SQL 及其之后的一些步骤中得到的需要操作的数据封装成一个 tuple 进行返回）。</p><h3 id=delete>Delete<a hidden class=anchor aria-hidden=true href=#delete>#</a></h3><p>需要写的代码和 insert 操作的基本相同。但有个地方需要注意一下，在执行一条 delete 语句时，让我们看看做了些什么：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>explain</span><span class=w> </span><span class=k>delete</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>colA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>999</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Delete</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=n>expr</span><span class=o>=</span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=o>=</span><span class=mi>999</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Delete</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__bustub_internal</span><span class=p>.</span><span class=n>delete_rows</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Filter</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=</span><span class=mi>999</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Delete</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__bustub_internal</span><span class=p>.</span><span class=n>delete_rows</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=p>,</span><span class=w> </span><span class=n>filter</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=</span><span class=mi>999</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>可以看到，在 optimizer 阶段，where 子句的 filter 下放至 SeqScan 处与其合并了，也就是说，我们需要在实现 <code>SeqScanExecutor</code> 时注意处理一下 filter。这里提示一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>cur_tuple</span><span class=p>.</span><span class=n>first</span><span class=p>.</span><span class=n>is_deleted_</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>	    <span class=p>(</span><span class=n>plan_</span><span class=o>-&gt;</span><span class=n>filter_predicate_</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>plan_</span><span class=o>-&gt;</span><span class=n>filter_predicate_</span><span class=o>-&gt;</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>tuple</span><span class=p>,</span> <span class=n>GetOutputSchema</span><span class=p>()).</span><span class=n>GetAs</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>())))</span>
</span></span></code></pre></div><p>如果其返回 true，说明 filter 匹配到了数据（就如例子中匹配到了 colA 列为 999 的 tuple），如果此时这个 tuple 没有被标记为删除，那么就说明找到了我们需要删除的 tuple。</p><h3 id=update>Update<a hidden class=anchor aria-hidden=true href=#update>#</a></h3><p>我们如何知道 update 需要更新的数据从哪里取呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>explain</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>o</span><span class=p>)</span><span class=w> </span><span class=k>update</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>colB</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>15445</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Update</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span><span class=w> </span><span class=n>target_exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;15445&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Filter</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=k>true</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Update</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>table_oid</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span><span class=w> </span><span class=n>target_exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;15445&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=p>,</span><span class=w> </span><span class=n>filter</span><span class=o>=</span><span class=k>true</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span></code></pre></div><p>看看 Update 中，有一个 <code>target_exprs</code> 数组，这个数组可不就是我们的一行数据吗，并且是需要更新的那行数据：update 语句可以不加 where 子句，这样就是选中表中的所有行，也就是这里将表中 colB 列的数据都 update 为 15445！</p><p>对于 <code>target_exprs</code> 这个数组，我们可以通过 <code>plan_->target_expressions_</code> 获取，然后用其构建一个新的 tuple。</p><p>需要注意的是，这里并没有提供直接更新 tuple 的操作，所以我们的 update 操作可以用先删除后插入的方式来模拟。</p><h3 id=indexscan>IndexScan<a hidden class=anchor aria-hidden=true href=#indexscan>#</a></h3><p>我们首先需要完成 <code>OptimizeSeqScanAsIndexScan</code> 这个优化步骤。</p><p>假设现在我们有一个表叫“test_1”，其列如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>+</span><span class=c1>-------------+-------------+-------------+-------------+
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>+</span><span class=c1>-------------+-------------+-------------+-------------+
</span></span></span></code></pre></div><p>现在我们希望这条 SQL 能执行的更快：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>colB</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>11</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>那比较不错的方法就是给 <code>colB</code> 列加上索引：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=n>v1</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=n>test_1</span><span class=p>(</span><span class=n>colB</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这样在执行时可以更快速的查找数据。</p><p>那么为了实现这一目标，我们需要通过 <code>OptimizeSeqScanAsIndexScan</code> 将 plan 树中的 <code>SeqScanPlanNode</code> 转换成 <code>IndexScanPlanNode</code>，这样我们才能使用 IndexScanPlanNode 对应的算子 &mdash;<code>IndexScanExecutor</code> 去使用索引。但是由于 bustub 的一些设计，需要遵循以下规则才可以转化：</p><ol><li>当前的节点的类型必须是 <code>PlanType::SeqScan</code></li><li>当前节点必须有 filter 谓词，如果只是 <code>select * from test_1;</code> 这样的是不需要使用索引的</li><li>当前表中必须有索引，没有索引还玩啥呢</li><li>fileter 谓词中的逻辑表达式只能有一个，并且其类型必须是 <code>ComparisonType::Equal</code>（我想这里必须是“等于”是不是因为 fall2023 使用的索引是哈希索引）</li><li>在当前表的索引信息中找到与 filter 谓词相对应的索引后才能返回一个 <code>IndexScanPlanNode</code></li></ol><p>在 <code>select * from test_1 where colB = 11;</code> 中，加了索引后，最需要关注的就是 <code>where colB = 11</code> 这一个过滤条件。bustub 中要求 <code>IndexScan</code> 过滤运算符必须是 <code>=</code>，且只能有一个条件。如果 <code>colA</code> 和 <code>colB</code> 都是索引，然后执行 <code>select * from test_1 where colB = 11 and colA = 1;</code>，这样是不会走索引优化的。</p><p>我们将查询计划中的过滤谓词转化成 <code>ComparisonExpression</code> 类型，据我的理解，其可通过 <code>GetChildAt</code> 函数获取比较谓词左边的列名表达式（即这里的“colB”，有了这个列名的表达式，我们就可以获取到这个列的 col_id 值）和右边的值（即“11”）。之后需要去这张表中的所有索引中去找是否有 colB 的索引，怎么确定是否有呢，那就要看这个表中的每个 <code>Index</code> 的 <code>key_attrs_</code>：</p><p>在 <code>Index</code> 中，<code>key_attrs_</code> 决定了索引的关键字由哪些列组成，对应了每个列的下标。例如：</p><ul><li>如果表的 schema 定义有 5 列，分别为 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>。</li><li>某个索引的 <code>key_attrs_</code> 是 <code>[0, 2]</code>，则表示该索引使用了第 0 列（<code>A</code>）和第 2 列（<code>C</code>）作为其关键字。</li></ul><p>如果之前我们获取的列的 col_id 值和某个 <code>Index</code> 的 <code>key_attrs_</code> 中的值相同，那么就存在相应的索引！这时构造一个 <code>IndexScanPlanNode</code> 返回即可（参考 <code>merge_filter_scan.cpp</code> 中是如何做的）。</p><p>当优化器成功更换节点后，在执行时就会走索引，其底层算子就会使用到 <code>IndexScanExecutor</code>。到这里，这个算子需要做的事情就很简单了，就是调用哈希索引的 <code>ScanKey</code> 进行查找，不过这里有 3 点需要注意：</p><ol><li>在 project2 中，我们实现的索引引擎只支持一个键对应一个值（不只是这个版本的可拓展哈希，其他版本中的 B+Tree 也只要求这样实现），也就是我们的这个算子在底层索引引擎不扩展的情况下最多查到一条记录，这样的话就可以在算子的 <code>Init</code> 函数中调用 <code>ScanKey</code> 查找记录就行。</li><li>可拓展哈希中是将一个 Tuple 的 data 转化一下当作 key，所以在索引中，其是将索引列的值作为 key，其对应的 oid 作为值。在使用 <code>ScanKey</code> 时，第一个参数需要的 tuple 将用查询计划节点 <code>IndexScanPlanNode</code> 中的 <code>pred_key_</code> 构造。</li><li>表中的 tuple 的元数据中，其 <code>is_deleted_</code> 可能为 true，这说明这个 tuple 在逻辑上已经删除了，所以如果我们通过 2 中获取的 oid 对应的 tuple 是这种情况，就不用向上返回数据。</li></ol><h2 id=task2---aggregation--join-executors>Task2 - Aggregation & Join Executors<a hidden class=anchor aria-hidden=true href=#task2---aggregation--join-executors>#</a></h2><h3 id=aggregation>Aggregation<a hidden class=anchor aria-hidden=true href=#aggregation>#</a></h3><p>分析一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>colC</span><span class=p>),</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>colB</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>test_1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>colA</span><span class=w> </span><span class=k>HAVING</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>colB</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BoundSelect</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>table</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>22</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;max([\&#34;</span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=err>\</span><span class=s2>&#34;])&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;min([\&#34;</span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=err>\</span><span class=s2>&#34;])&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>groupBy</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;test_1.colA&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>having</span><span class=o>=</span><span class=p>(</span><span class=k>max</span><span class=p>([</span><span class=s2>&#34;test_1.colB&#34;</span><span class=p>])</span><span class=o>&gt;</span><span class=mi>10</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>limit</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>offset</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>order_by</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>is_distinct</span><span class=o>=</span><span class=k>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ctes</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=o>&lt;</span><span class=k>unnamed</span><span class=o>&gt;</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=o>&lt;</span><span class=k>unnamed</span><span class=o>&gt;</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Filter</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>1</span><span class=o>&gt;</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Agg</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>types</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;max&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;max&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;min&#34;</span><span class=p>],</span><span class=w> </span><span class=n>aggregates</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>],</span><span class=w> </span><span class=n>group_by</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=o>&lt;</span><span class=k>unnamed</span><span class=o>&gt;</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=o>&lt;</span><span class=k>unnamed</span><span class=o>&gt;</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Filter</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>1</span><span class=o>&gt;</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Agg</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>types</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;max&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;max&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;min&#34;</span><span class=p>],</span><span class=w> </span><span class=n>aggregates</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>],</span><span class=w> </span><span class=n>group_by</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>0</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>1</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>agg</span><span class=o>#</span><span class=mi>2</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>test_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>test_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colC</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>test_1</span><span class=p>.</span><span class=n>colD</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>对于 AggregationExecutor，我们可以获取到 SQL 语句中：</p><ol><li>聚合操作的 <code>types</code>（进行聚合操作的类型）和 <code>aggregates</code>（需要聚合操作的列），二者一一对应</li><li>需要 group by 进行分组的列</li></ol><p><img loading=lazy src=https://obsidian-image-oss.oss-cn-shanghai.aliyuncs.com/Pasted%20image%2020250311194555.png></p><p>再看看 lecture 中的这个例子，其对列 cid 使用 group by 进行分组，其中涉及的聚合操作为 <code>AVG</code>，可转换成 <code>COUNT</code> 和 <code>SUM</code> 操作。这里相当于：</p><pre tabindex=0><code>types = [&#39;count&#39;, &#39;sum&#39;]
aggregates = [&#39;s.gpa&#39;, &#39;s.gpa&#39;]
</code></pre><p>我的理解是根据 group by 的字段的值进行 hash 函数处理作为哈希表的键，例如图中的“15-445”，“15-826”等；然后哈希表的值为一个集合，这个集合的大小和 <code>types</code> 和 <code>aggregates</code> 的大小相同，并且对应的位置就为 aggregates 的值：例如图中键“15-445”的值中，第一个元素就为 <code>COUNT</code> 操作下 <code>s.gpa</code> 为 15-445 的个数。</p><p>在 lab 中需要实现 <code>count</code>、<code>sum</code>、<code>max</code>、<code>min</code> 操作，其实就是在 <code>SimpleAggregationHashTable：：CombineAggregateValues</code> 中实现对应的操作即可，本质上是对哈希表的几个很简单的操作。</p><p><code>aggregation</code> 通常需要对一组数据进行计算，这些计算具有以下特点：</p><ol><li><strong>需要完整输入</strong>：Aggregation 通常需要从下层拉取所有相关数据才能计算结果，例如计算 <code>SUM</code> 需要遍历所有行。</li><li><strong>阻塞性</strong>：在传统实现中，Aggregation 算子通常被称为“阻塞算子”，因为它必须等待所有输入数据都拉取完成才能产出结果。这意味着 <code>next()</code> 调用会被延迟，直到聚合计算完成。</li></ol><p>在我们的火山模型中 <code>aggregation</code> 是阻塞算子：</p><ul><li>当上层算子调用 <code>next()</code> 时，<code>aggregation</code> 会向下层算子连续调用 <code>next()</code>，直到拉取完全部数据并完成聚合。</li><li>在数据尚未完全拉取并聚合完成之前，上层的 <code>next()</code> 调用无法直接返回结果。</li></ul><p>需要注意的是：</p><ul><li>SQL 中进行 <code>group by</code> 后使用 <code>count</code>，统计的是<strong>每组数据中的记录数</strong>，而非分组后新表的行数。</li><li><code>distinct</code> 其实就是对某个字段进行 <code>group by</code> 操作</li><li><code>count(*)</code> 统计 null，而 <code>count(字段)</code> 不统计 null</li></ul><h3 id=nestedloopjoin>NestedLoopJoin<a hidden class=anchor aria-hidden=true href=#nestedloopjoin>#</a></h3><p>Inner Join：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>colA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>colE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BoundSelect</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>table</span><span class=o>=</span><span class=n>BoundCrossProductRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>left</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>0</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=k>right</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>2</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;__mock_table_1.colA&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_1.colB&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colE&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colF&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>having</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=o>=</span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>limit</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>offset</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>order_by</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>is_distinct</span><span class=o>=</span><span class=k>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ctes</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Filter</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Inner</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=k>true</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Inner</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>__mock_table_1</span><span class=w> </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>__mock_table_3</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>colA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>colE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BoundSelect</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>table</span><span class=o>=</span><span class=n>BoundJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Inner</span><span class=p>,</span><span class=w> </span><span class=k>left</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>0</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=k>right</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>2</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=n>condition</span><span class=o>=</span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;__mock_table_1.colA&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_1.colB&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colE&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colF&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>having</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>limit</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>offset</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>order_by</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>is_distinct</span><span class=o>=</span><span class=k>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ctes</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Inner</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Inner</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>可以看到，即便我们不加 <code>inner join</code>，默认情况下也是使用的 Inner Join：<code>NestedLoopJoin</code> 中的 type 均为 <code>Inner</code>。</p><p>Left Join：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>EXPLAIN</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>__mock_table_1</span><span class=w> </span><span class=k>LEFT</span><span class=w> </span><span class=k>OUTER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>__mock_table_3</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>colA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>colE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>BINDER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BoundSelect</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>table</span><span class=o>=</span><span class=n>BoundJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Left</span><span class=p>,</span><span class=w> </span><span class=k>left</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>0</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=k>right</span><span class=o>=</span><span class=n>BoundBaseTableRef</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>,</span><span class=w> </span><span class=n>oid</span><span class=o>=</span><span class=mi>2</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w> </span><span class=n>condition</span><span class=o>=</span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>columns</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;__mock_table_1.colA&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_1.colB&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colE&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;__mock_table_3.colF&#34;</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>groupBy</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>having</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>where</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>limit</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>offset</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>order_by</span><span class=o>=</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>is_distinct</span><span class=o>=</span><span class=k>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ctes</span><span class=o>=</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>PLANNER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Projection</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=n>exprs</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;#0.0&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.2&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;#0.3&#34;</span><span class=p>]</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Left</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>NestedLoopJoin</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>Left</span><span class=p>,</span><span class=w> </span><span class=n>predicate</span><span class=o>=</span><span class=p>(</span><span class=o>#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=o>=#</span><span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_1</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colA</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_1</span><span class=p>.</span><span class=n>colB</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>MockScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>__mock_table_3</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colE</span><span class=p>:</span><span class=nb>INTEGER</span><span class=p>,</span><span class=w> </span><span class=n>__mock_table_3</span><span class=p>.</span><span class=n>colF</span><span class=p>:</span><span class=nb>VARCHAR</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>由于火山模型中的 Next 每次返回一条 tuple，所以我们需要在 Init 中得到 join 后的所有 tuple。Nested Loop Join 其实就是用两个 for 循环去遍历两张表，保存满足筛选条件的 tuple。</p><p><code>inner join</code> 只会返回两个表中满足连接条件的 tuple；而 <code>left join</code> 会返回左表中的所有记录，以及右表中满足条件的 tuple。所以在嵌套 for 循环中，如果右表中有未能满足条件的 tuple，那么就保存左表中的每一列的值，并且加上右表中每一列的 null 值。</p><h2 id=task3---hashjoin-executor-and-optimization>Task3 - HashJoin Executor and Optimization<a hidden class=anchor aria-hidden=true href=#task3---hashjoin-executor-and-optimization>#</a></h2><p>为什么需要 hash join 呢？如果两张要进行 join 的表非常大，这时使用 NLJ 的时间复杂度就为 <code>O(n*m)</code>，但是如果我们使用 hash join，先对一张表建立哈希映射，然后再对另一张表进行哈希检测来判断是否满足连接条件，这样就只要各扫描一次两张表，时间复杂度就降为了 <code>O(n+m)</code>。</p><h3 id=将-nl-join-优化为-hash-join>将 NL Join 优化为 Hash Join<a hidden class=anchor aria-hidden=true href=#将-nl-join-优化为-hash-join>#</a></h3><p>实验指导中说，优化器需要将 nl join 优化为 hash join 的情况为：连接条件中有多个等值 AND 操作，即 <code>x = y AND a = b AND ...</code>。那我们只要在碰到 <code>NestedLoopPlanNode</code> 时获取其谓词，判断一下是否满足该情况就好了。</p><p>需要注意的是，当谓词仅为 <code>a = b</code> 时，这个谓词是一个 <code>ComparationExpression</code>；而当它为 <code>x = y AND a = b AND ...</code> 时，它是一个 <code>LogicExpression</code>。这里在判断的是否需要区分，而在之前的实验中，有学习到可以使用标准库中的 <code>std::dynamic_pointer_cast</code> 函数来将谓词从 <code>Expression基类</code> 转换为指定的 <code>Expression派生类</code>，当转换失败时，会返回空指针，这样我们可以通过返回的指针来判断是否是想要的 Expression，如果为空，就代表是另一个 Expression。</p><p>由于谓词中很有可能是 <code>LogicExpression</code> 嵌套着 <code>LogicExpression</code> 和 <code>ComparationExpression</code>，数量也不确定，且子 <code>LogicExpression</code> 很可能还有嵌套，这样的话使用<strong>递归</strong>来处理就非常方便。</p><h3 id=实现-hash-join>实现 Hash Join<a hidden class=anchor aria-hidden=true href=#实现-hash-join>#</a></h3><p>hash join 的核心就是：先对一张表建立哈希映射，然后再对另一张表进行哈希检测来判断是否满足连接条件。哈希表中的 key 为连接条件中对应的值的拼接，value 为整个 tuple。而一张表中的所有 tuple，很有可能会有几个列是完全相同的，如果这些列刚好作为连接条件，那进行哈希时就会造成 key 相同的情况，这就造成了<strong>哈希碰撞</strong>。</p><p>解决方法也很简单：</p><ol><li>使用 <code>std::unordered_map</code>，将拼接的列值作为 key，而值的类型为 <code>std::vector&lt;Tuple></code>;</li><li>使用 <code>std::unordered_multimap</code> 来处理。</li></ol><p>当我们构建好哈希表后，每次获取了另一张表中的 tuple 后进行一次哈希检测，如果 key 存在，需要将所有 value 都进行连接拼接。同 nested loop join 一样，需要特殊处理连接类型为 <code>left</code> 的情况。</p><h2 id=task4---sort--limit-executors--window-functions--top-n-optimization>Task4 - Sort + Limit Executors + Window Functions + Top-N Optimization<a hidden class=anchor aria-hidden=true href=#task4---sort--limit-executors--window-functions--top-n-optimization>#</a></h2><h3 id=sort>Sort<a hidden class=anchor aria-hidden=true href=#sort>#</a></h3><p>这个算子的实现思路很简单，但是需要注意两点：</p><ol><li><code>order by</code> 后面可以跟多个关键字，也就是需要在 <code>std::sort</code> 中对<strong>多个关键字进行排序</strong>（利用 for 循环）。</li><li>这些关键字中可能进行算数运算（算数对象类型为 <code>ArithmeticExpression</code>，搞清楚进行运算的函数就可）。</li></ol><h3 id=limit>Limit<a hidden class=anchor aria-hidden=true href=#limit>#</a></h3><p>这个就更简单了，根据 <code>limit</code> 的返回对应数量的 tuple。</p><h3 id=topn>TopN<a hidden class=anchor aria-hidden=true href=#topn>#</a></h3><p>topn 算子的优化只有 sort 和 limit 同时出现的是否才会触发，这里的优化逻辑比较简单。</p><p>而具体的算子的实现其实就是一个<strong>优先队列</strong>。举个例子，现在 tuple 按照某个关键字升序排列，并且 limit 为 10，那么就可以构造一个小根堆，并维护其大小最多为 10，最后留在堆中的就是结果。如果力扣刷了一点题的话很容易就能理解这里。</p><h3 id=window-function>Window Function<a hidden class=anchor aria-hidden=true href=#window-function>#</a></h3><p>说来惭愧，学 SQL 的时候并不知道窗口函数这个东西&mldr;简单来理解，就是在使用聚合函数的后面加上 <code>over ([可选操作])</code> 即可对<strong>区间</strong>进行聚合操作。</p><p>对于下面的 SQL，最后输出的 schema 应该和 <code>WindowFunc.columns</code> 相同，<strong>并且行数也和子 executor 返回的行数相同</strong>（下文将子 executor 返回的 tuple 称为 <code>child_tuples</code>），只是多了一些额外的计算列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>bustub</span><span class=o>&gt;</span><span class=w> </span><span class=k>explain</span><span class=p>(</span><span class=n>o</span><span class=p>)</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=n>v1</span><span class=p>,</span><span class=w>  </span><span class=k>min</span><span class=p>(</span><span class=n>v1</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>min_v1</span><span class=p>,</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=n>v1</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>max_v1</span><span class=p>,</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=n>v1</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>count_v1</span><span class=p>,</span><span class=w> </span><span class=k>sum</span><span class=p>(</span><span class=n>v1</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sum_v1</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>===</span><span class=w> </span><span class=n>OPTIMIZER</span><span class=w> </span><span class=o>===</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>WindowFunc</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>columns</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>placeholder</span><span class=p>,</span><span class=w> </span><span class=n>placeholder</span><span class=p>,</span><span class=w> </span><span class=n>placeholder</span><span class=p>,</span><span class=w> </span><span class=n>placeholder</span><span class=p>,</span><span class=w> </span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>window_functions</span><span class=o>=</span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>1</span><span class=o>=&gt;</span><span class=err>{</span><span class=w> </span><span class=n>function_arg</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>min</span><span class=p>,</span><span class=w> </span><span class=n>partition_by</span><span class=o>=</span><span class=p>[],</span><span class=w> </span><span class=n>order_by</span><span class=o>=</span><span class=p>[]</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>2</span><span class=o>=&gt;</span><span class=err>{</span><span class=w> </span><span class=n>function_arg</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>max</span><span class=p>,</span><span class=w> </span><span class=n>partition_by</span><span class=o>=</span><span class=p>[],</span><span class=w> </span><span class=n>order_by</span><span class=o>=</span><span class=p>[]</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>3</span><span class=o>=&gt;</span><span class=err>{</span><span class=w> </span><span class=n>function_arg</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>count</span><span class=p>,</span><span class=w> </span><span class=n>partition_by</span><span class=o>=</span><span class=p>[],</span><span class=w> </span><span class=n>order_by</span><span class=o>=</span><span class=p>[]</span><span class=w> </span><span class=err>}</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>4</span><span class=o>=&gt;</span><span class=err>{</span><span class=w> </span><span class=n>function_arg</span><span class=o>=#</span><span class=mi>0</span><span class=p>.</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=k>type</span><span class=o>=</span><span class=k>sum</span><span class=p>,</span><span class=w> </span><span class=n>partition_by</span><span class=o>=</span><span class=p>[],</span><span class=w> </span><span class=n>order_by</span><span class=o>=</span><span class=p>[]</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>SeqScan</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>table</span><span class=o>=</span><span class=n>t1</span><span class=w> </span><span class=err>}</span><span class=w>
</span></span></span></code></pre></div><p>在这条 SQL 中，返回的 tuple 的格式应该为：</p><table><thead><tr><th>这条 tuple 的 v1 列的值</th><th>所有 tuple 中最小的 v1 的值</th><th>所有 tuple 中最大的 v1 的值</th><th>所有 tuple 中 v1 的个数</th><th>所有 tuple 中 v1 的值的和</th></tr></thead></table><p>这其实和 <code>WindowFunc.columns</code> 有很大的关系，placeholder 说明这只是个占位符，其应该为 <code>window_functions[下标]</code> 对应的窗口函数。例如第二个 placeholder 在 columns 的下表为 1，其对应的窗口函数就是 <code>{ function_arg=#0.0, type=min, partition_by=[], order_by=[] }</code>。那么就可以通过 column 来找到每个窗口对应的哈希表。</p><p>️需要注意的是：</p><ul><li>如果按照 <code>ORDER BY</code> 进行排序后，每一行的窗口范围从第一行开始扩展到当前行</li><li>否则每一行的窗口范围是整个 <code>child_tuples</code></li></ul><p>既然如此，我们需要先从 <code>child_executor</code> 获取到所有的 <code>child_tuples</code>，然后对 <code>child_tuples</code> 遍历：如果有分组行为，那就需要按照某一列（或多列）进行分组，然后对于每一个 tuple，都让其执行一次 <code>WindowFunc.window_functions</code> 中的窗口函数。</p><blockquote><p>稍有不同的是，之前的 aggregation 操作分组后可能需要完成多个聚合函数，但是这里我们分组之后，只会完成一个聚合函数，因为每个窗口中只有一个聚合函数。</p></blockquote><p>现在看来，这个窗口函数也无非就是对某个范围内的 tuple 进行分组和聚合操作，实验指导中也提示我们可以去利用 task2 中写的代码。在我的实现方案中，并不像 task2 中只使用一个哈希表，因为在一条 SQL 函数中，可能有多个窗口函数，每一个窗口函数又可能又不同的分组和不同的聚合操作，因此我对于每一个窗口函数都设置了一个哈希表。</p><p>该 task 中 bustub 很仁慈地简化了难度：<u>如果窗口函数任意一个中有 order by，那么所有窗口函数的 order by 都相同</u>。不过在有排序和没有排序的情况下，窗口的范围有所不同，处理起来的方法也不同。</p><h4 id=无排序的情况>无排序的情况<a hidden class=anchor aria-hidden=true href=#无排序的情况>#</a></h4><p>这个情况下，每个窗口函数的范围就是整个 <code>child_tuples</code>。之后再次遍历每一条 tuple，按照输出的 schema 来构建返回的 tuple。那么实现操作应该如下：</p><p><strong>先描所有 tuple，生成这条 tuple 对应的 key 和 value，再把 key 和 value 加入对应的哈希表。</strong></p><p>然后对于每一条 tuple，遍历 <code>WindowFunc.columns</code>：</p><ol><li>如果 column 不是 placeholder，那么说明这个位置是这个 tuple 中的一列，获取这一列对应的 Value 就好。</li><li>如果 column 是 placeholder，那么说明这个位置的值应该是对应的窗口函数的执行结果，那么从 column 对应的哈希表中找出这个 tuple 对应的值就 ok。</li></ol><h4 id=有排序的情况>有排序的情况<a hidden class=anchor aria-hidden=true href=#有排序的情况>#</a></h4><p>在这个情况下，排序号后每条 tuple 的范围是自身及之前的所有 tuple，而不是像之前一样的所有 tuple。这就有点像一句话：<strong>“走一步看一步”</strong>。</p><p>还是遍历每一条 tuple，对每一条 tuple 又遍历 <code>WindowFunc.columns</code>：</p><ol><li>如果 column 不是 placeholder，那么说明这个位置是这个 tuple 中的一列，获取这一列对应的 Value 就好。这里和无排序的情况一致。</li><li>如果 column 是 placeholder，<ol><li>生成这条 tuple 对应的 key</li><li>生成这条 tuple 对应的 value，并将 <code>{key, value}</code> 插入 column 对应的哈希表（在 task2 中可知，这里的“插入”其实是对 key 处的旧值 old_value 与新值 value 进行聚合操作）</li><li>从哈希表中取出 key 对应的 value</li></ol></li></ol><p>这里的 2.2 和 2.3 就是之前所说的“走一步看一步”：<strong>当前 tuple 的结果是在之前的 tuple 上聚合而来的</strong>。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>这个 Project 需要我们去深入理解 bustub 的源码，知道一条 SQL 会被解析成一棵什么样的 plan 树，在经过基于规则的优化器优化后才会是最终的物理 plan 树，这时又要去理解这棵树上每个节点对应的算子应该是怎么实现的。其实知道了 plan 树是什么样子后，节点对应的算子就按照要求去设计就好了。</p><p>在众多 AI 例如 ChatGPT、DeepSeek、Kimi 等帮助下，还是慢慢理解并完成了这个 Project！但是有的地方我可能还没有做的比较好，以后有时间再优化一下。</p><p><img loading=lazy src=https://obsidian-image-oss.oss-cn-shanghai.aliyuncs.com/Pasted%20image%2020250311201509.png></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://kerolt.github.io/posts/c++/c++%E4%BD%95%E6%97%B6%E4%BC%9A%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/><span class=title>« Prev</span><br><span>C++何时会阻止默认的特殊成员函数的生成</span>
</a><a class=next href=https://kerolt.github.io/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/hugo%E9%85%8D%E7%BD%AEgithub-actions/><span class=title>Next »</span><br><span>Hugo配置Github Actions</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kerolt.github.io/>Kerolt's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>